import ds/reducer;
import material/material;
import material/material2tropic;
import formats/dom/render;

/*
TODO:
- Update the RAssign. Have a wrapper which uses behaviours?
- Try a version using HTML. Can we express a reducer for HTML?

  html.body.p = "Hello world";
  html.body.p.style = "Bold";

- Figure out how assignments can be compositional: Introduce RAssigns
*/

REditor(
	document : Behaviour<[RAssign<?>]>,
	// Where are the cursors?
	cursor : Behaviour<[RLValue]>,
	// What leading path are we focusing on?
	focus : Behaviour<RLValue>,
	// What elements are selected?
	selected : Behaviour<[RLValue]>,
	// What elements are collapsed?
	collapsed : Behaviour<[RLValue]>,
	// How to edit a given value
	editValue : (e : RAssign<?>, cursor : bool, selected : bool) -> Material,
);

makeView(e : REditor<?>) -> Material {
	MSelect3(
		e.document, e.cursor, e.selected,
		\assigns : [RAssign<?>], cursor, selected -> {
			MLines(
				map(
					assigns,
					\a -> {
						e.editValue(a, contains(cursor, a.lvalue), contains(selected, a.lvalue))
					}
				)
			)
		}
	);
}

makeREditor(doc : [RAssign<?>], editFn : (e : RAssign<?>, cursor : bool, selected : bool) -> Material) -> REditor {
	REditor(
		make(doc),
		make(if (doc != []) [doc[0].lvalue] else []),
		make(RLeaf()),
		make([]),
		make([]),
		editFn
	);
}


viewRAssignJson(l : RAssign<Json>, cursor : bool, selected : bool) -> Material {
	todo = \ -> MText("todo", []);
	MBaselineCols([
		viewRLValue(l.lvalue),
		switch (l.value : Json) {
			JsonObject(members): todo();
			JsonArray(value): todo();
			JsonNull(): MText("null", []);
			JsonBool(v): MCheckBox(MText("bool",[]), make(v), []);
			JsonString(s): MTextInput(make(s), [], []);
			JsonDouble(value): MTextInput(make(d2s(value)), [], []);
		}
	])
}

// This is called for all leafs
viewRAssignHtml(l : RAssign<Json>, cursor : bool, selected : bool) -> IXmlNode {
	dom2ixml(switch (l.value) {
		JsonObject(members): eP("Object");
		JsonArray(value): eP("Array");
		JsonNull(): eP("null");
		JsonBool(v): eP(b2s(v));
		JsonDouble(v): eP(d2s(v));
		JsonString(s): eP(escapeHtml(s));
	});
}

jsonAssign2htmlAssign(l : RAssign<Json>, cursor : bool, selected : bool) -> RAssign<IXmlNode> {
	RAssign(
		jsonLValue2HtmlLValue(l.lvalue),
		viewRAssignHtml(l, cursor, selected)
	)
}

jsonLValue2HtmlLValue(l : RLValue) -> RLValue {
	switch (l) {
		RLeaf(): RLeaf();
		RLObject(key, lvalue): {
			RLArray(
				RLObject("div", jsonLValue2HtmlLValue(lvalue)) // TODO: What about the key?
			);
		}
		RLArray(rvalue): RLArray(jsonLValue2HtmlLValue(rvalue));
	}
}

viewRLValue(l : RLValue) -> Material {
	switch (l) {
		RLeaf(): MText(": ", []);
		RLObject(key, rvalue): MCols([MText(key + ".", []), viewRLValue(rvalue)]);
		RLArray(rvalue): MCols([MText("[]", []), viewRLValue(rvalue)]);
	}
}

main() {
	json1 = parseJson("
		{
			a: 0,
			b: [
				1,
				2,
				3
			],
			c: {
				d: true,
				e: null
			}
		}
	");

/*
a = 0
b[] = 1
b[] = 2
b[] = 3
c.d = true
c.e = null

	<div>  a  0 </div>
	<div>  b 
			<div>1</div>
			<div>2</div>
			<div>3</div>
	</div>
	<div>  c
		<div> d  true </div>
		<div> e  null </div>
	<div>
*/
	editor = makeREditor(rreduceJson(json1, rarray()), viewRAssignJson);

	assigns = getValue(editor.document);

	htmlAssigns = map(assigns, \a -> jsonAssign2htmlAssign(a, false, false));
	iter(htmlAssigns, println);

/*	mrender(
		makeMaterialManager([]), true,
		makeView(editor)
	);*/
	quit(0);
}


/*
RAssigns(
	assignments : [RAssign]
)

renderComap(p : Topic) -> RAssigns {
	html.body.p = renderTopic(p);
}

renderComap(Reducer<Topic>) -> Reducer<Html>;

Curator:

renderTopic(p : Topic) -> RAssigns {
	RAssigns(
		[
			table.tr[0] = RAssigns([
				td[0] = p.topic;
				rowspan = length(p.children());
				yalign = center;
			]),
			mapi(p.children(), \i, child -> {
				table.tr[i].td[1] = renderTopic(child);
			})
		]
	)
}

htmlRAssign(acc : MHTMLStage, assign : RAssign<string>) -> MHTMLStage {

}

*/
