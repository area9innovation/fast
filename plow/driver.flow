import plow/pexp/parse;
import plow/dexp/desugar;
import plow/types/typeinference;
import plow/bexp/btype2ttype;
import plow/bexp/pretty;
import plow/lookup;

import plow/tracing;

import fast/fast_path;
import plow/plowcache;

export {
	// Parse, desugar and type a file, and all the transitive imports
	compilePlow(cache : PlowCache, file : string) -> BModule;
}

compilePlow(cache : PlowCache, file : string) -> BModule {
	path = fastPath2path(cache.includes, changeFileExt(file, ".flow"));
	flowpath = path2fastPath(cache.includes, path);

	// TODO: We could add a "stop" flag and cancel compilation in those cases
	if (hasCachedBModule(cache.modules, flowpath)) {
		getCachedBModule(cache.modules, flowpath);
	} else if (^(cache.errorCount) != 0) {
		// We stop if there are errors
		println("Stops compilation because of errors: " + flowpath);
		getDummyBModule();
	} else if (hasIncrementalBModule(cache.tracing, cache.modules, path, flowpath)) {
		// OK, we have an incremental module, which we read now
		bmod = getCachedBModule(cache.modules, flowpath);
		// Then make sure we have all dependents as well
		sequential(false, map(bmod.imports, \i -> {
			\ -> compilePlow(cache, i.path)
		}));
		bmod;
	} else if (containsSet(^(cache.awaiting), flowpath)) {
		getDummyBModule();
	} else if (fileExists(path)) {
		// We should mark this as being processed,
		// so we do not concurrently do the same file many times
		cache.awaiting := insertSet(^(cache.awaiting), flowpath);

		// OK, we have to parse this
		code = getFileContent(path);

		p = parsePExp(code, \e -> cache.onError(path + ":" + e));
		if (isTracingId(cache.tracing, StageParse(), 0, flowpath)) {
			println("Parsed '" + file + "' as " + path);
		}

		// OK, parse all the dependent files
		imports = getDImports(p);
		// TODO: fix this so that concurrent running of imports compilation 
		// wouldn't hang
		sequential(false, map(imports, \i -> {
			\ -> compilePlow(cache, i.path)
		}));

		if (^(cache.errorCount) > 0) {
			println("Stops compilation because of errors: " + flowpath);
			getDummyBModule();
		} else {
			dd = makeDDesugar(cache.tracing, makeOnError(path, cache.onError), cache.nextId, 
				// resolveStructName
				\n -> {
					// OK, scan our imports for this struct
					lookupFromImport(cache.modules, cache.structLookup, imports, n);
				}, 
				// resolveUnionName
				\n -> {
					// OK, scan our imports for this union
					lookupFromImport(cache.modules, cache.unionLookup, imports, n)
				}
			);

			dmod = desugarPExp(dd, flowpath, path, p);

			tenv0 = makeTTypeEnv(dd.onError, dmod);
			// Register unions and subtyping relations into the global lookup
			updateSubtyping(cache, tenv0.bmodule);
			tenv1 = updateNameLookupsForImports(cache, dd, tenv0, imports);
			bmodule = ttypeInference(tenv1, dmod);

			setCachedBModule(cache.modules, flowpath, bmodule);

			if (^(cache.errorCount) != 0) {
				// OK, there are errors, so remove any incremental
				deleteBModule(cache.tracing, flowpath)
			} else {
				writeBModule(cache.tracing, bmodule);
			}

			// OK, clear the name lookup cache
			clearPlowCache(cache);

			if (isTracingId(tenv1.tracing, StageLower(), 1, flowpath)) {
				println(prettyBModule(bmodule));
			}

			bmodule;
		}
	} else {
		cache.onError(file + " could not be found");
		getDummyBModule();
	}
}

// Given this module, looks up names from imports
updateNameLookupsForImports(cache : PlowCache, dd : DDesugar, env : TTypeEnv, imports : [DImport]) -> TTypeEnv {
	TTypeEnv(
		env with
		resolveId = \pos, id -> {
			mbmod : Maybe<BGlobal> = lookupFromImport(cache.modules, cache.globalLookup, imports, id);
			mbmod ?? {
				btype2ttype(mbmod.type);
			} : {
				mbnat : Maybe<BNative> = lookupFromImport(cache.modules, cache.nativeLookup, imports, id);
				switch (mbnat) {
					None(): {
						dd.onError(pos, "Unknown id " + id);
						TTypeEClass(makeTNodeClass(env.tmap));
					}
					Some(bnat): btype2ttype(bnat.type);
				}
			}
		},
		resolveField = \id -> {
			structs : [string] = lookupsFromImport(cache.modules, cache.fieldLookup, imports, id);
			filtermap(structs, \str -> {
				dd.resolveStructName(str);
			})
		},
		resolveUnionField = \id -> {
			buildSet(lookupsFromImport(cache.modules, cache.unionFieldLookup, imports, id));
		},
		resolveSupertypes = \id -> {
			if (true) {
				// TODO: Filter to those reachable from the module
				getTreeArrayValue(^(cache.globalSupertypes), id);
			} else {
				lookupsFromImport(cache.modules, cache.superTypeLookup, imports, id);
			}
		},
		resolveSubtypes = \id -> {
			if (true) {
				// TODO: Filter to those reachable from the module
				getTreeArrayValue(^(cache.globalSubtypes), id);
			} else {
				lookupsFromImport(cache.modules, cache.subTypeLookup, imports, id);
			}
		},
		resolveStructName = dd.resolveStructName,
		resolveUnionName = dd.resolveUnionName
	);
}
