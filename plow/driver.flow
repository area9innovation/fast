import plow/pexp/parse;

import plow/lookup;

import plow/dexp/dexp;
import plow/dexp/desugar;
import plow/dexp/pretty;

import plow/types/typeinference;

import plow/bexp/dmodule2bmodule;
import plow/bexp/pretty;
import plow/bexp/btype2ttype;

import fast/fast_path;

export {
	// Constructs a compilation cache
	makePlowCache(
		// How to report an error
		onError : (string) -> void,
		// The includes we should use to find files
		includes : [string]
	) -> PlowCache;

	// Parse, desugar and type a file, and all the transitive imports
	compilePlow(cache : PlowCache, file : string) -> BModule;
}

PlowCache(
	// How to report an error
	onError : (string) -> void,
	// The includes we should use to find files
	includes : [string], 
	// Map of the Modules we have already parsed and desugared
	modules : BModules,
	// Helpers to look up things in imports
	structLookup : BLookupFromImport<DStruct>,
	unionLookup : BLookupFromImport<DUnion>,
	fieldLookup : BLookupFromImport<[string]>,
	superTypeLookup : BLookupFromImport<[string]>,
	globalLookup : BLookupFromImport<BGlobal>,
	nativeLookup : BLookupFromImport<BNative>,
	// What is the next id
	nextId : ref int,
);

makePlowCache(
	// How to report an error
	onError : (string) -> void,
	// The includes we should use to find files
	includes : [string]
) -> PlowCache {
	// A helper to lookup structs.
	structLookup = BLookupFromImport(\module, n -> {
			lookupTree(module.structs, n)
		}, \module, n -> {
			containsSet(module.exported.exportedTypes, n)
			|| containsSet(module.exported.exportedTypeNames, n)
		},
		\spath, struct, error -> {
			makeOnError(spath, onError)(struct.pos, error)
		},
		ref makeTree(), ref makeSet()
	);

	// A helper to lookup unions.
	unionLookup = BLookupFromImport(\module, n -> {
			lookupTree(module.unions, n)
		}, 
		\module, n -> {
			containsSet(module.exported.exportedTypes, n)
			|| containsSet(module.exported.exportedTypeNames, n)
		},
		\upath, struct, error -> {
			makeOnError(upath, onError)(struct.pos, error)
		},
		ref makeTree(), ref makeSet()
	);

	globalLookup = BLookupFromImport(\module, n -> {
			lookupTree(module.globals, n);
		},
		\module, n -> {
			containsSet(module.exported.exportedGlobals, n)
		},
		\upath, gl, error -> {
			makeOnError(upath, onError)(gl.pos, error)
		},
		ref makeTree(), ref makeSet()
	);
	nativeLookup = BLookupFromImport(\module, n -> {
			lookupTree(module.natives, n);
		},
		\module, n -> {
			containsSet(module.exported.exportedGlobals, n);
		},
		\upath, nat, error -> {
			makeOnError(upath, onError)(nat.pos, error)
		},
		ref makeTree(), ref makeSet()
	);
	fieldLookup = BLookupFromImport(\module, n -> {
		lookupTree(module.fields, n);
	}, \module, n -> {
		structs = getTreeArrayValue(module.fields, n);
		// TODO: Maybe this is too much. We should probably just restrict
		// to those that are exported
		forall(structs, \s -> {
			containsSet(module.exported.exportedTypes, s)
		})
	}, \upath, n, error -> {
		println("TODO: What about the position of this field?");
		makeOnError(upath, onError)(0, error)
	}, ref makeTree(), ref makeSet()
	);

	superTypeLookup = BLookupFromImport(\module, n -> {
		supers = makeDSupers(module.unions);
		Some(getTreeArrayValue(supers, n));
	}, \module, n -> {
		true;
	}, \upath, nat, error -> {
		println("TODO: What about the position of this field?");
		makeOnError(upath, onError)(0, error)
	}, ref makeTree(), ref makeSet()
	);

	PlowCache(
		onError, includes, makeBModules(), 
		structLookup, unionLookup, fieldLookup, superTypeLookup,
		globalLookup, nativeLookup,
		ref 0
	);
}

compilePlow(cache : PlowCache, file : string) -> BModule {
	path = fastPath2path(cache.includes, changeFileExt(file, ".flow"));
	flowpath = path2fastPath(cache.includes, path);

	// TODO: We could add a "stop" flag and cancel compilation in those cases
	if (hasCachedBModule(cache.modules, flowpath)) {
		getCachedBModule(cache.modules, flowpath);
	} else if (fileExists(path)) {
		// OK, we have to parse this
		code = getFileContent(path);

		p = parsePExp(code, \e -> cache.onError(path + ":" + e));
		println("Parsed " + file + " as " + path);

		// OK, parse all the dependent files
		imports = getDImports(p);
		mods = concurrent(false, map(imports, \i -> {
			\ -> compilePlow(cache, i.path)
		}));

		dd = makeDDesugar(makeOnError(path, cache.onError), cache.nextId, \n -> {
				// OK, scan our imports for this struct
				lookupFromImport(cache.modules, cache.structLookup, imports, n)
			}, \n -> {
				// OK, scan our imports for this struct
				lookupFromImport(cache.modules, cache.unionLookup, imports, n)
			});

		dmod = desugarPExp(dd, flowpath, path, p);

		tenv1 = TTypeEnv(
			makeTTypeEnv(dd.tgraph) with
			onError = dd.onError,
			resolveId = \pos, id -> {
				mbmod : Maybe<BGlobal> = lookupFromImport(cache.modules, cache.globalLookup, imports, id);
				mbmod ?? {
					btype2ttype(mbmod.type);
				} : {
					mbnat : Maybe<BNative> = lookupFromImport(cache.modules, cache.nativeLookup, imports, id);
					switch (mbnat) {
						None(): {
							dd.onError(pos, "Unknown id " + id);
							TTypeEClass(emptyTTypeClass(dd.tgraph));
						}
						Some(bnat): btype2ttype(bnat.type);
					}
				}
			},
			resolveField = \id -> {
				mstructs : Maybe<[string]> = lookupFromImport(cache.modules, cache.fieldLookup, imports, id);
				mstructs ?? {
					filtermap(mstructs, \str -> {
						dd.resolveStructName(str);
					})
				} : []
			},
			resolveSupertypes = \id -> {
				lookupsFromImport(cache.modules, cache.superTypeLookup, imports, id);
			},
			resolveStructName = dd.resolveStructName,
			resolveUnionName = dd.resolveUnionName
		);
		tenv = ttypeInference(tenv1, dmod);

		benv = BExpEnv(tenv.onError, tenv.tgraph, tenv.etypes);
		bmodule = dmodule2bmodule(benv, dmod);

		setCachedBModule(cache.modules, flowpath, bmodule);

		if (true) {
			prettyDModule(tenv, dmod);
		}
		if (false) {
			println(prettyBModule(bmodule));
		}

		bmodule;
	} else {
		cache.onError(file + " could not be found");
		getDummyBModule();
	}
}

makeOnError(file : string, onError : (string) -> void) -> (int, string) -> void {
	resolver = ref None();
	\pos, error -> {
		res = onlyOnce(resolver, \ -> {
			text = getFileContent(file);
			makeLineResolver(text);
		});
		linecol = findLine(res, pos); // maxi
		onError(
			file + ":" + i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": " + error
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	}
}
