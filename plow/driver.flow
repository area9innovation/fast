import plow/dexp/dexp;
import plow/dexp/desugar;
import plow/dexp/pretty;

import plow/pexp/parse;

import plow/lookup;

import fast/fast_path;

import sys/concurrent;

export {
	// Constructs a compilation cache
	makePlowCache(
		// How to report an error
		onError : (string) -> void,
		// The includes we should use to find files
		includes : [string]
	) -> PlowCache;

	// Parse and desugar a file, and all the transitive imports
	compilePlow(cache : PlowCache, file : string) -> DModule;
}

PlowCache(
	// How to report an error
	onError : (string) -> void,
	// The includes we should use to find files
	includes : [string], 
	// Map of the Modules we have already parsed and desugared
	modules : DModules,
	// What is the next id
	nextId : ref int,
);

makePlowCache(
	// How to report an error
	onError : (string) -> void,
	// The includes we should use to find files
	includes : [string]
) -> PlowCache {
	PlowCache(onError, includes, DModules(initConcurrentHashMap()), ref 0);
}

compilePlow(cache : PlowCache, file : string) -> DModule {
	path = fastPath2path(cache.includes, changeFileExt(file, ".flow"));
	flowpath = path2fastPath(cache.includes, path);

	if (containsConcurrentHashMap(cache.modules.modules, flowpath)) {
		getConcurrentHashMap(cache.modules.modules, flowpath, getDummyDModule());
	} else if (fileExists(path)) {
		// OK, we have to parse this
		code = getFileContent(path);

		p = parsePExp(code, \e -> cache.onError(path + ":" + e));
		println("Parsed " + file + " as " + path);

		// OK, parse all the dependent files
		imports = getDImports(p);
		mods = concurrent(false, map(imports, \i -> {
			\ -> compilePlow(cache, i.path)
		}));

		if (true) {
			iter(mods, prettyDModule)
		}

		// A helper to lookup structs. TODO: Should this be in the plowcache?
		structLookup = DImportLookup(\module, n -> {
				lookupTree(module.structs, n)
			}, \module, n -> {
				containsSet(module.exported.exportedTypes, n)
			},
			\spath, struct, error -> {
				makeOnError(spath, cache.onError)(struct.pos, error)
			},
			ref makeTree(), ref makeSet()
		);

		// A helper to lookup unions. TODO: Should this be in the plowcache?
		unionLookup = DImportLookup(\module, n -> {
				lookupTree(module.unions, n)
			}, 
			\module, n -> {
				containsSet(module.exported.exportedTypes, n)
			},
			\upath, struct, error -> {
				makeOnError(upath, cache.onError)(struct.pos, error)
			},
			ref makeTree(), ref makeSet()
		);

		dd = makeDDesugar(path, cache, \n -> {
				// OK, scan our imports for this struct
				importLookup(cache.modules, structLookup, imports, n)
			}, \n -> {
				// OK, scan our imports for this struct
				importLookup(cache.modules, unionLookup, imports, n)
			});

		dmod = desugarPExp(dd, flowpath, path, p);

		setConcurrentHashMap(cache.modules.modules, flowpath, dmod);

		dmod;
	} else {
		cache.onError(file + " could not be found");
		getDummyDModule();
	}
}

makeDDesugar(path : string, cache : PlowCache, 
		resolveStructName : (string) -> Maybe<DStruct>,
		resolveUnionName : (string) -> Maybe<DUnion>) -> DDesugar {
	tyvarId = ref 0;
	DDesugar(resolveStructName, resolveUnionName, 
		makeOnError(path, cache.onError), 
		cache.nextId,
		\ -> {
			atomicRefIntAddition(tyvarId, 1);
			^tyvarId;
		}
	);
}

makeOnError(file : string, onError : (string) -> void) -> (int, string) -> void {
	resolver = ref None();
	\pos, error -> {
		res = onlyOnce(resolver, \ -> {
			text = getFileContent(file);
			makeLineResolver(text);
		});
		linecol = findLine(res, pos); // maxi
		onError(
			file + ":" + i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": " + error
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	}
}
