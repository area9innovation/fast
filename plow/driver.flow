import plow/dexp/dexp;
import plow/dexp/desugar;
import plow/pexp/parse;

import plow/lookup;

import fast/fast_path;

import sys/concurrent;

export {
	compilePlow(cache : PlowCache, file : string) -> Maybe<DModule>;

	PlowCache(
		// How to report an error
		onError : (string) -> void,
		// The includes we should use to find files
		includes : [string], 
		// Map of the Modules we have already parsed and desugared
		modules : DModules,
	);
}

compilePlow(cache : PlowCache, file : string) -> Maybe<DModule> {
	path = fastPath2path(cache.includes, changeFileExt(file, ".flow"));
	flowpath = path2fastPath(cache.includes, path);

	if (containsConcurrentHashMap(cache.modules.modules, flowpath)) {
		Some(getConcurrentHashMap(cache.modules.modules, flowpath, getDummyDModule()));
	} else {
		// OK, we have to parse this
		code = getFileContent(path);

		p = parsePExp(code, \e -> cache.onError(path + ":" + e));
		println("Parsed " + file + " as " + path);

		// OK, parse all the dependent files
		imports = getDImports(p);
		mods = concurrent(false, map(imports, \i -> {
			\ -> compilePlow(cache, i.path)
		}));

		// A helper to lookup structs
		structLookup = DImportLookup(cache.modules, \module, n -> {
			lookupTree(module.structs, n)
		}, ref makeTree(), ref makeSet());

		// A helper to lookup unions
		unionLookup = DImportLookup(cache.modules, \module, n -> {
			lookupTree(module.unions, n)
		}, ref makeTree(), ref makeSet());

		dd = DDesugar(flowpath, \n -> {
			// OK, scan our imports for this struct
			structLookup.visited := makeSet();
			importLookup(structLookup, imports, n)
		}, \n -> {
			// OK, scan our imports for this struct
			unionLookup.visited := makeSet();
			importLookup(unionLookup, imports, n)
		}, makeOnError(path, cache.onError));

		dmod = desugarPExp(dd, p);

		setConcurrentHashMap(cache.modules.modules, flowpath, dmod);
		Some(dmod);
	}
}

makeOnError(file : string, onError : (string) -> void) -> (int, string) -> void {
	resolver = ref None();
	\pos, error -> {
		res = onlyOnce(resolver, \ -> {
			text = getFileContent(file);
			makeLineResolver(text);
		});
		linecol = findLine(res, pos); // maxi
		onError(
			file + ":" + i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": " + error
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	}
}

/*transitiveModuleSearch(visited : Set<string>, modules : [DModule], fn : (?) -> Maybe<??>) -> Maybe<??> {
	fold2(modules, visited, None(), \nvisit, acc, module -> {
		if (acc == None()) {
			mfind = fn(module);
			mfind ?? {
				Pair(nvisit, Some(mfind))
			} : {

			}
		} else Pair(nvisit, acc);
	});
}
*/