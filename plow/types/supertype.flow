import plow/types/typeenv;
import plow/types/util;
import plow/types/polymorphism;

export {
	// This attempts to resolve a set of subtypes
	resolveTSupertype(env : TTypeEnv, super : TTypeSupertype) -> TType;
}

resolveTSupertype(env : TTypeEnv, super : TTypeSupertype) -> TType {
	namedsupers = foldSet(super.subtypes, makeSet(), \acc, st -> {
		switch (st) {
			TTypeName(id, typars): {
				supers0 = env.resolveSupertypes(id);
				supers = if (supers0 == []) [id] else supers0;
				supset = buildSet(supers);
				if (isEmptySet(acc)) supset
				else intersectSets(supset, acc)
			}
			default: acc;
		}
	});

	fnsupers = foldSet(super.subtypes, makeSet(), \acc, st -> {
		switch (st) {
			TTypeFunction(__, __): insertSet(acc, st);
			default: acc;
		}
	});

	if (sizeSet(namedsupers) == 1 && isEmptySet(fnsupers)) {
		name = set2array(namedsupers)[0];
		type = instantiateTTypeName(env, name);
		// println(name + " becomes " + prettyTType(type));
		type
	} else if (sizeSet(fnsupers) == 1 && isEmptySet(namedsupers)) {
		fn : TTypeFunction = set2array(fnsupers)[0];
		fn;
	} else {
		// OK, if we are dealing with functions or something like that, we could
		// probably "expand" them
		super;
	}
}
