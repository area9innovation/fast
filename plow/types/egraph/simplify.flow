import plow/types/typeenv;
import plow/types/egraph/extract;
import plow/types/unify;

export {
	// Given a set of enodes in an equivalence class, find out how
	// we can refine those
	unifyENodes(env : TTypeEnv, root : int, nodes : Set<ENode<TType>>) -> [ENodesUnify];

		// Structure that defines what operations we should do on the eclasses
		ENodesUnify ::= EClassMerge, EClassInsert, EUnifyTypes;
			// Merge two classes
			EClassMerge(leftClass : int, rightClass : int);
			EClassInsert(root : int, node : ENode<TType>);
			EUnifyTypes(root : int, types : Set<TType>);

	// Lets us know if there was any change
	applyENodesUnify(env : TTypeEnv, e : ENodesUnify) -> bool;
}

unifyENodes(env : TTypeEnv, root : int, nodes : Set<ENode<TType>>) -> [ENodesUnify] {
	// First, do general simplification
	simp = simplifyENodes(env, root, nodes);

	// Split members by the head
	heads : Tree<TType, [ENode<TType>]> = foldSet(nodes, makeTree(), \acc, node -> {
		treePushToArrayValue(acc, node.head, node);
	});
	foldTree(heads, simp, \head, simnodes : [ENode<TType>], acc -> {
		recurse = switch (head : TType) {
			TTypeName(id, typars): true;
			TTypeEClass(eclass): false;
			TTypeFunction(args, returnType): true;
			TTypeOverload(unique, overloads): false;
			TTypeSupertype(unique, subtypes): false;
		}
		if (recurse && length(simnodes) > 1) {
			// Unify children of the same head
			foldi(tail(simnodes), acc, \i, acc2, node -> {
				prev = simnodes[i];
				if (length(prev.args) == length(node.args)) {
					unifies = mapi(prev.args, \j, pr -> {
						EClassMerge(pr, node.args[j])
					});
					concat(acc2, unifies);
				} else {
					acc2;
				}
			})
		} else acc
	});
}

simplifyENodes(env : TTypeEnv, root : int, nodes : Set<ENode<TType>>) -> [ENodesUnify] {
	concatA([
//		simplifySupertypes(env, root, nodes),
		simplifyTOverloads(env, root, nodes),
	])
}

simplifySupertypes(env : TTypeEnv, root : int, nodes : Set<ENode<TType>>) -> [ENodesUnify] {
	// OK, first look for all supers, and combine them
	existingSupers : [ENode<TType>] = filter(set2array(nodes), \node -> {
		switch (node.head) {
			TTypeSupertype(__, __): true;
			default: false;
		}
	});

	// OK, find the super types to our supers
	allSupers : Set<int> = removeSet(fold(existingSupers, makeSet(), \acc, no -> {
		fold(no.args, acc, \acc2, arg -> {
			extractSupertypes(env, acc2, arg)
		});
	}), root);
	if (isEmptySet(allSupers)) {
		[]
	} else {
		newRoots = mapSet(allSupers, \a -> getEClassRoot(env.egraph, a));
		newNode : ENode<TType> = ENode(existingSupers[0].head, set2array(newRoots));
		// println("New supertype for " + i2s(root));

		// TODO: We could mark existingSupers as processed, so we do not do those next time

		[EClassInsert(root, newNode)];
	}
}

extractSupertypes(env : TTypeEnv, acc : Set<int>, eclass : int) -> Set<int> {
	nodes = getEClassNodes(env.egraph, eclass);
	foldSet(nodes, insertSet(acc, eclass), \acc2, node -> {
		switch (node.head) {
			TTypeSupertype(__, args): fold(node.args, acc2, \acc3, a -> {
				if (!containsSet(acc3, a)) {
					extractSupertypes(env, acc3, a)
				} else acc3;
			});
			default: acc2;
		}
	});
}

// Simplify any overloads based on any functions in the same equivalence class

simplifyTOverloads(env : TTypeEnv, root : int, nodes : Set<ENode<TType>>) -> [ENodesUnify] {
	if (containsKeyTree(env.etypes, root)) {
		[]
	} else {
		types = extractENodes(env, root, nodes);
		if (sizeSet(types) <= 1) {
			[];
		} else {
			[EUnifyTypes(root, types)];
		}
	}
}

applyENodesUnify(env : TTypeEnv, e : ENodesUnify) -> bool {
	switch (e) {
		EClassMerge(leftClass, rightClass): {
			if (leftClass == rightClass) false
			else {
				unionEClass(env.egraph, leftClass, rightClass);
				true;
			}
		}
		EClassInsert(root, node): {
			// println(prettyTType(node.head));
			switch (node.head) {
				TTypeEClass(eclass): false;
				default: {
					nroot = addENode(env.egraph, node);
					join = unionEClass(env.egraph, root, nroot);
					true;
				}
			}
		}
		EUnifyTypes(root, nodes): {
			foldSet(nodes, false, \acc, node1 -> {
				foldSet(nodes, acc, \acc2, node2 -> {
					if (node1 != node2) {
						// println(i2s(root) + ": " + prettyTType(node1) + " vs " + prettyTType(node2));
						unifyTType(env, -1, node1, node2);
						true;
					} else acc;
				})
			})
		}
	}
}
