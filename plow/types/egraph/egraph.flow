import plow/types/pretty;
import plow/types/split;
import ds/egraph;

// The idea with this file is to present the minimum interface
// that is required to work with equivalence classes for the types
export {
	makeTypeGraph(onError : (int, string) -> void) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// Get the (or construct a) type equivalence class for this type
	makeTTypeEClass(tg : TypeGraph, type : TType) -> int;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// Join these two types into the same equivalence class
	unifyTTypeEClass(tg : TypeGraph, pos : int, left : TType, right : TType) -> int;

	// After setting up all the relations, calls resolveEClasses from resolve.flow
	// which will populate the etypes in the TTypeEnv

	TypeGraph(
		egraph : EGraph<TType>,
		onError : (int, string) -> void,
	);
}


makeTypeGraph(onError : (int, string) -> void) -> TypeGraph {
	TypeGraph(
		makeEGraph(splitTType),
		onError
	)
}

emptyTTypeClass(tg : TypeGraph) -> int {
	makeEClass(tg.egraph);
}

makeTTypeEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): eclass;
		default: addTType2EGraph(tg, type);
	}
}

addTType2EGraph(tg : TypeGraph, e : TType) -> int {
	split : Pair<TType, [TType]> = tg.egraph.splitChildren(e);
	enode = ENode(split.first, map(split.second, \child -> {
		makeTTypeEClass(tg, child)
	}));
	addENode(tg.egraph, enode);
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	getEClassRoot(tg.egraph, eclass)
}

unifyTTypeEClass(tg : TypeGraph, pos : int, left : TType, right : TType) -> int {
	lroot = makeTTypeEClass(tg, left);
	rroot = makeTTypeEClass(tg, right);
	if (lroot != rroot) {
		root = unionEClass(tg.egraph, lroot, rroot);
		if (false) {
			tg.onError(pos, "Unify " + prettyTType(left) + " and " + prettyTType(right) + " (class " + i2s(lroot) + " and " + i2s(rroot) + " into eclass " + i2s(root));
		}
		root;
	} else lroot;
}
