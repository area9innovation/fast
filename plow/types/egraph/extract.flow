import plow/types/typeenv;
import plow/types/util;
import plow/types/pretty;
import plow/types/supertype;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(env : TTypeEnv) -> Tree<int, TType>;

	// Extract the types of a set of classes
	extractEClasses(env : TTypeEnv, eclasses : Set<int>) -> Set<TType>;
	extractENodes(env : TTypeEnv, eclass : int, enodes : Set<ENode<TType>>) -> Set<TType>;
}

extractEClassTypes(env : TTypeEnv) -> Tree<int, TType> {
	egraph = env.egraph;
	extract = extractEGraph(egraph, calculateTTypeBenefit);
	extractTTypes(ExtractEnv(env, extract, ref makeTree()));
}

extractEClasses(env : TTypeEnv, eclasses : Set<int>) -> Set<TType> {
	extract = extractEGraph(env.egraph, calculateTTypeBenefit);
	eenv = ExtractEnv(env, extract, ref makeTree());
	mapSet(eclasses, \eclass -> {
		extractTType(eenv, eclass);
	});
}

extractENodes(env : TTypeEnv, eclass : int, enodes : Set<ENode<TType>>) -> Set<TType> {
	extract = extractEGraph(env.egraph, calculateTTypeBenefit);
	eenv = ExtractEnv(env, extract, ref makeTree());
	mapSet(enodes, \enode -> {
		extractENode(eenv, eclass, enode)
	});
}

ExtractEnv(
	env : TTypeEnv,
	benefits : Tree<int, EClassBenefit<TType>>,
	// Types we already have extracted
	etypes : ref Tree<int, TType>,
);

extractTTypes(env : ExtractEnv) -> Tree<int, TType> {
	traverseInOrder(env.benefits, \eclass, ebenefit -> {
		type = extractTType(env, eclass);
	});
	^(env.etypes)
}

extractTType(env : ExtractEnv, eclass : int) -> TType {
	mexist = lookupTree(^(env.etypes), eclass);
	mexist ?? {
		mexist
	} : {
		mbenefit = lookupTree(env.benefits, eclass);
		mbenefit ?? {
			enode = mbenefit.node;
			extractENode(env, eclass, enode);
		} : {
			TTypeEClass(eclass);
		}
	}
}

extractENode(env : ExtractEnv, eclass : int, enode : ENode<TType>) -> TType {
	set = \tt -> {
		env.etypes := setTree(^(env.etypes), eclass, tt);
		tt;
	}
	extractChildren = \ -> {
		map(enode.args, \root : int -> {
			if (root == eclass) TTypeEClass(eclass)
			else extractTType(env, root)
		});			
	};

	switch (enode.head : TType) {
		TTypeEClass(id): {
			TTypeEClass(getEClassRoot(env.env.egraph, id))
		}
		TTypeName(id, __): {
			typars = extractChildren();
			set(TTypeName(id, typars));
		}
		TTypeFunction(__, __): {
			children : [TType] = extractChildren();
			// The last child is the return type
			n = length(children);
			set(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
		}
		TTypeOverload(typar, __): {
			children : [TType] = extractChildren();
			cset = buildSet(children);
			set(TTypeOverload(typar, buildSet(children)));
		}
		TTypeSupertype(unique, __): {
			children : [TType] = extractChildren();
			cset = buildSet(children);
			super = TTypeSupertype(unique, cset);
			if (isEmptySet(cset)) {
				// We have no information.
				set(TTypeEClass(eclass));
			} else {
				set(resolveTSupertype(env.env, super));
			}
		}
	}
}

calculateTTypeBenefit(e : ENode<TType>, childbenefits : [EClassBenefit<TType>]) -> EClassBenefit<TType> {
	benefits = map(childbenefits, \cc -> cc.benefit);
	cbenefits = sum(benefits);
	switch (e.head) {
		TTypeName(id, typars): {
			if (id == "flow") EClassBenefit(5, e)
			else EClassBenefit(10 + cbenefits, e);
		}
		TTypeEClass(id): EClassBenefit(0, e);	// No benefit from these
		TTypeFunction(args, returnType): EClassBenefit(5 + cbenefits, e);
		TTypeOverload(unique, overloads): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
		TTypeSupertype(unique, subtypes): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
	}
}
