import plow/types/egraph/extract;
import plow/types/egraph/simplify;

export {
	resolveEClasses(env : TTypeEnv) -> TTypeEnv;
}

resolveEClasses(env : TTypeEnv) -> TTypeEnv {
	canonicalizeEGraph(env.tgraph.egraph);
	
	if (false) {
		dot = egraph2dot(env.tgraph.egraph, \n -> ttypeENode2string(env.tgraph.egraph, n));
		setFileContent("egraph-pre.dot", dot);
		{}
	}

	unifyEClasses(env, 3, 3)
}

// Structurally unify eclasses
unifyEClasses(env : TTypeEnv, iterations : int, extractions : int) -> TTypeEnv {
	if (false) {
		println("Unify eclasses " + i2s(iterations));
		dumpEClasses(env);
	}
	unify : ref [ENodesUnify] = ref [];
	iterEGraph(env.tgraph.egraph, \root, nodes : Set<ENode<TType>> -> {
		unify := concat(^unify, unifyENodes(env, root, nodes));
	});
	update = ref false;
	if (^unify != []) {
		// Apply all updates to the graph
		iter(^unify, \eunify : ENodesUnify -> {
			update := applyENodesUnify(env, eunify) || ^update;
		});
		canonicalizeEGraph(env.tgraph.egraph);
	}

	if (!^update || iterations <= 0) {
		extractEClassTType(env, extractions);
	} else {
		// Repeat
		unifyEClasses(env, iterations - 1, extractions);
	}
}

// OK, based on the egraph we have, extract the "cheapest" types
extractEClassTType(env : TTypeEnv, iterations : int) -> TTypeEnv {
	// println("Cost based extraction:");
	types = extractEClassTypes(env);

	update = ref false;
	etypes = foldTree(types, env.etypes, \eclass, type, acc -> {
		if (containsKeyTree(acc, eclass)) {
			acc;
		} else {
			nclass = makeTTypeEClass(env.tgraph, type);
			if (nclass != eclass) {
				// println("Added new type " + prettyTType(type) + " to " + i2s(eclass));
				unionEClass(env.tgraph.egraph, nclass, eclass);
				update := true;
			}
			if (!unresolvedTType(type) || iterations == 0) {
				// println("Resolved type " + prettyTType(type) + " to " + i2s(eclass));
				setTree(acc, nclass, type);
			} else acc
		}
	});

	tenv = TTypeEnv(env with etypes = etypes);

	canonicalizeEGraph(tenv.tgraph.egraph);
	if (iterations > 0 && ^update) {
		unifyEClasses(tenv, 2, iterations - 1);
	} else {
		if (true) {
			println("Final Classes at " + i2s(iterations));
			dumpEClasses(tenv);
		}
		if (true) {
			dot = egraph2dot(tenv.tgraph.egraph, \n -> ttypeENode2string(tenv.tgraph.egraph, n));
			setFileContent("egraph.dot", dot);
			{}
		}
		tenv;
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	iteri(env.tgraph.egraph.eclass.values, \i, value : ref Set<ENode<TType>> -> {
		root = getEClassRoot(env.tgraph.egraph, i);
		if (isEmptySet(^value)) {
			// println("Class e" + i2s(root) + " from e" + i2s(i));
		} else {
			println("Class e" + i2s(root) + " : "
				+ rpad(prettyTType(lookupTreeDef(env.etypes, i, TTypeName("Unresolved", []))), " ", 50) + " from "
				+ superglue(set2array(^value), \e : ENode<TType>-> {
					ttypeENode2string(env.tgraph.egraph, e) + "(" + superglue(e.args, \ec -> {
						eroot = getEClassRoot(env.tgraph.egraph, ec);
						i2s(eroot)
					}, ", ") + ")"
				}, ", ")
			);
		}
	});
}


ttypeENode2string(egraph : EGraph<TType>, enode : ENode<TType>) -> string {
	switch (enode.head) {
		TTypeName(id, typars): id;
		TTypeEClass(id): "e" + i2s(getEClassRoot(egraph, id));
		TTypeFunction(args, returnType): "fn/" + i2s(length(enode.args) - 1);
		TTypeOverload(unique, overloads): "overload";
		TTypeSupertype(unique, subtypes): "supertype_" + i2s(unique);
	}
}
