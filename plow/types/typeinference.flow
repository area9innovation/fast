import plow/dexp/types;
import plow/types/typeinference_exp;
import plow/types/resolve;
import plow/types/typeof;
import plow/types/polymorphism;
import plow/types/util;

import ds/egraph_dot;
import ds/egraph_extract;

export {
	// Given a module, figure out what the types are
	ttypeInference(t : TTypeEnv, d : DModule) -> TTypeEnv;
}

ttypeInference(env : TTypeEnv, d : DModule) -> TTypeEnv {
	// Resolve the types of natives
	nenv = foldTree(d.natives, env, \nat, nativ, acc -> {
		type = dtype2ttype(env, false, nativ.type);
		unifyTType(env, d.pos, type, TTypeEClass(nativ.eclass));
		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, nat, type))
	});

	// Set the type of top levels, so mutual recursion has something to bite on
	tenv = foldTree(d.globals, nenv, \id, global, acc -> {
		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, id, TTypeEClass(global.eclass)))
	});

	// Make a field map
	fields = makeDFieldMap(d.structs);
	supers = makeDSupers(d.unions);

	// Make sure we can find local structs
	senv = TTypeEnv(tenv with
		resolveStructName = \name -> {
			lstruct = lookupTree(d.structs, name);
			lstruct ?? {
				Some(lstruct)
			} : tenv.resolveStructName(name);
		},
		resolveUnionName = \name -> {
			lunion = lookupTree(d.unions, name);
			lunion ?? {
				Some(lunion)
			}: tenv.resolveUnionName(name);
		},
		resolveField = \name -> {
			structs = getTreeArrayValue(fields, name);
			istructs = filtermap(structs, \str -> {
				lookupTree(d.structs, str);
			});
			others = tenv.resolveField(name);
			concat(istructs, others);
		},
		resolveSupertypes = \name -> {
			concat(
				getTreeArrayValue(supers, name),
				tenv.resolveSupertypes(name)
			);
		}
	);

	// The handle all globals
	genv = fold(d.order, senv, \acc, id -> {
		mglobal = lookupTree(d.globals, id);
		mglobal ?? {
			ttypeInferenceDGlobal(acc, mglobal)
		} : {acc}
	});

	resolveEClasses(genv);
}

ttypeInferenceDGlobal(env : TTypeEnv, d : DGlobal) -> TTypeEnv {
	// println("Inference of global " + d.id);

	// Instantiate the typars
	typars = fold(d.typars, makeTree(), \acc, tp -> {
		setTree(acc, tp, env.mkEClass())
	});
	nenv = TTypeEnv(env with typars = typars);

	type = ttypeInferenceDExp(nenv, d.value);

	// Now, unify the typars and their corresponding eclasses, and abstract the final type again
	ftype = replaceTTypeEClasss(
		foldTree(typars, makeTree(), \tp, tv, acc -> {
			typar = TTypeName(tp, []);
			unifyTType(env, d.pos, typar, TTypeEClass(tv));
			setTree(acc, tv, TTypeName(tp, []))
		}),
		type
	);

	// println("Inference " + d.id + " is " + prettyTType(ftype));
	unifyTType(env, d.pos, ftype, TTypeEClass(d.eclass));
	TTypeEnv(env with moduleTypes = setTree(env.moduleTypes, d.id, ftype));
}
