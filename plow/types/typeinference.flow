import plow/dexp/types;
import plow/types/typeinference_exp;
import plow/types/typeof;
import plow/types/benefit;
import plow/types/polymorphism;
import plow/types/util;
import plow/types/simplify;

import ds/egraph_dot;
import ds/egraph_extract;

export {
	// Given a module, figure out what the types are
	ttypeInference(t : TTypeEnv, d : DModule) -> TTypeEnv;
}

ttypeInference(env : TTypeEnv, d : DModule) -> TTypeEnv {
	// Resolve the types of natives
	nenv = foldTree(d.natives, env, \nat, nativ, acc -> {
		type = dtype2ttype(env, false, nativ.type);
		unifyTType(env, d.pos, type, TTypeEClass(nativ.eclass));
		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, nat, type))
	});

	// Set the type of top levels, so mutual recursion has something to bite on
	tenv = foldTree(d.globals, nenv, \id, global, acc -> {
		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, id, TTypeEClass(global.eclass)))
	});

	// Make a field map
	fields = makeDFieldMap(d.structs);
	supers = makeDSupers(d.unions);

	// Make sure we can find local structs
	senv = TTypeEnv(tenv with
		resolveStructName = \name -> {
			lstruct = lookupTree(d.structs, name);
			lstruct ?? {
				Some(lstruct)
			} : tenv.resolveStructName(name);
		},
		resolveUnionName = \name -> {
			lunion = lookupTree(d.unions, name);
			lunion ?? {
				Some(lunion)
			}: tenv.resolveUnionName(name);
		},
		resolveField = \name -> {
			structs = getTreeArrayValue(fields, name);
			istructs = filtermap(structs, \str -> {
				lookupTree(d.structs, str);
			});
			others = tenv.resolveField(name);
			concat(istructs, others);
		},
		resolveSupertypes = \name -> {
			concat(
				getTreeArrayValue(supers, name),
				tenv.resolveSupertypes(name)
			);
		}
	);

	// The handle all globals
	genv = fold(d.order, senv, \acc, id -> {
		mglobal = lookupTree(d.globals, id);
		mglobal ?? {
			ttypeInferenceDGlobal(acc, mglobal)
		} : {acc}
	});

	canonicalizeEGraph(genv.egraph);

	if (false) {
		dot = egraph2dot(env.egraph, ttypeENode2string);
		setFileContent("egraph-pre.dot", dot);
		{}
	}
	unifyEClasses(genv, 10, 10);
}

// Structurally unify eclasses
unifyEClasses(env : TTypeEnv, iterations : int, extractions : int) -> TTypeEnv {
	if (false) {
		println("Unify eclasses " + i2s(iterations));
		dumpEClasses(env);
	}
	unify : ref [ENodesUnify] = ref [];
	iterEGraph(env.egraph, \root, nodes : Set<ENode<TType>> -> {
		unify := concat(^unify, unifyENodes(env, root, nodes));
	});
	update = ref false;
	if (^unify != []) {
		// Apply all updates to the graph
		iter(^unify, \eunify : ENodesUnify -> {
			update := applyENodesUnify(env, eunify) || ^update;
		});
		canonicalizeEGraph(env.egraph);
	}

	if (!^update || iterations <= 0) {
		extractEClassTType(env, extractions);
	} else {
		// Repeat
		unifyEClasses(env, iterations - 1, extractions);
	}
}

// OK, based on the egraph we have, extract the "cheapest" types
extractEClassTType(env : TTypeEnv, iterations : int) -> TTypeEnv {
	// println("Cost based extraction:");
	types = extractEClassTypes(env);

	update = ref false;
	traverseInOrder(types, \eclass, type -> {
		// println("Added new type " + prettyTType(type) + " to " + i2s(eclass));
		nclass = getTTypeEClass(env, type);
		if (nclass != eclass) {
			unionEClass(env.egraph, nclass, eclass);
			update := true;
		}
	});

	tenv = TTypeEnv(env with etypes = types);

	canonicalizeEGraph(env.egraph);
	if (iterations > 0 && ^update) {
		unifyEClasses(tenv, 10, iterations - 1);
	} else {
		if (true) {
			println("Final Classes at " + i2s(iterations));
			dumpEClasses(tenv);
		}
		if (true) {
			dot = egraph2dot(env.egraph, ttypeENode2string);
			setFileContent("egraph.dot", dot);
			{}
		}
		tenv;
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	iteri(env.egraph.eclass.values, \i, value : ref Set<ENode<TType>> -> {
		root = env.egraph.eclass.parents[i];
		if (isEmptySet(^value)) {
		} else {
			println("Class " + i2s(i) + " -> " + i2s(^root) + " : "
				+ rpad(prettyTType(lookupTreeDef(env.etypes, i, TTypeName("Unresolved", []))), " ", 50) + " from "
				+ superglue(set2array(^value), \e : ENode<TType>-> {
					ttypeENode2string(e) + "(" + superglue(e.args, \ec -> {
						eroot = getEClassRoot(env.egraph, ec);
						i2s(eroot)
					}, ", ") + ")"
				}, ", ")
			);
		}
	});
}

ttypeInferenceDGlobal(env : TTypeEnv, d : DGlobal) -> TTypeEnv {
	println("Inference of global " + d.id);

	// Instantiate the typars
	typars = fold(d.typars, makeTree(), \acc, tp -> {
		setTree(acc, tp, env.mkEClass())
	});
	nenv = TTypeEnv(env with typars = typars);

	type = ttypeInferenceDExp(nenv, d.value);

	// Now, unify the typars and their corresponding eclasses, and abstract the final type again
	ftype = replaceTTypeEClasss(
		foldTree(typars, makeTree(), \tp, tv, acc -> {
			typar = TTypeName(tp, []);
			unifyTType(env, d.pos, typar, TTypeEClass(tv));
			setTree(acc, tv, TTypeName(tp, []))
		}),
		type
	);

	// println("Inference " + d.id + " is " + prettyTType(ftype));
	unifyTType(env, d.pos, ftype, TTypeEClass(d.eclass));
	TTypeEnv(env with moduleTypes = setTree(env.moduleTypes, d.id, ftype));
}
