import plow/dexp/types;
import plow/types/typeinference_exp;
import plow/types/ugraph/resolve;
import plow/types/typeof;
import plow/types/polymorphism;
import plow/types/util;

export {
	// Given a module, figure out what the types are
	ttypeInference(t : TTypeEnv, d : DModule) -> TTypeEnv;
}

ttypeInference(env : TTypeEnv, d : DModule) -> TTypeEnv {
	// Resolve the types of natives
	nenv = foldTree(d.natives, env, \nat, nativ, acc -> {
		// The module types have to be with ? in the types
		type = dtype2ttype(env, false, nativ.type);
		unifyTType(env, "native", d.pos, type, TTypeEClass(nativ.eclass));

		if (isTracingId(env.tracing, StageTypeInference(), 0, nat)) {
			println(nat + ": " + prettyTType(type));
		}

		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, nat, type))
	});

	// Set the type of top levels, so mutual recursion has something to bite on
	tenv = foldTree(d.globals, nenv, \id, global, acc -> {
		// We need to set up a declared type here so polymorphism will work. 
		// We need ? in the moduleTypes.
		type = switch (global.value) {
			DTyped(value, dtype, __, eclass): {
				// If there is a declared type, use that
				dtype2ttype(env, false, dtype);
			}
			default: {
				TTypeEClass(global.eclass)
			}
		};
		if (isTracingId(env.tracing, StageTypeInference(), 0, id)) {
			println(id + ": " + prettyTType(type));
		}
		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, id, type))
	});

	// Make a field map
	fields = makeDFieldMap(d.structs);
	supers = makeDSupers(d.unions);
	subs = makeDSubtypes(d.unions);

	// Make sure we can find local structs
	senv = TTypeEnv(tenv with
		resolveStructName = \name -> {
			lstruct = lookupTree(d.structs, name);
			lstruct ?? {
				Some(lstruct)
			} : tenv.resolveStructName(name);
		},
		resolveUnionName = \name -> {
			lunion = lookupTree(d.unions, name);
			lunion ?? {
				Some(lunion)
			}: tenv.resolveUnionName(name);
		},
		resolveField = \name -> {
			structs = getTreeArrayValue(fields, name);
			istructs = filtermap(structs, \str -> {
				lookupTree(d.structs, str);
			});
			others = tenv.resolveField(name);
			concat(istructs, others);
		},
		resolveSupertypes = \name -> {
			concat(
				getTreeArrayValue(supers, name),
				tenv.resolveSupertypes(name)
			);
		},
		resolveSubtypes = \name -> {
			concat(
				getTreeArrayValue(subs, name),
				tenv.resolveSubtypes(name)
			);
		}
	);

	// The handle all globals
	genv = fold(d.order, senv, \acc, id -> {
		mglobal = lookupTree(d.globals, id);
		mglobal ?? {
			ttypeInferenceDGlobal(acc, mglobal)
		} : {acc}
	});

	if (isTracingId(env.tracing, StageTypeInference(), 2, d.flowpath)) {
		println("Before resolving " + d.flowpath);
		prettyDModule(genv, d);
	}

	resolveEClasses(genv);
}

ttypeInferenceDGlobal(env : TTypeEnv, d : DGlobal) -> TTypeEnv {
	if (isTracingId(env.tracing, StageTypeInference(), 1, d.id)) {
		println("Inference of global " + d.id);
	}

	// Instantiate the typars
	typars = fold(d.typars, makeTree(), \acc, tp -> {
		setTree(acc, tp, env.mkEClass())
	});
	nenv = TTypeEnv(env with typars = typars);

	type = ttypeInferenceDExp(nenv, d.value);

	// Now, unify the typars and their corresponding eclasses, and abstract the final type again
	ftype = replaceTTypeEClasss(
		foldTree(typars, makeTree(), \tp, tv, acc -> {
			typar = TTypeName(tp, []);
			unifyTType(env, "global", d.pos, typar, TTypeEClass(tv));
			setTree(acc, tv, TTypeName(tp, []))
		}),
		type
	);

	if (isTracingId(env.tracing, StageTypeInference(), 1, d.id)) {
		println("Inference " + d.id + " is " + prettyTType(ftype));
	}
	unifyTType(env, "global 2", d.pos, ftype, TTypeEClass(d.eclass));
	
	etype = lookupTreeDef(env.moduleTypes, d.id, TTypeEClass(d.eclass));

	switch (etype) {
		TTypeEClass(__): {
			// OK, it was not a real class.
			// Let us at least define what we have
			// println("Refined type for " + d.id);
			TTypeEnv(env with moduleTypes = setTree(env.moduleTypes, d.id, ftype));
		}
		default: {
		//	println(prettyTType(ftype) + " vs " + prettyTType(etype));
			unifyTType(env, "global 3", d.pos, ftype, etype);
			env;
		}
	}
}
