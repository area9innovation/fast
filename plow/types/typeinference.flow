import plow/dexp/types;
import plow/dexp/vars;
import plow/types/typeinference_exp;
import plow/types/typeof;
import plow/types/polymorphism;
import plow/types/util;
import ds/simplegraph;
import ds/arrayutils;

export {
	// Given a module, figure out what the types are
	ttypeInference(t : TTypeEnv, d : DModule) -> TTypeEnv;
}

ttypeInference(env : TTypeEnv, d : DModule) -> TTypeEnv {
	if (isTracingStage(env.tracing, StageTypeInference(), 1)) {
		println("\nStage: Type inference of " + d.flowpath);
	}
	// Resolve the types of natives
	nenv = foldTree(d.natives, env, \nat, nativ, acc -> {
		// The module types have to be with ? in the types
		type = dtype2ttype(env, false, nativ.type);
		unifyTType(env, nat, "native", d.pos, type, TTypeEClass(nativ.eclass));

		if (isTracingId(env.tracing, StageTypeInference(), 0, nat)) {
			println("native " + nat + ": " + prettyTType(type));
		}

		TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, nat, type))
	});

	// Set the type of top levels, so mutual recursion has something to bite on
	tenv = foldTree(d.globals, nenv, \id, global, acc -> {
		// We need to set up a declared type here so polymorphism will work. 
		// We need ? in the moduleTypes.
		type = switch (global.value) {
			DTyped(value, dtype, __, eclass): {
				// If there is a declared type, use that
				dtype2ttype(env, false, dtype);
			}
			default: {
				TTypeEClass(global.eclass)
			}
		};
		if (isTracingId(env.tracing, StageTypeInference(), 0, id)) {
			println(id + ": " + prettyTType(type));
		}
		if (!containsKeyTree(acc.moduleTypes, id)) {
			TTypeEnv(acc with moduleTypes = setTree(acc.moduleTypes, id, type))
		} else acc;
	});

	// Make a field map
	fields = makeDFieldMap(d.structs);
	supers = makeDSupers(d.unions);
	subs = makeDSubtypes(d.unions);

	// Make sure we can find local structs
	senv = TTypeEnv(tenv with
		resolveStructName = \name -> {
			lstruct = lookupTree(d.structs, name);
			lstruct ?? {
				Some(lstruct)
			} : tenv.resolveStructName(name);
		},
		resolveUnionName = \name -> {
			lunion = lookupTree(d.unions, name);
			lunion ?? {
				Some(lunion)
			}: tenv.resolveUnionName(name);
		},
		resolveField = \name -> {
			structs = getTreeArrayValue(fields, name);
			istructs = filtermap(structs, \str -> {
				lookupTree(d.structs, str);
			});
			others = tenv.resolveField(name);
			all = concat(istructs, others);
			// println(name + " from " + d.flowpath + " is totally " + toString(all));
			all;
		},
		resolveSupertypes = \name -> {
			concat(
				getTreeArrayValue(supers, name),
				tenv.resolveSupertypes(name)
			);
		},
		resolveSubtypes = \name -> {
			concat(
				getTreeArrayValue(subs, name),
				tenv.resolveSubtypes(name)
			);
		}
	);

	// OK, send the resolver to the unification friend
	tmenv = TTypeEnv(senv with
		tgraph = setTypeGraphResolver(senv.tgraph, senv.resolveUnionName, senv.resolveSupertypes)
	);

	order : [[string]] = buildDModuleDeps(d.globals, d.order);
	order2 = if (false) [d.order] else order;
	if (order2 == []) {
		resolveEClasses(env, d.flowpath, false);
	} else {
		ttypeInferenceChunk(tmenv, d, order2);
	}
}

ttypeInferenceChunk(env : TTypeEnv, d : DModule, order : [[string]]) -> TTypeEnv {
	if (order == []) {
		env
	} else {
		chunk = order[0];
		cenv = env;

		// println(chunk);

		// Now process this chunk
		genv = fold(chunk, cenv, \acc, id -> {
			mglobal = lookupTree(d.globals, id);
			mglobal ?? {
				ttypeInferenceDGlobal(acc, d.flowpath, mglobal)
			} : {acc}
		});

		verbose = fold(chunk, false, \acc, c -> {
			acc || isTracingId(env.tracing, StageTypeResolve(), 1, c)
		});
		nenv = resolveEClasses(genv, d.flowpath, verbose);
		ttypeInferenceChunk(nenv, d, tail(order));
	}
}

// Build dependencies between all globals
// and return them in order we can treat them (respecting connected components)
buildDModuleDeps(globals : Tree<string, DGlobal>, order : [string]) -> [[string]] {
	// Build a graph of dependencies
	deps = foldTree(globals, makeSimpleGraph(), \id, global, acc : SimpleGraph<string, bool> -> {
		vars = extractDVars(makeSet(), global.value);
		foldSet(vars, acc, \acc2, var -> {
			if (containsKeyTree(globals, var)) {
				// OK, an internal name - add a bidirectional dependency
				acc3 = addSimpleEdge(acc2, id, var, false, 1);
				addSimpleEdge(acc3, var, id, false, 1)
			} else acc2;
		})
	});

	extractConnectedComponents(deps, [], order);
}

extractConnectedComponents(deps : SimpleGraph<string, bool>, acc : [[string]], order : [string]) -> [[string]] {
	if (order == []) acc
	else {
		first = order[0];
		clusterSet = insertSet(reachableClosureFromSimpleNode(deps, first), first);
		cluster = filter(order, \o -> containsSet(clusterSet, o));
		// println("Starting from " + first + " finds " + strGlue(cluster, ", "));
		extractConnectedComponents(deps, arrayPush(acc, cluster), subtractA(order, cluster));
	}
}

ttypeInferenceDGlobal(env : TTypeEnv, flowpath : string, d : DGlobal) -> TTypeEnv {
	if (isTracingId(env.tracing, StageTypeInference(), 1, d.id)
		|| isTracingId(env.tracing, StageTypeInference(), 1, flowpath)) {
		println("\nInference of global " + d.id);
	}

	// Instantiate the typars
	typars = fold(d.typars, makeTree(), \acc, tp -> {
		setTree(acc, tp, env.mkEClass())
	});
	nenv = TTypeEnv(env with typars = typars, onError = \p, e -> env.onError(p, d.id + ": " + e));

	tracingId = isTracingId(env.tracing, StageTypeInference(), 1, d.id);

	type = ttypeInferenceDExp(nenv, d.id, d.value);

	// Now, unify the typars and their corresponding eclasses, and abstract the final type again
	ftype = replaceTTypeEClasss(
		foldTree(typars, makeTree(), \tp, tv, acc -> {
			typar = TTypeName(tp, []);
			// TODO: This is wrong, since it
			// contaminates the entire tmap

			// println("// Review scope: Unify typars " + prettyTType(typar) + " and e" + i2s(tv));
			unifyTType(env, d.id, "global " + d.id, d.pos, typar, TTypeEClass(tv));

			setTree(acc, tv, TTypeName(tp, []))
		}),
		type
	);

	unifyTType(env, d.id, "global " + d.id + " 2", d.pos, ftype, TTypeEClass(d.eclass));

	if (tracingId) {
		println("Inference " + d.id + " ends with " + prettyTType(ftype) + "\n");
	}

	etype = lookupTreeDef(env.moduleTypes, d.id, TTypeEClass(d.eclass));

	switch (etype) {
		TTypeEClass(__): {
			// OK, it was not a real class.
			// Let us at least define what we have
			// println("Refined type for " + d.id);
			TTypeEnv(env with moduleTypes = setTree(env.moduleTypes, d.id, ftype));
		}
		default: {
		//	println(prettyTType(ftype) + " vs " + prettyTType(etype));
			
			// TODO: This contaminates the TMap polymorphism
			// println("// Review scope: Unify typars " + prettyTType(ftype) + " and " + prettyTType(etype));
			unifyTType(env, d.id, "global " + d.id + " 3", d.pos, ftype, etype);
			env;
		}
	}
}

resolveEClasses(env : TTypeEnv, flowpath : string, verbose : bool) -> TTypeEnv {
	types = resolveTNodes(env.tgraph.tmap, verbose);
	TTypeEnv(env with etypes = types);
}
