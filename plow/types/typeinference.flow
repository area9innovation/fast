import plow/types/typeof;
import plow/dexp/pretty;
import plow/types/unify;
import plow/types/extract;
import plow/types/builtin;
import plow/types/polymorphism;

export {
	ttypeInference(t : TTypeEnv, d : DModule) -> TTypeEnv;
}

ttypeInference(env : TTypeEnv, d : DModule) -> TTypeEnv {
	nenv = fold(d.order, env, \acc, id -> {
		mglobal = lookupTree(d.globals, id);
		mglobal ?? {
			ttypeInferenceDGlobal(acc, mglobal)
		} : {acc}
	});

	canonicalizeEGraph(nenv.egraph);

	println("Type equivalences:");
	iterEGraph(nenv.egraph, \root, nodes : Set<ENode<TType>> -> {
		equi = foldSet(nodes, "", \acc, node : ENode<TType> -> {
			acc + "   " + prettyTType(node.head) + (if (node.args != []) "<" + superglue(node.args, i2s, ", ") + ">" else "")
		});
		extract = eclass2TType(nenv, root);
		println(i2s(root) + ": " + prettyTType(extract) + " from " + equi);
	});
	nenv;
}

ttypeInferenceDGlobal(env : TTypeEnv, d : DGlobal) -> TTypeEnv {
	typars = fold(d.typars, makeTree(), \acc, tp -> {
		setTree(acc, tp, env.mkTyvar())
	});
	nenv = TTypeEnv(env with typars = typars);
	if (d.recursive) {
		println("TODO: Handle recursive defs");
		type = ttypeInferenceDExp(nenv, d.value);
		TTypeEnv(env with localTypes = setTree(env.localTypes, d.id, type));
	} else {
		type = ttypeInferenceDExp(nenv, d.value);
		TTypeEnv(env with localTypes = setTree(env.localTypes, d.id, type));
	}
}

ttypeInferenceDExp(env : TTypeEnv, d : DExp) -> TType {
	restype = \tv, type -> {
		unifyTType(env, type, TTypeVar(tv));
	}
	switch (d) {
		DVoid(pos): TTypeName("void", []);
		DBool(v, pos): TTypeName("bool", []);
		DInt(v, pos): TTypeName("int", []); 
		DDouble(v, pos): TTypeName("double", []);
		DString(v, pos): TTypeName("string", []);
		DStringInclude(path, pos): TTypeName("string", []);
		DVar(id, pos, tyvar): {
			mtype = lookupTree(env.localTypes, id);
			type = mtype ?? {
				mtype
			} : {
				env.resolveId(id);
			};
			restype(tyvar, type);
		}
		DTyped(value, type, pos): {
			valtype = ttypeInferenceDExp(env, value);
			unifyTType(env, valtype, dtype2ttype(env, type));
		}
		DLet(id, value, body, pos, tyvar): {
			tvalue = ttypeInferenceDExp(env, value);
			nenv = TTypeEnv(env with localTypes = setTree(env.localTypes, id, tvalue));
			tbody = ttypeInferenceDExp(nenv, body);
			restype(tyvar, tbody);
		}
		DIf(cond, then, else_, pos, tyvar): {
			tcond = ttypeInferenceDExp(env, cond);
			unifyTType(env, tcond, TTypeName("bool", []));

			tthen = ttypeInferenceDExp(env, then);
			telse = ttypeInferenceDExp(env, else_);
			type = unifyTType(env, tthen, telse);
			restype(tyvar, type);
		}
		DCall(fn, args, pos, tyvar): {
			fntype1 = ttypeInferenceDExp(env, fn);
			argtypes = map(args, \a -> ttypeInferenceDExp(env, a));
			rettype = TTypeVar(env.mkTyvar());
			fntype2 = TTypeFunction(argtypes, rettype);
			type = unifyTType(env, fntype1, fntype2);
			restype(tyvar, type);
		}
		DCallOp(op, args, pos, tyvar): {
			moptype = getBuiltinTType(op);
			moptype ?? {
				optype = instantiateTTypePar(env, moptype);
				argtypes = map(args, \a -> ttypeInferenceDExp(env, a));
				rettype = TTypeVar(env.mkTyvar());
				fntype = TTypeFunction(argtypes, rettype);
				type = unifyTType(env, moptype, fntype);
				restype(tyvar, type);
			} : {
				env.onError(tyvar, "Unknown operator " + op);
				TTypeVar(env.mkTyvar());
			}
		}
		// DConstruct(structid, args, pos, tyvar): 
		DLambda(args, body, pos, tyvar): {
			argTypes = map(args, \arg -> {
				dtype2ttype(env, arg.type)
			});
			nenv = foldi(args, env, \i, acc, arg -> {
				TTypeEnv(acc with localTypes = setTree(acc.localTypes, arg.id, argTypes[i]))
			});
			retType = ttypeInferenceDExp(nenv, body);
			type = TTypeFunction(argTypes, retType);
			restype(tyvar, type);
		}
		// DRef(value, pos, tyvar): 
		// DField(value, field, pos, tyvar): 
		// DSetMutable(lhs, field, value, pos, tyvar): 
		// DArray(exps, pos, tyvar): 
		DSequence(exps, pos, tyvar): {
			stype = fold(exps, voidTType, \acc, e -> {
				ttypeInferenceDExp(env, e);
			});
			restype(tyvar, stype);
		}
		DSwitch(value, type, cases, defaultCase, pos, tyvar): {
			tvalue = ttypeInferenceDExp(env, value);
			ttype = dtype2ttype(env, type);
			stype = unifyTType(env, tvalue, ttype);

			caseType = fold(cases, TTypeVar(env.mkTyvar()), \acc, c -> {
				// TODO: Maybe introduce a "super-type allowed" construct
				tbody = ttypeInferenceDExp(env, c.body);
				unifyTType(env, acc, tbody)
			});

			btype = defaultCase ?? {
				dtype = ttypeInferenceDExp(env, defaultCase);
				unifyTType(env, dtype, caseType)
			} : {
				caseType
			};
			restype(tyvar, btype);
		}
		// DCast(value, target, pos): 
		DDowncast(var, subtype, scope, pos, tyvar): {
			tsubtype = dtype2ttype(env, subtype);
			nenv = TTypeEnv(env with localTypes = setTree(env.localTypes, var, tsubtype));
			dtype = ttypeInferenceDExp(nenv, scope);
			restype(tyvar, dtype);
		}
		// DWith(struct, value, fields, pos, tyvar): 
		default: {
			println("TODO: Infer the type of " + d.structname);
			TTypeVar(env.mkTyvar());
		}
	}
}

