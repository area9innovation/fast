import plow/types/typeenv;
import plow/types/pretty;

export {
	// Sort out the relation between these types
	compareTType(env : TTypeEnv, left : TType, right : TType) -> TTypeOrder;

	emptyTType = TTypeName("ERROR", []);

	TTypeOrder ::= TTypePrefer, TTypeSubtype, TTypeDifferent;
		TTypePrefer(type : TType);

		// One is a sub type of the other
		TTypeSubtype(subtype : TType, supertype : TType);

		// These types are not compatible
		TTypeDifferent(error : string);

}

compareTType(env : TTypeEnv, left : TType, right : TType) -> TTypeOrder {
	// println("Compare types " + prettyTType(left) + " and " + prettyTType(right));
	todo = \ -> {
		println("TODO: Compare types " + prettyTType(left) + " and " + prettyTType(right));
		TTypeDifferent("TODO: Compare " + prettyTType(left) + " and " + prettyTType(right));
	}
	if (left == right) TTypePrefer(left)
	else if (left == emptyTType) TTypePrefer(right)
	else if (right == emptyTType) TTypePrefer(left)
	else switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						if (length(ltypars) == length(rtypars)) {
							foldi(ltypars, TTypePrefer(left), \i, acc : TTypeOrder, ltypar -> {
								cc = compareTType(env, ltypar, rtypars[i]);
								combineTTypeOrder(env, acc, cc)
							});
						} else TTypeDifferent("# typar args differ for " + lid);
					} else if (lid == "flow") {
						TTypePrefer(right);
					} else if (rid == "flow") {
						TTypePrefer(left);
					} else {
						compareTTypenames(env, left, right)
					}
				}
				TTypeVar(id): TTypePrefer(left);
				TTypeFunction(args, returnType): TTypeDifferent(lid + " != fn");
				TTypeOverload(unique, overloads): {
					compareTOverload(env, right, left);
				}
				TTypeSupertype(unique, subtypes): todo();
			}
		}
		TTypeVar(id): {
			switch (right) {
				TTypeName(__, typars): TTypePrefer(right);
				TTypeFunction(args, returnType): TTypePrefer(right);
				TTypeVar(rid): if (id < rid) TTypePrefer(left) else TTypePrefer(right);
				TTypeOverload(typar, overloads): {
					compareTOverload(env, right, left);
				}
				TTypeSupertype(typar, subtypes): {
					todo();
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeName(id, typars): TTypeDifferent("function != " + id);
				TTypeVar(id): TTypePrefer(left);
				TTypeFunction(rargs, rreturnType): {
					if (length(largs) == length(rargs)) {
						args : [TType] = filtermapi(largs, \i, larg -> {
							extractBestType(compareTType(env, rargs[i], larg));
						});
						mrt : Maybe<TType> = extractBestType(compareTType(env, lreturnType, rreturnType));
						mrt ?? {
							if (length(args) == length(rargs)) {
								TTypePrefer(TTypeFunction(args, mrt))
							} else {
								TTypeDifferent("Could not join functions");
							}
						} : {
							TTypeDifferent("Could not join functions");
						}
					} else {
						TTypeDifferent("# args differ");
					}
				}
				TTypeOverload(unique, overloads): {
					compareTOverload(env, right, left);
				}
				TTypeSupertype(unique, subtypes): todo();
			}
		}
		TTypeOverload(typar, overloads): {
			compareTOverload(env, left, right)
		}
		TTypeSupertype(typar, subtypes): {
			todo();
		}
	}
}

compareTOverload(env : TTypeEnv, ov : TTypeOverload, right : TType) -> TTypeOrder {
	foldSet(ov.overloads, TTypePrefer(right), \acc : TTypeOrder, overload -> {
		cc = compareTType(env, overload, right);
		switch (cc) {
			TTypeDifferent(__): acc;
			default: {
				combineTTypeOrder(env, acc, cc)
			}
		}
	});
}

combineTTypeOrder(env : TTypeEnv, l : TTypeOrder, r : TTypeOrder) -> TTypeOrder {
	todo = \ -> {
		println("Combine type orders " + toString(l) + " and " + toString(r));
		TTypeDifferent("TODO " + toString(l) + " and " + toString(r));
	}
	switch (l) {
		TTypePrefer(ltype): {
			switch (r) {
				TTypePrefer(rtype): compareTType(env, ltype, rtype);
				TTypeSubtype(subtype, supertype): {
					todo();
				}
				TTypeDifferent(__): r;
			}
		}
		TTypeSubtype(subtype, supertype): {
			todo();
		}
		TTypeDifferent(__): l;
	}
}

extractBestType(t : TTypeOrder) -> Maybe<TType> {
	switch (t) {
		TTypePrefer(type): Some(type);
		TTypeSubtype(subtype, supertype): Some(subtype);
		TTypeDifferent(error): None()
	}
}

// We know these are different, so figure them out
compareTTypenames(env : TTypeEnv, left : TTypeName, right : TTypeName) -> TTypeOrder {
	basic = \t -> contains(["void", "bool", "int", "double", "string"], t);
	if (basic(left.id) || basic(right.id)) TTypeDifferent("Could not combine " + left.id  + " and " + right.id)
	else {
		println("TODO: Check subtyping relation between " + left.id + " and " + right.id);
		TTypeDifferent("TODO: Subtyping between " + left.id + " and " + right.id);
	}
}
