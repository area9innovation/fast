import plow/types/type;
import algorithms;

export {
	makeTTypeSupertype(mkUnique : () -> int, subtypes : [TType], maxed : bool) -> TType;

	getTTypeName(t : TType) -> string;
	unresolvedTType(t : TType) -> bool;
	containsTTypeEClass(t : TType) -> bool;
}

makeTTypeSupertype(mkUnique : () -> int, subtypes : [TType], maxed : bool) -> TType {
	ss2 = fold(subtypes, makeSet(), extractTSupers);
	TTypeSupertype(mkUnique(), set2array(ss2), maxed);
}

extractTSupers(acc : Set<TType>, t : TType) -> Set<TType> {
	switch (t) {
		TTypeSupertype(__, supers, maxed): fold(supers, acc, extractTSupers);
		default: insertSet(acc, t);
	}
}

getTTypeName(t : TType) -> string {
	switch (t) {
		TTypeName(n, __): n;
		default: "";
	}
}

unresolvedTType(t : TType) -> bool {
	switch (t) {
		TTypeName(id, typars): exists(typars, unresolvedTType);
		TTypeEClass(eclass): true;
		TTypeFunction(args, returnType): exists(args, unresolvedTType) || unresolvedTType(returnType);
		TTypeOverload(unique, overloads): true;
		TTypeSupertype(unique, subtypes, maxed): true;
	}
}

containsTTypeEClass(t : TType) -> bool {
	switch (t) {
		TTypeName(id, typars): exists(typars, containsTTypeEClass);
		TTypeEClass(eclass): true;
		TTypeFunction(args, returnType): exists(args, containsTTypeEClass) || containsTTypeEClass(returnType);
		TTypeOverload(unique, overloads): exists(overloads, containsTTypeEClass);
		TTypeSupertype(unique, subtypes, maxed): exists(subtypes, containsTTypeEClass);
	}
}
