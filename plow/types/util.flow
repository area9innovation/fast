import plow/types/type;
import ds/egraph;

export {
	makeTTypeSupertype(mkUnique : () -> int, subtypes : [TType]) -> TType;

	ttypeENode2string(egraph : EGraph<TType>, enode : ENode<TType>) -> string;

	replaceTTypeEClasss(eclasss : Tree<int, TType>, type : TType) -> TType;

	replaceTType(types : Tree<TType, TType>, type : TType) -> TType;


	unresolvedTType(t : TType) -> bool;
	containsTTypeEClass(t : TType) -> bool;
}

makeTTypeSupertype(mkUnique : () -> int, subtypes : [TType]) -> TType {
	ss = buildSet(subtypes);
	ss2 = foldSet(ss, makeSet(), extractTSupers);
	TTypeSupertype(mkUnique(), ss2);
}

extractTSupers(acc : Set<TType>, t : TType) -> Set<TType> {
	switch (t) {
		TTypeSupertype(__, supers): foldSet(supers, acc, extractTSupers);
		default: insertSet(acc, t);
	}
}

ttypeENode2string(egraph : EGraph<TType>, enode : ENode<TType>) -> string {
	switch (enode.head) {
		TTypeName(id, typars): id;
		TTypeEClass(id): "e" + i2s(getEClassRoot(egraph, id));
		TTypeFunction(args, returnType): "fn/" + i2s(length(enode.args) - 1);
		TTypeOverload(unique, overloads): "overload";
		TTypeSupertype(unique, subtypes): "supertype_" + i2s(unique);
	}
}

replaceTTypeEClasss(eclasss : Tree<int, TType>, type : TType) -> TType {
	rec = \tt -> replaceTTypeEClasss(eclasss, tt);
	switch (type) {
		TTypeEClass(id): lookupTreeDef(eclasss, id, type);
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, mapSet(overloads, rec));
		TTypeSupertype(unique, subtypes): TTypeSupertype(unique, mapSet(subtypes, rec));
	}
}

replaceTType(types : Tree<TType, TType>, type : TType) -> TType {
	mrep = lookupTree(types, type);
	mrep ?? {
		mrep
	} : {
		rec = \tt -> replaceTType(types, tt);
		switch (type) {
			TTypeEClass(id): type;
			TTypeName(id, typars): TTypeName(id, map(typars, rec));
			TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
			TTypeOverload(unique, overloads): TTypeOverload(unique, mapSet(overloads, rec));
			TTypeSupertype(unique, subtypes): TTypeSupertype(unique, mapSet(subtypes, rec));
		}
	}
}


unresolvedTType(t : TType) -> bool {
	switch (t) {
		TTypeName(id, typars): exists(typars, unresolvedTType);
		TTypeEClass(eclass): true;
		TTypeFunction(args, returnType): exists(args, unresolvedTType) || unresolvedTType(returnType);
		TTypeOverload(unique, overloads): true;
		TTypeSupertype(unique, subtypes): true;
	}
}

containsTTypeEClass(t : TType) -> bool {
	switch (t) {
		TTypeName(id, typars): exists(typars, containsTTypeEClass);
		TTypeEClass(eclass): true;
		TTypeFunction(args, returnType): exists(args, containsTTypeEClass) || containsTTypeEClass(returnType);
		TTypeOverload(unique, overloads): existsSet(overloads, containsTTypeEClass);
		TTypeSupertype(unique, subtypes): existsSet(subtypes, containsTTypeEClass);
	}
}
