import plow/types/typeenv;
import plow/types/util;
import plow/types/pretty;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(env : TTypeEnv) -> Tree<int, TType>;
}

extractEClassTypes(env : TTypeEnv) -> Tree<int, TType> {
	egraph = env.egraph;
	extract = extractEGraph(egraph, calculateTTypeCost);
	extractTTypes(env, extract);
}

extractTTypes(env : TTypeEnv, costs : Tree<int, EClassCost<TType>>) -> Tree<int, TType> {
	foldTree(costs, makeTree(), \eclass, ecost, acc -> {
		mtype = extractTType(env, costs, eclass);
		mtype ?? {
			// println(i2s(eclass) + " = " + prettyTType(mtype));
			setTree(acc, eclass, mtype)
		} : {
			println("Could not extract type from " + ttypeENode2string(ecost.node) + " with eclass " + i2s(eclass));
			acc;
		}
	});
}

extractTType(env : TTypeEnv, costs : Tree<int, EClassCost<TType>>, eclass : int) -> Maybe<TType> {
	mcost = lookupTree(costs, eclass);
	mcost ?? {
		enode = mcost.node;
		switch (enode.head : TType) {
			TTypeVar(id): Some(enode.head);
			TTypeName(id, __): {
				mtypars = filtermap(enode.args, \root : int -> {
					extractTType(env, costs, root)
				});
				if (length(mtypars) == length(enode.args)) {
					Some(TTypeName(id, mtypars));
				} else {
					None();
				}
			}
			TTypeFunction(__, __): {
				children : [TType] = filtermap(enode.args, \root -> extractTType(env, costs, root));
				// The last child is the return type
				n = length(children);
				if (n != length(enode.args)) {
					None();
				} else {
					Some(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
				}
			}
			TTypeOverload(typar, __): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(env, costs, root);
				});
				if (length(children) != length(enode.args)) {
					None()
				} else {
					Some(TTypeOverload(typar, buildSet(children)));
				}
			}
			TTypeSupertype(typar, __): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(env, costs, root);
				});
				if (length(children) != length(enode.args)) {
					None();
				} else {
					cset = buildSet(children);
					if (children == []) {
						Some(TTypeVar(env.mkTyvar()))
					} else if (sizeSet(cset) == 1) {
						Some(children[0]);
					} else {
						Some(TTypeSupertype(typar, cset));
					}
				}
			}
		}
	} : {
		println("Have no cost for " + i2s(eclass));
		None()
	}
}

calculateTTypeCost(e : ENode<TType>, childCosts : [EClassCost<TType>]) -> EClassCost<TType> {
	costs = map(childCosts, \cc -> cc.cost);
	ccosts = sum(costs);
	switch (e.head) {
		TTypeName(id, typars): {
			if (id == "flow") EClassCost(1, e)
			else EClassCost(max(0, ccosts - 1), e);
		}
		TTypeVar(id): EClassCost(5 + ccosts, e);
		TTypeFunction(args, returnType): EClassCost(max(0, ccosts - 1), e);
		TTypeOverload(unique, overloads): {
			// We do not want these
			EClassCost(100 + ccosts, e);
		}
		TTypeSupertype(unique, subtypes): {
			// We do not want these
			EClassCost(100 + ccosts, e);
		}
	}
}
