import plow/types/type;
import plow/types/util;
import plow/types/pretty;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(e : EGraph<TType>) -> Tree<int, TType>;
}

extractEClassTypes(egraph : EGraph<TType>) -> Tree<int, TType> {
	extract = extractEGraph(egraph, calculateTTypeCost);
	extractTTypes(extract);
}

extractTTypes(costs : Tree<int, EClassCost<TType>>) -> Tree<int, TType> {
	foldTree(costs, makeTree(), \eclass, ecost, acc -> {
		mtype = extractTType(costs, eclass);
		mtype ?? {
			// println(i2s(eclass) + " = " + prettyTType(mtype));
			setTree(acc, eclass, mtype)
		} : {
			println("Could not extract type from " + toString(ecost.node) + " with eclass " + i2s(eclass));
			acc;
		}
	});
}

extractTType(costs : Tree<int, EClassCost<TType>>, eclass : int) -> Maybe<TType> {
	mcost = lookupTree(costs, eclass);
	mcost ?? {
		enode = mcost.node;
		switch (enode.head : TType) {
			TTypeVar(id): Some(enode.head);
			TTypeName(id, typars): {
				mtypars = filtermap(enode.args, \root : int -> {
					extractTType(costs, root)
				});
				if (length(mtypars) == length(typars)) {
					Some(TTypeName(id, mtypars));
				} else None();
			}
			TTypeFunction(args, returnType): {
				children : [TType] = filtermap(enode.args, \root -> extractTType(costs, root));
				// The last child is the return type
				n = length(children);
				if (n != length(args) + 1) {
					None();
				} else {
					Some(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
				}
			}
			TTypeOverload(typar, overloads): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(costs, root);
				});
				if (length(children) != sizeSet(overloads)) {
					None()
				} else {
					Some(TTypeOverload(typar, buildSet(children)));
				}
			}
			TTypeSupertype(typar, subtypes): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(costs, root);
				});
				if (length(children) != sizeSet(subtypes)) {
					None();
				} else {
					Some(makeTTypeSupertype(typar, children));
				}
			}
		}
	} : {
		println("Have no cost for " + i2s(eclass));
		None()
	}
}

calculateTTypeCost(e : ENode<TType>, childCosts : [EClassCost<TType>]) -> EClassCost<TType> {
	costs = map(childCosts, \cc -> cc.cost);
	switch (e.head) {
		TTypeName(id, typars): EClassCost(1 + sum(costs), e);
		TTypeVar(id): EClassCost(5 + sum(costs), e);
		TTypeFunction(args, returnType): EClassCost(1 + sum(costs), e);
		TTypeOverload(unique, overloads): {
			fold(childCosts, EClassCost(intMax, e), \acc, childcost -> {
				if (childcost.cost < acc.cost) {
					childcost
				} else acc
			});
		}
		TTypeSupertype(unique, subtypes): {
			println("TODO: Find the cost of this supertype");
			EClassCost(2 + sum(costs), e);
		}
	}
}
