import plow/types/typeenv;
import plow/types/supertype;
import plow/types/unify;

export {
	// Try to resolve this supertype from the given node.
	// If we make progress, return true.
	// If "last" is true, then pick some type out of desperation
	resolveTTypeSuper(env : TTypeEnv, verbose: bool, eclass : int, node : TTypeNode, 
		last : bool, supertype : TTypeSupertype) -> bool;
}

resolveTTypeSuper(env : TTypeEnv, verbose: bool, eclass : int, node : TTypeNode, last : bool, supertype : TTypeSupertype) -> bool {
	// If this supertype has names it, then take care of it
	potsupers = resolveTSupertype(env, supertype, last);
	if (length(potsupers) == 1) {
		// OK, we have a unique super type
		supername = potsupers[0];
		mtype = hasTypeNodeThisName(node, supername);
		mtype ?? {
			// We found the type already
			if (verbose) {
				println("Resolve supertype e" + i2s(eclass) + " to existing " + prettyTType(mtype) + " from " + prettyTType(supertype));
			}
			unifyTypeToEClass(env, eclass, mtype, ["resolve supertype with existing"], []);
			true;
		} : {
			// OK, the type does not exist. We have to construct it
			ntype = instantiateTTypeName(env, supername);
			if (verbose) {
				println("Resolve supertype e" + i2s(eclass) + " to " + prettyTType(ntype) + " from " + prettyTType(supertype));
			}
			unifyTypeToEClass(env, eclass, ntype, ["resolve supertype"], []);
			true;
		}
	} else {
		// OK, the supertype could contain functions
		fns : [TTypeFunction] = filtermap(supertype.subtypes, \st : TType -> {
			switch (st) {
				TTypeFunction(__, __): Some(st);
				default: None();
			}
		});
		if (fns != []) {
			// super( (a) -> b) -->  (a) -> super(b)
			iter(fns, \fn -> {
				stubfn = TTypeFunction(fn.args, TTypeSupertype(env.mkUnique(), [fn.returnType], supertype.maxed));
				if (verbose) {
					println("Resolve supertype returns for e" + i2s(eclass) + " to " + prettyTType(stubfn) + " from " + prettyTType(supertype));
				}
				unifyTypeToEClass(env, eclass, stubfn, ["resolve supertype fn"], []);
			});
			true;
		} else {
			if (length(potsupers) > 1) {
				types = filtermap(potsupers, \pot -> {
					mtype = hasTypeNodeThisName(node, pot);
					mtype ?? {
						Some(mtype)
					} : {
						// TODO: Instantiate a supertype from a struct
						// so we avoid excessive typars
						// instantiateTTypeName(env, pot);
						None();
					}
				});
				if (length(types) == length(potsupers)) {
					overload = TTypeOverload(TTypeEClass(eclass), types);
					if (verbose) {
						println("Resolve supertype e" + i2s(eclass) + " to overload " + prettyTType(overload) + " from " + prettyTType(supertype));
					}
					unifyTypeToEClass(env, eclass, overload, ["supertype overload"], []);
				} else {

				}
			}

			supers = filtermap(supertype.subtypes, \st : TType -> {
				switch (st) {
					TTypeSupertype(__, __, __): Some(st);
					default: None();
				}
			});
			if (supers != []) {
				println("TODO: Super inside super: " + prettyTType(supertype));
			}
			false;
		}
	}
}

hasTypeNodeThisName(node : TTypeNode, name : string) -> Maybe<TType> {
	supers = switch (node.supertype) {
		None(): [];
		Some(st): st.subtypes;
	}
	overs = switch (node.overload) {
		None(): [];
		Some(ov): ov.overloads;
	}
	types = concat3(node.best, supers, overs);
	fit = filter(types, \n -> getTTypeName(n) == name);
	resolved = filter(fit, \t -> !unresolvedTType(t));
	if (resolved != []) Some(resolved[0])
	else if (fit == []) None()
	else Some(fit[0])
}
