import plow/types/typeenv;
import plow/types/unify;
import plow/types/ugraph/supertype;
import plow/types/ugraph/ugraph;
import plow/types/ugraph/cost;

/*
TODO:
Do not instantiate resolved. 
Get rid of history concept
Filter nodes to non-free types (get rid of resolved)
Keep cost for nodes along with best type
Also track benefit so e1 is not preferred to Maybe<e2>

- For supertypes, expand to cover all suitable types for typenodes
  and that way, try to resolve supertypes more usefully

So the loop should be this:
  - Simplify: Instantiate decided eclasses and substitute everywhere.
    This by itself should not cause any new unifications to happen

  - Overloads should filter candidates if we have any other info, and thus limit the field.
    Does not cause new unification, unless the overload is resolved.
	This happens when we unify the overload with bests.

  - Supertypes: Expand to all possible supertypes. If unique, then resolve.

  - Unify new information with other info.
*/

export {
	resolveEClasses(env : TTypeEnv, flowpath : string,  verbose : bool) -> TTypeEnv;

	cleanEClasses(env : TTypeEnv) -> void;
}

resolveEClasses(env : TTypeEnv, flowpath : string, verbose : bool) -> TTypeEnv {
	doResolveEClasses(env, flowpath, verbose, false, 10);
}

SimplifyEnv(
	env : TTypeEnv,
	flowpath : string,
	verbose : bool,
	etypes : ref Tree<int, TType>,
	visiting : ref Set<int>,
	update : ref bool,
);

doResolveEClasses(env : TTypeEnv, flowpath : string, verbose : bool, last : bool, iteration : int) -> TTypeEnv {
	if (verbose || isTracingId(env.tracing, StageTypeResolve(), 2, flowpath)) {
		println("\nResolve " + flowpath + ": Iteration " + i2s(iteration) + (if (last) ". Decision time" else "") + ". Max eclass: " + i2s(^(env.tgraph.nextEClass)));
		println("Updated: " + superglue(set2array(^(env.tgraph.updated)), \e -> "e" + i2s(e), ", "));
		dumpEClasses(env, i2s(iteration) + (if (last) "-last" else ""));
	}
	env.visited := makeSet();
	env.tgraph.updated := makeSet();

	roots = getEClassRoots(env.tgraph);
	senv = SimplifyEnv(env, flowpath, verbose, ref env.etypes, ref makeSet(), ref false);
	iterSet(roots, \root -> {
		simplifyTTypeNode(senv, root, last);
		{}
	});
	nenv = TTypeEnv(env with etypes = ^(senv.etypes));

	if (!^(senv.update) || iteration <= 0) {
		if (last) {
			finalResolvePhase(nenv, flowpath);
		} else {
			doResolveEClasses(nenv, flowpath, verbose, true, 5);
		}
	} else {
		doResolveEClasses(nenv, flowpath, verbose, last, iteration - 1);
	}
}

dumpEClasses(env : TTypeEnv, label : string) -> void {
	normalizeTTypeDependencies(env.tgraph);

	roots = getEClassRoots(env.tgraph);
	graph = "digraph graphname {\n";
	nodes = foldSet(roots, graph, \acc, root -> {
		text = eclassString(env, root, false);
		if (text != "") println(text);

		node = eclassString(env, root, true);
		acc + "e" + i2s(root) + " [label=" 
		+ toString(node)
		+ "];\n"
	});
	links = foldTree(^(env.tgraph.dependencies), nodes, \from : int, to : Set<int>, acc : string -> {
		foldSet(to, acc, \acc2, t -> {
			acc2 + "e" + i2s(from) + " -> e" + i2s(t) + ";\n"
		});
	});
	dot = links + "}";
	setFileContent("graph" + label + ".dot", dot);
	{}
}

eclassString(env : TTypeEnv, root : int, verbose : bool) -> string {
	cost = costTTypeEClass(env, ref makeSet(), root);

	node = getEClassTypeNode(env.tgraph, root);
	childClasses = foldRange(0, ^(env.tgraph.nextEClass), [], \acc, ec -> {
		r = rootTTypeEClass(env.tgraph, ec);
		if (r == root) {
			arrayPush(acc, ec)
		} else acc;
	});
	type = lookupTreeDef(env.etypes, root, TTypeEClass(root));
	if (!verbose && type == TTypeEClass(root) && node == defaultTTypeNode()) {
		"";
	} else {
		if (verbose) {
			"e" + i2s(root) + ": "
			+ prettyTType(type) + "\n"
			+ prettyTType(cost.type) + " benefit: " + i2s(cost.benefit) + ", cost: " + i2s(cost.cost) + "\n"
			+ strGlue(strWordWrap(ttypeNode2string(env, node), 80, [" "]), "\n")
			+ "\ncovers " + superglue(childClasses, \ec -> "e" + i2s(ec), ", ")
		} else {
			"e" + i2s(root) + ": "
			+ rpad(prettyTType(type), " ", 40) + " from "
			+ ttypeNode2string(env, node)
			+ " covers " + superglue(childClasses, \ec -> "e" + i2s(ec), ", ")
		}
	}	
}

ttypeNode2string(env : TTypeEnv, t : TTypeNode) -> string {
	tp = \tt, ts -> {
		if (ts == []) ""
		else {
			(if (tt != "") tt + ":" else "") + "{ " +  superglue(ts, \ttt -> {
				st = canonicalTTypeEClass(env.tgraph, ttt);
				prettyTType(st)
			}, "; ") + " } "
		}
	}
	tp("", t.best) 
	+ switch (t.overload) {
		None(): "";
		Some(ov): tp("Overloads", ov.overloads)
	}
	+ switch (t.supertype) {
		None(): "";
		Some(st): tp("Supertypes " + i2s(st.unique), st.subtypes)
	}
	+ tp("Originals", set2array(t.originals))
	+ "  " + strGlue(t.reasons, ", ")
}

simplifyTTypeNode(senv : SimplifyEnv, teclass : int, last : bool) -> void {
	env = senv.env;
	eclass = rootTTypeEClass(env.tgraph, teclass);
	if (containsSet(^(senv.visiting), eclass)) {
		// Nothing to be done
	} else {
		node = getEClassTypeNode(env.tgraph, eclass);
		ctype = lookupTree(^(senv.etypes), eclass);
		switch (ctype) {
			Some(type): {
				// Already set, but maybe we need to unify with more stuff?
				// unifyTypeToEClass(senv.env.tgraph, eclass, type, ["eclass " + i2s(eclass) + " resolved"], []);
			}
			None(): {
				senv.visiting := insertSet(^(senv.visiting), eclass);

				// println("Starting to simplifying " + i2s(eclass) + ": " + ttypeNode2string(env, node));

				// Simplify dependents and resolve
				snode = basicSimplifyTypenode(senv, eclass, node);
			
				// Make sure we remember all the original nodes
				fnode = addOriginals(node, snode);

				if (fnode != node) {
					setEClassTypeNode(env.tgraph, eclass, fnode);

					clarifyEClass(env, eclass, fnode);

					if (false) {
						println("Simplified e" + i2s(eclass) + "\n  " + ttypeNode2string(env, node) + " to\n  " + ttypeNode2string(env, fnode));
					}
					senv.update := true;
				}

				// See if we can resolve the overloads
				if (simplifyTTypeOverload(senv, eclass, fnode, last)) {
					senv.update := true;
				} else if (simplifyTTypesuper(senv, eclass, fnode, last)) {
					// See if we can resolve the supertype
					senv.update := true;
				}

				mtype = resolvedTTypeNode(fnode);
				mtype ?? {
					if (senv.verbose || isTracingId(senv.env.tracing, StageTypeResolve(), 1, senv.flowpath)) {
						line = "Resolved e" + i2s(eclass) + " to " + prettyTType(mtype);
						output = if (isTracingId(senv.env.tracing, StageTypeResolve(), 2, senv.flowpath)) {
							line
							+ " with\n  " + ttypeNode2string(env, fnode)
							+ " from\n  " + ttypeNode2string(env, node)
						} else line;
						println(output);
					}
					senv.etypes := setTree(^(senv.etypes), eclass, mtype);
					// We know the resolved type is in the "best" field of the typenode
					senv.update := true;
				} : {}

			}
		}
	}
}

// Simplifies dependent types, as well as instantiates known types and resolves typeclasses
// and inlines nested supertypes
basicSimplifyTypenode(senv : SimplifyEnv, eclass : int, node : TTypeNode) -> TTypeNode {
	// Simplify the best nodes, if we can. (Recursive)
	bests = sortUnique(map(node.best, \t -> simplifyType(senv, t)));

	// Simplify the overloads
	moverload = switch (node.overload) {
		None(): None();
		Some(overload): {
			Some(
				TTypeOverload(
					overload.unique,
					sortUnique(map(overload.overloads, \t -> simplifyType(senv, t)))
				)
			)
		}
	};

	// Simplify the super types
	msuper = switch (node.supertype) {
		None(): None();
		Some(supertype): {
			supers0 = map(supertype.subtypes, \st -> simplifyType(senv, st));
			// "Inline" all supers inside supers
			supers1 : Set<TType> = fold(supers0, makeSet(), \acc, st -> {
				addTTypeSupers(senv, acc, eclass, st)
			});
			supers = set2array(supers1);
			if (supers == []) None()
			else Some(
				TTypeSupertype(
					supertype with subtypes = supers
				)
			)
		}
	}
	TTypeNode(node with best = bests, overload = moverload, supertype = msuper);
}

// If we have a supertype, this will try to resolve it
simplifyTTypesuper(senv : SimplifyEnv, eclass : int, node : TTypeNode, last : bool) -> bool {
	switch (node.supertype) {
		None(): false;
		Some(supertype): {
			resolveTTypeSuper(senv.env, senv.verbose, eclass, node, last, supertype);
		}
	}
}

simplifyTTypeOverload(senv : SimplifyEnv, eclass : int, node : TTypeNode, last : bool) -> bool {
	switch (node.overload) {
		None(): false;
		Some(overload): {
			good = filter(overload.overloads, \ol -> {
				possibleTTypeNodeMatch(senv.env, node, ol)
			});
			n = length(good);
			if (n == 1) {
				winner = good[0];
				// println("Resolved overload in simplification to " + prettyTType(winner) + " from " + prettyTType(overload));
				unifyTypeToEClass(senv.env, eclass, winner, ["resolve overload"], []);
				true;
			} else {
				false;
			}
		}
	}
}

// Unify all the elements in these typenodes

simplifyType(senv : SimplifyEnv, t : TType) -> TType {
	rec = \tt -> simplifyType(senv, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): {
			root = rootTTypeEClass(senv.env.tgraph, eclass);

			// Then check if we have a solution
			mtype = lookupTree(^(senv.etypes), root);
			mtype ?? {
				if (simplifyType(senv, mtype) != mtype) {
					println("Not canonical type in the environment");
				}
				mtype;
			} : {
				// OK, simplify this recursively
				simplifyTTypeNode(senv, root, false);

				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): {
			TTypeFunction(map(args, rec), rec(returnType));
		}
		TTypeOverload(unique, overloads): {
			TTypeOverload(unique, sortUnique(map(overloads, rec)));
		}
		TTypeSupertype(unique, subtypes, maxed): {
			class = findEClass(senv.env.tgraph, t);
			if (class != -1 && !containsSet(^(senv.visiting), class)) {
				// OK, we have this supertype resolved elsewhere
				simplifyType(senv, TTypeEClass(class));
			} else {
				// This supertype does not have a class?
				// println(prettyTType(t) + " does not have an eclass:");
				// dumpEClasses(senv.env);
				subs = sortUnique(map(subtypes, rec));
				TTypeSupertype(unique, subs, maxed);
			}
		}
	}
}

resolvedTTypeNode(node : TTypeNode) -> Maybe<TType> {
	resolved = filter(node.best, \tt -> !unresolvedTType(tt));
	if (resolved != []) {
		if (length(resolved) > 1) {
			println("More than one best type: " + superglue(resolved, prettyTType, ","));
		}
		Some(resolved[0]);
	} else {
		None();
	}
}

canonicalTTypeEClass(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTTypeEClass(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes, maxed): TTypeSupertype(unique, sortUnique(map(subtypes, rec)), maxed);
	}
}

addOriginals(orig : TTypeNode, n : TTypeNode) -> TTypeNode {
	add = \acc, m -> {
		switch (m) {
			None(): acc;
			Some(t): insertSet(acc, t);
		}
	};
	origs1 = add(n.originals, orig.overload);
	origs2 = add(origs1, orig.supertype);
	origs3 = fold(orig.best, origs2, \acc, b -> insertSet(acc, b));
	rem = \acc, m : Maybe<TType> -> {
		switch (m) {
			None(): acc;
			Some(t): removeSet(acc, t)
		}
	}
	origs4 = rem(origs3, n.overload);
	origs5 = rem(origs4, n.supertype);
	origs6 = fold(n.best, origs5, \acc, b -> removeSet(acc, b));

	TTypeNode(n with originals = origs6)
}

finalResolvePhase(env : TTypeEnv, flowpath : string) -> TTypeEnv {
	if (isTracingId(env.tracing, StageTypeResolve(), 1, flowpath)) {
		println("\nFinal " + flowpath);
		dumpEClasses(env, "-final");
	}
	roots = getEClassRoots(env.tgraph);
	foldSet(roots, env, \acc, root -> {
		if (!containsKeyTree(acc.etypes, root)) {
			node = getEClassTypeNode(acc.tgraph, root);
			if (length(node.best) >= 1) {
				// TODO: We could attempt to generalize any type vars here
				TTypeEnv(acc with etypes = setTree(acc.etypes, root, node.best[0]))
			} else {
				def = \ -> {
					if (node.positions == []) {
						acc
					} else {
						acc.onError(elementAt(node.positions, 0, -1), "Could not resolve " + ttypeNode2string(acc, node));
						acc;
					}
				}
				switch (node.supertype) {
					None(): def();
					Some(supertype): {
						if (length(supertype.subtypes) == 1) {
							type = supertype.subtypes[0];
							TTypeEnv(acc with etypes = setTree(acc.etypes, root, type))
						} else def();
					}
				}

			}
		} else acc;
	});
}

// Extract all super types to this type
addTTypeSupers(senv : SimplifyEnv, acc : Set<TType>, eclass : int, type : TType) -> Set<TType> {
	switch (type) {
		TTypeSupertype(__ , types, __): fold(types, acc, insertSet);
		TTypeEClass(cl): {
			// We should ignore types to ourselves
			root = rootTTypeEClass(senv.env.tgraph, cl);
			if (root != eclass) {
				addEClassSupers(senv, acc, root)
			} else acc;
		}
		default: insertSet(acc, type);
	}
}

// Add the potential supertypes of this eclass to the set of types
addEClassSupers(senv : SimplifyEnv, acc : Set<TType>, eclass : int) -> Set<TType> {
	node = getEClassTypeNode(senv.env.tgraph, eclass);
	nacc = fold(node.best, acc, insertSet);
	insertSet(nacc, TTypeEClass(eclass));
}

cleanEClasses(env : TTypeEnv) -> void {
	roots = getEClassRoots(env.tgraph);
	iterSet(roots, \root -> {
		mtype = lookupTree(env.etypes, root);
		mtype ?? {
			if (!unresolvedTType(mtype)) {
				// OK, clean up the type node to simplify it
				node = getEClassTypeNode(env.tgraph, root);
				cleanNode = TTypeNode([mtype], None(), None(), makeSet(), [], []);
			//	println("Cleaning " + ttypeNode2string(env, node) + " to " + ttypeNode2string(env, cleanNode));
				setEClassTypeNode(env.tgraph, root, cleanNode);
			}
		} : {}
	});
}
