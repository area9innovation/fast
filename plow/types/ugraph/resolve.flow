import plow/types/typeenv;
import plow/types/supertype;
import plow/types/unify;
import plow/types/ugraph/ugraph;

export {
	resolveEClasses(env : TTypeEnv) -> TTypeEnv;
}

resolveEClasses(env : TTypeEnv) -> TTypeEnv {
	// println("\nNow about to resolve\n");
	doResolveEClasses(env, 10);
}

SimplifyEnv(
	env : TTypeEnv,
	etypes : ref Tree<int, TType>,
	visiting : ref Set<int>,
	update : ref bool,
);

doResolveEClasses(env : TTypeEnv, iteration : int) -> TTypeEnv {
	if (true) {
		println("\nIteration " + i2s(iteration));
		dumpEClasses(env);
	}

	roots = getEClassRoots(env.tgraph);
	senv = SimplifyEnv(env, ref env.etypes, ref makeSet(), ref false);
	iterSet(roots, \root -> {
		simplifyTTypeNode(senv, root);
		{}
	});
	nenv = TTypeEnv(env with etypes = ^(senv.etypes));

	if (!^(senv.update) || iteration <= 0) {
		dumpEClasses(nenv);
		nenv;
	} else {
		doResolveEClasses(nenv, iteration - 1);
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	roots = getEClassRoots(env.tgraph);

	iterSet(roots, \root : int -> {
		node = getUnionMapValue(env.tgraph.umap, root);
		type = lookupTreeDef(env.etypes, root, TTypeEClass(root));
		println("Class e" + i2s(root) + " : "
			+ rpad(prettyTType(type), " ", 40) + " from "
			+ ttypeNode2string(env, node)
		);
	});
}

ttypeNode2string(env : TTypeEnv, t : TTypeNode) -> string {
	tp = \tt, ts -> {
		if (ts == []) ""
		else {
			(if (tt != "") tt + ":" else "") + "{ " +  superglue(ts, \ttt -> {
				st = canonicalTTypeEClass(env.tgraph, ttt);
				prettyTType(st)
			}, "; ") + " } "
		}
	}
	tp("", t.best) 
	+ switch (t.overload) {
		None(): "";
		Some(ov): tp("Overloads", ov.overloads)
	}
	+ tp("Supertypes", t.supertypes)
}

simplifyTTypeNode(senv : SimplifyEnv, eclass : int) -> void {
	env = senv.env;
	node = getUnionMapValue(env.tgraph.umap, eclass);

	if (containsSet(^(senv.visiting), eclass) || containsKeyTree(^(senv.etypes), eclass)) {

	} else {
		senv.visiting := insertSet(^(senv.visiting), eclass);
		// println("Starting to simplifying " + i2s(eclass));

		// Simplify the best nodes, if we can
		bests = sortUnique(map(node.best, \t -> {
			simplifyType(senv, t);
		}));

		supers0 = map(node.supertypes, \st -> simplifyType(senv, st));
		// Supers pointing to ourselves are useless
		supers = sortUnique(filter(supers0, \s -> {
			switch (s) {
				TTypeEClass(sr): rootTTypeEClass(env.tgraph, sr) != eclass;
				default: true;
			}
		}));
		supertype = TTypeSupertype(node.supertypeUnique, supers);

		if (false) {
			if (length(bests) > 0) {
				// Unify among the best types
				iteri(bests, \i, b1 -> {
					iter(tailFrom(bests, i + 1), \b2 -> {
						unifyTType(env, "eclass " + i2s(eclass) + " simplify", -1, b1, b2)
					})
				});
				// Unify against the supertype
				if (supertype.unique != -1) {
					iter(bests, \b -> {
						unifyTType(env, "eclass " + i2s(eclass) + " supers", -1, b, supertype);
					});
				}
			}
		}

		bnode = TTypeNode(node with best = bests, supertypes = supers);

		// See if we can resolve the supertype
		stype = if (supertype.unique != -1) {
			potsupers = resolveTSupertype(env, supertype);
			println(potsupers);
			// type = instantiateTTypeName(env, potsupers[0]);
			supertype;
		} else supertype;

		snode = switch (stype) {
			TTypeSupertype(__, st): {
				TTypeNode(bnode with supertypes = st);
			}
			default: {
				// OK, we have a winner.
				// Make sure to unify this one against each type
				// println("Resolved " + i2s(eclass) + " supertype to " + prettyTType(stype));
				// unifyTType(env, "eclass " + i2s(eclass) + " super resolved", -1, stype, supertype);
				// And promote this to be the winner

				sbests = sortUnique(map(arrayPush(bnode.best, stype), \t -> {
					simplifyType(senv, t);
				}));
				TTypeNode(bnode with best = sbests, supertypes = [])
			}
		};

		// TODO: If we have a supertype

		if (snode != node) {
			mtype = resolvedTTypeNode(snode);
			fnode = mtype ?? {
				if (!unresolvedTType(mtype)) {
					println("Resolved " + i2s(eclass) + " to " + prettyTType(mtype));
					senv.etypes := setTree(^(senv.etypes), eclass, mtype);
					TTypeNode([mtype], None(), bnode.supertypeUnique, []);
				} else snode;
			} : {
				snode;
			}

			setUnionMapValue(env.tgraph.umap, eclass, fnode);

			println("Simplified " + i2s(eclass) + " " + ttypeNode2string(env, node) + " to " + ttypeNode2string(env, fnode));
			senv.update := true;
		}

		senv.visiting := removeSet(^(senv.visiting), eclass);
	}
}

simplifyType(senv : SimplifyEnv, t : TType) -> TType {
	rec = \tt -> simplifyType(senv, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): {
			root = rootTTypeEClass(senv.env.tgraph, eclass);
			// OK, simplify this recursively
			simplifyTTypeNode(senv, root);

			// Then check if we have a solution
			mtype = lookupTree(^(senv.etypes), root);
			mtype ?? {
				if (simplifyType(senv, mtype) != mtype) {
					println("Not canonical type in the environment");
				}
				mtype;
			} : {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes): {
			TTypeSupertype(unique, sortUnique(map(subtypes, rec)));
		}
	}
}

resolvedTTypeNode(node : TTypeNode) -> Maybe<TType> {
	if (length(node.best) == 1) {
		t = node.best[0];
		if (unresolvedTType(t)) None()
		else Some(t);
	} else None();
}


canonicalTTypeEClass(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTTypeEClass(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes): TTypeSupertype(unique, sortUnique(map(subtypes, rec)));
	}
}