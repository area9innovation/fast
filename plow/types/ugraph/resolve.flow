import plow/types/typeenv;
import plow/types/unify;
import plow/types/ugraph/supertype;
import plow/types/ugraph/ugraph;

/*
TODO:
- For supertypes, expand to cover all suitable types for typenodes
  and that way, try to resolve supertypes more usefully

So the loop should be this:
  - Simplify: Instantiate decided eclasses and substitute everywhere.
    This by itself should not cause any new unifications to happen

  - Overloads should filter candidates if we have any other info, and thus limit the field.
    Does not cause new unification, unless the overload is resolved.
	This happens when we unify the overload with bests.

  - Supertypes: Expand to all possible supertypes. If unique, then resolve.

  - Unify new information with other info.
*/

export {
	resolveEClasses(env : TTypeEnv, flowpath : string,  verbose : bool) -> TTypeEnv;
}

resolveEClasses(env : TTypeEnv, flowpath : string, verbose : bool) -> TTypeEnv {
	doResolveEClasses(env, flowpath, verbose, false, 5);
}

SimplifyEnv(
	env : TTypeEnv,
	flowpath : string,
	verbose : bool,
	etypes : ref Tree<int, TType>,
	visiting : ref Set<int>,
	update : ref bool,
);

doResolveEClasses(env : TTypeEnv, flowpath : string, verbose : bool, last : bool, iteration : int) -> TTypeEnv {
	if (verbose || isTracingId(env.tracing, StageTypeResolve(), 2, flowpath)) {
		println("\nResolve " + flowpath + ": Iteration " + i2s(iteration) + (if (last) ". Decision time" else ""));
		dumpEClasses(env);
	}
	env.visited := makeSet();

	roots = getEClassRoots(env.tgraph);
	senv = SimplifyEnv(env, flowpath, verbose, ref env.etypes, ref makeSet(), ref false);
	iterSet(roots, \root -> {
		simplifyTTypeNode(senv, root, last);
		{}
	});
	nenv = TTypeEnv(env with etypes = ^(senv.etypes));

	if (!^(senv.update) || iteration <= 0) {
		if (last) {
			finalResolvePhase(nenv, flowpath);
		} else {
			doResolveEClasses(nenv, flowpath, verbose, true, 5);
		}
	} else {
		doResolveEClasses(nenv, flowpath, verbose, last, iteration - 1);
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	roots = getEClassRoots(env.tgraph);

	iterSet(roots, \root : int -> {
		node = getUnionMapValue(env.tgraph.umap, root);
		childClasses = foldRange(0, ^(env.tgraph.nextEClass), [], \acc, ec -> {
			r = findUnionMapRoot(env.tgraph.umap, ec);
			if (r == root) {
				arrayPush(acc, ec)
			} else acc;
		});
		type = lookupTreeDef(env.etypes, root, TTypeEClass(root));
		if (type == TTypeEClass(root) && node == defaultTTypeNode()) {

		} else {
			println("Class e" + i2s(root) + " : "
				+ rpad(prettyTType(type), " ", 40) + " from "
				+ ttypeNode2string(env, node)
				+ " covers " + superglue(childClasses, \ec -> "e" + i2s(ec), ", ")
			);
		}
	});
}

ttypeNode2string(env : TTypeEnv, t : TTypeNode) -> string {
	tp = \tt, ts -> {
		if (ts == []) ""
		else {
			(if (tt != "") tt + ":" else "") + "{ " +  superglue(ts, \ttt -> {
				st = canonicalTTypeEClass(env.tgraph, ttt);
				prettyTType(st)
			}, "; ") + " } "
		}
	}
	tp("", t.best) 
	+ switch (t.overload) {
		None(): "";
		Some(ov): tp("Overloads", ov.overloads)
	}
	+ switch (t.supertype) {
		None(): "";
		Some(st): tp("Supertypes " + i2s(st.unique), st.subtypes)
	}
	+ tp("Originals", set2array(t.originals))
	+ "  " + strGlue(t.reasons, ", ")
}

simplifyTTypeNode(senv : SimplifyEnv, eclass : int, last : bool) -> void {
	env = senv.env;
	if (containsSet(^(senv.visiting), eclass)) {
		// Nothing to be done
	} else {
		node = getUnionMapValue(env.tgraph.umap, eclass);
		ctype = lookupTree(^(senv.etypes), eclass);
		switch (ctype) {
			Some(type): {
				// Already set, but maybe we need to unify with more stuff?
				// unifyTypeToEClass(senv.env.tgraph, eclass, type, ["eclass " + i2s(eclass) + " resolved"], []);
			}
			None(): {
				senv.visiting := insertSet(^(senv.visiting), eclass);

				// println("Starting to simplifying " + i2s(eclass));

				// Simplify dependents and resolve
				snode = basicSimplifyTypenode(senv, eclass, node);
			
				// See if we can resolve the supertype
				if (simplifyTTypesuper(senv, eclass, snode, last)) {
					senv.update := true;
				}

				// Make sure we remember all the original nodes
				fnode = addOriginals(node, snode);

				mtype = resolvedTTypeNode(fnode);
				mtype ?? {
					if (senv.verbose || isTracingId(senv.env.tracing, StageTypeResolve(), 1, senv.flowpath)) {
						println("Resolved " + i2s(eclass) + " to " + prettyTType(mtype) 
							+ " with\n  " + ttypeNode2string(env, fnode)
							+ " from\n  " + ttypeNode2string(env, node)
						);
					}
					senv.etypes := setTree(^(senv.etypes), eclass, mtype);
					// We know the resolved type is in the "best" field of the typenode
					senv.update := true;
				} : {}

				if (fnode != node) {
					setUnionMapValue(env.tgraph.umap, eclass, fnode);

					clarifyEClass(env, eclass, fnode);

					// println("Simplified " + i2s(eclass) + "\n  " + ttypeNode2string(env, node) + " to\n  " + ttypeNode2string(env, fnode));
					senv.update := true;
				}
				senv.visiting := removeSet(^(senv.visiting), eclass);
			}
		}
	}
}

// Simplifies dependent types, as well as instantiates known types and resolves typeclasses
basicSimplifyTypenode(senv : SimplifyEnv, eclass : int, node : TTypeNode) -> TTypeNode {
	// Simplify the best nodes, if we can. (Recursive)
	bests = sortUnique(map(node.best, \t -> simplifyType(senv, t)));

	// Simplify the overloads
	moverload = switch (node.overload) {
		None(): None();
		Some(overload): {
			Some(
				TTypeOverload(
					overload.unique,
					sortUnique(map(overload.overloads, \t -> simplifyType(senv, t)))
				)
			)
		}
	};

	// Simplify the super types
	msuper = switch (node.supertype) {
		None(): None();
		Some(supertype): {
			supers0 = map(supertype.subtypes, \st -> simplifyType(senv, st));
			supers1 : Set<TType> = fold(supers0, makeSet(), \acc, st -> {
				addTTypeSupers(senv, acc, eclass, st)
			});
			supers = set2array(supers1);
			if (supers == []) None()
			else Some(
				TTypeSupertype(
					supertype with subtypes = supers
				)
			)
		}
	}
	TTypeNode(node with best = bests, overload = moverload, supertype = msuper);
}

// If we have a supertype, this will try to resolve it
simplifyTTypesuper(senv : SimplifyEnv, eclass : int, node : TTypeNode, last : bool) -> bool {
	switch (node.supertype) {
		None(): false;
		Some(supertype): {
			resolveTTypeSuper(senv.env, senv.verbose, eclass, node, last, supertype);
		}
	}
}

// Unify all the elements in these typenodes

simplifyType(senv : SimplifyEnv, t : TType) -> TType {
	rec = \tt -> simplifyType(senv, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): {
			root = rootTTypeEClass(senv.env.tgraph, eclass);
			// OK, simplify this recursively
			simplifyTTypeNode(senv, root, false);

			// Then check if we have a solution
			mtype = lookupTree(^(senv.etypes), root);
			mtype ?? {
				if (simplifyType(senv, mtype) != mtype) {
					println("Not canonical type in the environment");
				}
				mtype;
			} : {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): {
			TTypeFunction(map(args, rec), rec(returnType));
		}
		TTypeOverload(unique, overloads): {
			TTypeOverload(unique, sortUnique(map(overloads, rec)));
		}
		TTypeSupertype(unique, subtypes, maxed): {
			class = findEClass(senv.env.tgraph, t);
			if (class != -1 && !containsSet(^(senv.visiting), class)) {
				// OK, we have this supertype resolved elsewhere
				simplifyType(senv, TTypeEClass(class));
			} else {
				println("NOT SUPPOSED TO HAPPEN");
				subs = sortUnique(map(subtypes, rec));
				TTypeSupertype(unique, subs, maxed);
			}
		}
	}
}

resolvedTTypeNode(node : TTypeNode) -> Maybe<TType> {
	resolved = filter(node.best, \tt -> !unresolvedTType(tt));
	if (resolved != []) {
		if (length(resolved) > 1) {
			println("More than one best type: " + superglue(resolved, prettyTType, ","));
		}
		Some(resolved[0]);
	} else {
		None();
	}
}

canonicalTTypeEClass(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTTypeEClass(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes, maxed): TTypeSupertype(unique, sortUnique(map(subtypes, rec)), maxed);
	}
}

addOriginals(orig : TTypeNode, n : TTypeNode) -> TTypeNode {
	add = \acc, m -> {
		switch (m) {
			None(): acc;
			Some(t): insertSet(acc, t);
		}
	};
	origs1 = add(n.originals, orig.overload);
	origs2 = add(origs1, orig.supertype);
	origs3 = fold(orig.best, origs2, \acc, b -> insertSet(acc, b));
	rem = \acc, m : Maybe<TType> -> {
		switch (m) {
			None(): acc;
			Some(t): removeSet(acc, t)
		}
	}
	origs4 = rem(origs3, n.overload);
	origs5 = rem(origs4, n.supertype);
	origs6 = fold(n.best, origs5, \acc, b -> removeSet(acc, b));

	TTypeNode(n with originals =  origs6)
}

finalResolvePhase(env : TTypeEnv, flowpath : string) -> TTypeEnv {
	if (isTracingId(env.tracing, StageTypeResolve(), 1, flowpath)) {
		println("\nFinal " + flowpath);
		dumpEClasses(env);
	}
	roots = getEClassRoots(env.tgraph);
	foldSet(roots, env, \acc, root -> {
		if (!containsKeyTree(acc.etypes, root)) {
			node = getUnionMapValue(acc.tgraph.umap, root);
			if (length(node.best) >= 1) {
				// TODO: We could attempt to generalize any type vars here
				TTypeEnv(acc with etypes = setTree(acc.etypes, root, node.best[0]))
			} else {
				def = \ -> {
					if (node.positions == []) {
						acc
					} else {
						acc.onError(elementAt(node.positions, 0, -1), "Could not resolve " + ttypeNode2string(acc, node));
						acc;
					}
				}
				switch (node.supertype) {
					None(): def();
					Some(supertype): {
						if (length(supertype.subtypes) == 1) {
							type = supertype.subtypes[0];
							TTypeEnv(acc with etypes = setTree(acc.etypes, root, type))
						} else def();
					}
				}

			}
		} else acc;
	});
}

addTTypeSupers(senv : SimplifyEnv, acc : Set<TType>, eclass : int, type : TType) -> Set<TType> {
	switch (type) {
		TTypeSupertype(__ , types, __): fold(types, acc, insertSet);
		TTypeEClass(cl): {
			// We should ignore types to ourselves
			root = rootTTypeEClass(senv.env.tgraph, cl);
			if (root != eclass) {
				addEClassSupers(senv, acc, root)
			} else acc;
		}
		default: insertSet(acc, type);
	}
}

// Add the potential supertypes of this eclass to the set of types
addEClassSupers(senv : SimplifyEnv, acc : Set<TType>, eclass : int) -> Set<TType> {
	node = getUnionMapValue(senv.env.tgraph.umap, eclass);
	nacc = fold(node.best, acc, insertSet);
	insertSet(nacc, TTypeEClass(eclass));
}
