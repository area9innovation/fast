import plow/types/typeenv;
import plow/types/supertype;
import plow/types/unify;
import plow/types/ugraph/ugraph;

export {
	resolveEClasses(env : TTypeEnv) -> TTypeEnv;
}

resolveEClasses(env : TTypeEnv) -> TTypeEnv {
	// println("\nNow about to resolve\n");
	doResolveEClasses(env, 10);
}

SimplifyEnv(
	env : TTypeEnv,
	etypes : ref Tree<int, TType>,
	visiting : ref Set<int>,
	update : ref bool,
);

doResolveEClasses(env : TTypeEnv, iteration : int) -> TTypeEnv {
	if (true) {
		println("\nIteration " + i2s(iteration));
		dumpEClasses(env);
	}

	roots = getEClassRoots(env.tgraph);
	senv = SimplifyEnv(env, ref env.etypes, ref makeSet(), ref false);
	iterSet(roots, \root -> {
		simplifyTTypeNode(senv, root);
		{}
	});
	nenv = TTypeEnv(env with etypes = ^(senv.etypes));

	if (!^(senv.update) || iteration <= 0) {
		dumpEClasses(nenv);
		nenv;
	} else {
		doResolveEClasses(nenv, iteration - 1);
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	roots = getEClassRoots(env.tgraph);

	iterSet(roots, \root : int -> {
		node = getUnionMapValue(env.tgraph.umap, root);
		type = lookupTreeDef(env.etypes, root, TTypeEClass(root));
		println("Class e" + i2s(root) + " : "
			+ rpad(prettyTType(type), " ", 40) + " from "
			+ ttypeNode2string(env, node)
		);
	});
}

ttypeNode2string(env : TTypeEnv, t : TTypeNode) -> string {
	tp = \tt, ts -> {
		if (ts == []) ""
		else {
			(if (tt != "") tt + ":" else "") + "{ " +  superglue(ts, \ttt -> {
				st = canonicalTTypeEClass(env.tgraph, ttt);
				prettyTType(st)
			}, "; ") + " } "
		}
	}
	tp("", t.best) 
	+ switch (t.overload) {
		None(): "";
		Some(ov): tp("Overloads", ov.overloads)
	}
	+ tp("Supertypes", t.supertypes)
}

simplifyTTypeNode(senv : SimplifyEnv, eclass : int) -> void {
	env = senv.env;
	node = getUnionMapValue(env.tgraph.umap, eclass);

	if (containsSet(^(senv.visiting), eclass) || containsKeyTree(^(senv.etypes), eclass)) {

	} else {
		senv.visiting := insertSet(^(senv.visiting), eclass);

		// println("Starting to simplifying " + i2s(eclass));

		// Simplify dependents and resolve
		bnode = basicSimplifyTypenode(senv, eclass, node);
	
		// See if we can resolve the supertype
		snode = simplifyTTypesuper(env, bnode);

		// OK, then we should unify the entire thing again against the original
		unifyTTypenodes(env, eclass, node, snode);

		// OK, simplify a final time after unification
		fnode : TTypeNode = basicSimplifyTypenode(senv, eclass, snode);

		if (fnode != node) {
			mtype = resolvedTTypeNode(fnode);
			mtype ?? {
				if (!unresolvedTType(mtype)) {
					println("Resolved " + i2s(eclass) + " to " + prettyTType(mtype));
					senv.etypes := setTree(^(senv.etypes), eclass, mtype);
				}
			} : {}

			setUnionMapValue(env.tgraph.umap, eclass, fnode);

			println("Simplified " + i2s(eclass) + " " + ttypeNode2string(env, node) + " to " + ttypeNode2string(env, fnode));
			senv.update := true;
		}

		senv.visiting := removeSet(^(senv.visiting), eclass);
	}
}

// Simplifies dependent types, as well as instantiates known types and resolves typeclasses
basicSimplifyTypenode(senv : SimplifyEnv, eclass : int, node : TTypeNode) -> TTypeNode {
	// Simplify the best nodes, if we can. (Recursive)
	bests = sortUnique(map(node.best, \t -> simplifyType(senv, t)));

	// Simplify the overloads
	moverload = switch (node.overload) {
		None(): None();
		Some(overload): {
			Some(
				TTypeOverload(
					overload.unique,
					sortUnique(map(overload.overloads, \t -> simplifyType(senv, t)))
				)
			)
		}
	};

	// Simplify the super types
	supers0 = map(node.supertypes, \st -> simplifyType(senv, st));
	// Supers pointing to ourselves are useless
	supers = sortUnique(filter(supers0, \s -> {
		switch (s) {
			TTypeEClass(sr): rootTTypeEClass(senv.env.tgraph, sr) != eclass;
			default: true;
		}
	}));
	TTypeNode(node with best = bests, overload = moverload, supertypes = supers);
}

simplifyTTypesuper(env : TTypeEnv, node : TTypeNode) -> TTypeNode {
	if (node.supertypeUnique != -1) {
		supertype = TTypeSupertype(node.supertypeUnique, node.supertypes);
		potsupers = resolveTSupertype(env, supertype);

		if (length(potsupers) == 1) {
			// OK, we have a unique super type
			supername = potsupers[0];
			mtype = hasTypeNodeThisName(node, supername);
			mtype ?? {
				// We found the type already
				makeTTypeNode(mtype);
			} : {
				// OK, the type does not exist. We have to construct it
				println("Made new type name");
				ntype = instantiateTTypeName(env, supername);
				makeTTypeNode(ntype);
			}
		} else node;
	} else node;
}

hasTypeNodeThisName(node : TTypeNode, name : string) -> Maybe<TType> {
	find(concat(node.best, node.supertypes), \n -> getTTypeName(n) == name);
}

// Unify all the elements in these typenodes
unifyTTypenodes(env : TTypeEnv, eclass : int, new : TTypeNode, old : TTypeNode) -> void {
	// Unify among the best types
	iteri(new.best, \i, b1 -> {
		iter(old.best, \b2 -> {
			unifyTType(env, "eclass " + i2s(eclass) + " simplify", -1, b1, b2)
		})
	});
	// Unify against the overloads
	
	// Unify against the supertype
	if (new.supertypeUnique != -1 && new.supertypes != []) {
		supertype = TTypeSupertype(new.supertypeUnique, new.supertypes);
		iter(new.best, \b -> {
//			println(prettyTType(b) + " against " + prettyTType(supertype));
			unifyTType(env, "eclass " + i2s(eclass) + " supers", -1, b, supertype);
		});
		iter(old.best, \b -> {
			unifyTType(env, "eclass " + i2s(eclass) + " supers", -1, b, supertype);
		});
	}
}

simplifyType(senv : SimplifyEnv, t : TType) -> TType {
	rec = \tt -> simplifyType(senv, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): {
			root = rootTTypeEClass(senv.env.tgraph, eclass);
			// OK, simplify this recursively
			simplifyTTypeNode(senv, root);

			// Then check if we have a solution
			mtype = lookupTree(^(senv.etypes), root);
			mtype ?? {
				if (simplifyType(senv, mtype) != mtype) {
					println("Not canonical type in the environment");
				}
				mtype;
			} : {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes): {
			subs = sortUnique(map(subtypes, rec));
			// Is there a type without a super type here?
			mtop = filter(subs, \s -> {
				tn = getTTypeName(s);
				if (tn != "") {
					supers = senv.env.resolveSupertypes(tn);
					supers == []
				} else false;
			});

			if (mtop != []) {
				// OK, are any of these fully resolved?
				resolved = filter(mtop, \m -> !unresolvedTType(m));
				if (resolved != []) {
					if (length(resolved) > 1) {
						senv.env.onError(-1, "This is not a unique super type: " + superglue(resolved, prettyTType, ", "))
					}
					resolved[0]
				} else {
					TTypeSupertype(unique, mtop);
				}
			} else {
				TTypeSupertype(unique, subs);
			}
		}
	}
}

resolvedTTypeNode(node : TTypeNode) -> Maybe<TType> {
	if (length(node.best) == 1) {
		t = node.best[0];
		if (unresolvedTType(t)) None()
		else Some(t);
	} else None();
}

canonicalTTypeEClass(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTTypeEClass(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes): TTypeSupertype(unique, sortUnique(map(subtypes, rec)));
	}
}