import plow/types/typeenv;
import plow/types/supertype;
import plow/types/unify;
import plow/types/ugraph/ugraph;

export {
	resolveEClasses(env : TTypeEnv) -> TTypeEnv;
}

resolveEClasses(env : TTypeEnv) -> TTypeEnv {
	// println("\nNow about to resolve\n");
	doResolveEClasses(env, 10);
}

SimplifyEnv(
	env : TTypeEnv,
	etypes : ref Tree<int, TType>,
	visiting : ref Set<int>,
	update : ref bool,
);

doResolveEClasses(env : TTypeEnv, iteration : int) -> TTypeEnv {
	if (true) {
		println("\nIteration " + i2s(iteration));
		dumpEClasses(env);
	}

	roots = getEClassRoots(env.tgraph);
	senv = SimplifyEnv(env, ref env.etypes, ref makeSet(), ref false);
	iterSet(roots, \root -> {
		simplifyTTypeNode(senv, root);
		{}
	});
	nenv = TTypeEnv(env with etypes = ^(senv.etypes));

	if (!^(senv.update) || iteration <= 0) {
		println("\nCompleted");
		dumpEClasses(nenv);

		nenv;
	} else {
		doResolveEClasses(nenv, iteration - 1);
	}
}

dumpEClasses(env : TTypeEnv) -> void {
	roots = getEClassRoots(env.tgraph);

	iterSet(roots, \root : int -> {
		node = getUnionMapValue(env.tgraph.umap, root);
		childClasses = foldRange(0, ^(env.tgraph.nextEClass), [], \acc, ec -> {
			r = findUnionMapRoot(env.tgraph.umap, ec);
			if (r == root) {
				arrayPush(acc, ec)
			} else acc;
		});
		type = lookupTreeDef(env.etypes, root, TTypeEClass(root));
		println("Class e" + i2s(root) + " : "
			+ rpad(prettyTType(type), " ", 40) + " from "
			+ ttypeNode2string(env, node)
			+ " covers " + superglue(childClasses, \ec -> "e" + i2s(ec), ", ")
		);
	});
}

ttypeNode2string(env : TTypeEnv, t : TTypeNode) -> string {
	tp = \tt, ts -> {
		if (ts == []) ""
		else {
			(if (tt != "") tt + ":" else "") + "{ " +  superglue(ts, \ttt -> {
				st = canonicalTTypeEClass(env.tgraph, ttt);
				prettyTType(st)
			}, "; ") + " } "
		}
	}
	tp("", t.best) 
	+ switch (t.overload) {
		None(): "";
		Some(ov): tp("Overloads", ov.overloads)
	}
	+ switch (t.supertype) {
		None(): "";
		Some(st): tp("Supertypes " + i2s(st.unique), st.subtypes)
	}
	+ tp("Originals", set2array(t.originals))
}

simplifyTTypeNode(senv : SimplifyEnv, eclass : int) -> void {
	env = senv.env;
	if (containsSet(^(senv.visiting), eclass) || containsKeyTree(^(senv.etypes), eclass)) {
		// Nothing to be done
	} else {
		node = getUnionMapValue(env.tgraph.umap, eclass);

		senv.visiting := insertSet(^(senv.visiting), eclass);

		// println("Starting to simplifying " + i2s(eclass));

		// Simplify dependents and resolve
		bnode = basicSimplifyTypenode(senv, eclass, node);
	
		// See if we can resolve the supertype
		snode = simplifyTTypesuper(env, eclass, bnode);

		// Make sure we remember all the original nodes
		onode = addOriginals(node, snode);

		// OK, then we should unify the entire thing again against the original
		unifyTTypenodes(env, eclass, node, onode);

		// OK, simplify a final time after unification
		fnode : TTypeNode = if (true) basicSimplifyTypenode(senv, eclass, onode) else onode;

		mtype = resolvedTTypeNode(fnode);
		mtype ?? {
			// println("Resolved " + i2s(eclass) + " to " + prettyTType(mtype));
			senv.etypes := setTree(^(senv.etypes), eclass, mtype);
			senv.update := true;
		} : {}

		if (fnode != node) {
			setUnionMapValue(env.tgraph.umap, eclass, fnode);

			// println("Simplified " + i2s(eclass) + " " + ttypeNode2string(env, node) + " to " + ttypeNode2string(env, fnode));
			senv.update := true;
		}

		senv.visiting := removeSet(^(senv.visiting), eclass);
	}
}

// Simplifies dependent types, as well as instantiates known types and resolves typeclasses
basicSimplifyTypenode(senv : SimplifyEnv, eclass : int, node : TTypeNode) -> TTypeNode {
	// Simplify the best nodes, if we can. (Recursive)
	bests = sortUnique(map(node.best, \t -> simplifyType(senv, t)));

	// Simplify the overloads
	moverload = switch (node.overload) {
		None(): None();
		Some(overload): {
			Some(
				TTypeOverload(
					overload.unique,
					sortUnique(map(overload.overloads, \t -> simplifyType(senv, t)))
				)
			)
		}
	};

	// Simplify the super types
	msuper = switch (node.supertype) {
		None(): None();
		Some(supertype): {
			supers0 = map(supertype.subtypes, \st -> simplifyType(senv, st));
			// Supers pointing to ourselves are useless
			supers = sortUnique(filter(supers0, \s -> {
				switch (s) {
					TTypeEClass(sr): rootTTypeEClass(senv.env.tgraph, sr) != eclass;
					default: true;
				}
			}));
			if (supers == []) None()
			else Some(
				TTypeSupertype(
					supertype with subtypes = supers
				)
			)
		}
	}
	TTypeNode(node with best = bests, overload = moverload, supertype = msuper);
}

simplifyTTypesuper(env : TTypeEnv, eclass : int, node : TTypeNode) -> TTypeNode {
	switch (node.supertype) {
		None(): node;
		Some(supertype): {
			potsupers = resolveTSupertype(env, supertype);

			if (length(potsupers) == 1) {
				// OK, we have a unique super type
				supername = potsupers[0];
				mtype = hasTypeNodeThisName(node, supername);
				mtype ?? {
					// We found the type already
					makeTTypeNode(mtype, node.reasons, node.positions);
				} : {
					// OK, the type does not exist. We have to construct it
					ntype = instantiateTTypeName(env, supername);
					// println("Made new type name for eclass " + i2s(eclass) + " from " + prettyTType(supertype));
					// println(ntype);
					makeTTypeNode(ntype, node.reasons, node.positions);
				}
			} else node;
		}
	}
}

hasTypeNodeThisName(node : TTypeNode, name : string) -> Maybe<TType> {
	supers = switch (node.supertype) {
		None(): [];
		Some(st): st.subtypes;
	}
	find(concat(node.best, supers), \n -> getTTypeName(n) == name);
}

// Unify all the elements in these typenodes
unifyTTypenodes(env : TTypeEnv, eclass : int, old : TTypeNode, new : TTypeNode) -> void {
	// Unify among the best types
	iteri(new.best, \i, b1 -> {
		iter(old.best, \b2 -> {
			unifyTType(env, "eclass " + i2s(eclass) + " simplify", elementAt(new.positions, 0, -1), b1, b2)
		});
		switch (old.overload) {
			None(): {}
			Some(ov): {
				unifyTType(env, "eclass " + i2s(eclass) + " overload 1", elementAt(new.positions, 0, -1), b1, ov);
			}
		}
		switch (old.supertype) {
			None(): {}
			Some(st): {
				unifyTType(env, "eclass " + i2s(eclass) + " super 1", elementAt(new.positions, 0, -1), b1, st);
			}
		}
		iterSet(new.originals, \o -> {
			unifyTType(env, "eclass " + i2s(eclass) + " origs", elementAt(new.positions, 0, -1), b1, o);
		})
	});

	// Unify best against the overloads
	switch (new.overload) {
		None(): {}
		Some(overload): {
			iter(new.best, \b -> {
				unifyTType(env, "eclass " + i2s(eclass) + " overload", elementAt(new.positions, 0, -1), b, overload);
			});
		}
	}

	// Unify best against the supertype
	switch (new.supertype) {
		None(): {}
		Some(supertype): {
			iter(new.best, \b -> {
				unifyTType(env, "eclass " + i2s(eclass) + " supers", elementAt(new.positions, 0, -1), b, supertype);
			});
		}
	}
}

simplifyType(senv : SimplifyEnv, t : TType) -> TType {
	rec = \tt -> simplifyType(senv, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): {
			root = rootTTypeEClass(senv.env.tgraph, eclass);
			// OK, simplify this recursively
			simplifyTTypeNode(senv, root);

			// Then check if we have a solution
			mtype = lookupTree(^(senv.etypes), root);
			mtype ?? {
				if (simplifyType(senv, mtype) != mtype) {
					println("Not canonical type in the environment");
				}
				mtype;
			} : {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): {
			TTypeOverload(unique, sortUnique(map(overloads, rec)));
		}
		TTypeSupertype(unique, subtypes, maxed): {
			class = findEClass(senv.env.tgraph, t);
			if (class != -1 && !containsSet(^(senv.visiting), class)) {
				// OK, we have this supertype resolved elsewhere
				simplifyType(senv, TTypeEClass(class));
			} else {
				subs = sortUnique(map(subtypes, rec));
				// Is there a type without a super type here?
				mtop = filter(subs, \s -> {
					tn = getTTypeName(s);
					if (tn != "") {
						supers = senv.env.resolveSupertypes(tn);
						supers == []
					} else false;
				});

				if (mtop != []) {
					// OK, are any of these fully resolved?
					resolved = filter(mtop, \m -> !unresolvedTType(m));
					if (resolved != []) {
						if (length(resolved) > 1) {
							// TODO: If maxed is given, we could maybe identify which it is
							senv.env.onError(-1, "This is not a unique super type: " + superglue(resolved, prettyTType, ", "))
						}
						resolved[0]
					} else {
						TTypeSupertype(unique, mtop, maxed);
					}
				} else {
					TTypeSupertype(unique, subs, maxed);
				}
			}
		}
	}
}

resolvedTTypeNode(node : TTypeNode) -> Maybe<TType> {
	resolved = filter(node.best, \tt -> !unresolvedTType(tt));
	if (resolved != []) {
		if (length(resolved) > 1) {
			println("More than one best type: " + superglue(resolved, prettyTType, ","));
		}
		Some(resolved[0]);
	} else {
		None();
	}
}

canonicalTTypeEClass(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTTypeEClass(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes, maxed): TTypeSupertype(unique, sortUnique(map(subtypes, rec)), maxed);
	}
}

addOriginals(orig : TTypeNode, n : TTypeNode) -> TTypeNode {
	add = \acc, m -> {
		switch (m) {
			None(): acc;
			Some(t): insertSet(acc, t);
		}
	};
	origs1 = add(n.originals, orig.overload);
	origs2 = add(origs1, orig.supertype);
	origs3 = fold(orig.best, origs2, \acc, b -> insertSet(acc, b));
	rem = \acc, m : Maybe<TType> -> {
		switch (m) {
			None(): acc;
			Some(t): removeSet(acc, t)
		}
	}
	origs4 = rem(origs3, n.overload);
	origs5 = rem(origs4, n.supertype);
	origs6 = fold(n.best, origs5, \acc, b -> removeSet(acc, b));

	TTypeNode(n with originals =  origs6)
}
