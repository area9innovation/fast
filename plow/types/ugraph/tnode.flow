import plow/types/ugraph/type;
import plow/types/pretty;

export {
	makeTMap(
		onError : (int, string) -> void, 
		nextEClass : ref int
	) -> TMap;

	setTMapResolvers(t : TMap, 
		resolveUnionName : (string) -> Maybe<DUnion>,
		resolveSupertypes : (string) -> [string], 
	) -> TMap;

	unifyTNodes(tmap : TMap, left : TType, right : TType) -> void;

	resolveTNodes(tmap : TMap) -> Tree<int, TType>;
}

makeTMap(onError : (int, string) -> void, nextEClass : ref int) -> TMap {
	self = ref None();
	tmap = TMap(
		makeUnionFindMap(defaultTNode(), \l, r -> {
			switch (^self) {
				None(): {
					println("NOT SUPPOSED TO HAPPEN");
					l;
				}
				Some(s): mergeTNodes(s, l, r);
			}
		}),
		\__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		\__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		onError,
		nextEClass,
	);
	self := Some(tmap);
	tmap;
}

setTMapResolvers(t : TMap, 
	resolveUnionName : (string) -> Maybe<DUnion>,
	resolveSupertypes : (string) -> [string], 
) -> TMap {
	TMap(t with 
		resolveUnionName = resolveUnionName,
		resolveSupertypes = resolveSupertypes
	);
}

defaultTNode() -> TNode {
	TNodeName("", []);
}

// These two types are unified
unifyTNodes(tmap : TMap, left : TType, right : TType) -> void {
	lclass = findTNode(tmap, left);
	rclass = findTNode(tmap, right);
	// println("Unify " + prettyTType(left) + " and " + prettyTType(right));
	if (lclass != -1 && rclass != -1) {
		// println("  Union e" + i2s(lclass) + " and e" + i2s(rclass));
		root = unionUnionMap(tmap.tmap, lclass, rclass);
		// println("  to e" + i2s(root) + " =  " + debugTNode(tmap, root));
		{}
	} else if (lclass != -1) {
		addTTypeToEClass(tmap, lclass, right);
	} else if (rclass != -1) {
		addTTypeToEClass(tmap, rclass, left);
	} else {
		lclass2 = findOrMakeTNodeClass(tmap, left);
		addTTypeToEClass(tmap, lclass2, right);
	}
}

// We promise there is no node for this
addTTypeToEClass(tmap : TMap, eclass : int, type : TType) -> void {
	switch (type) {
		TTypeEClass(nclass): {
			println("  NOT SUPPOSED TO HAPPEN e" + i2s(eclass) + " and e" + i2s(nclass));
			unionUnionMap(tmap.tmap, eclass, nclass);
			{}
		}
		default: {
			tnode1 = getUnionMapValue(tmap.tmap, eclass);
			if (isEmptyTNode(tnode1)) {
				tnode2 = makeTNode(tmap, type);
				// println("  Updating e" + i2s(eclass) + " to " + prettyTNode(tmap, tnode2));
				setUnionMapValue(tmap.tmap, eclass, tnode2)
			} else {
				// TODO: We could do it without making a new node
				// if we wanted to be a bit more clean
				// println("Can we add " + prettyTType(type) + " to " + prettyTNode(tmap, tnode1));
				tnode2 = makeTNode(tmap, type);
				// println("  Updating merged e" + i2s(eclass) + " from " + prettyTNode(tmap, tnode1) + " and " + prettyTNode(tmap, tnode2));
				nnode = mergeTNodes(tmap, tnode1, tnode2);
				// println("  Updating merged e" + i2s(eclass) + " to " + prettyTNode(tmap, nnode));
				root = findUnionMapRoot(tmap.tmap, eclass);
				if (root != eclass) {
					println("ERROR: The root changed!");
				}
				setUnionMapValue(tmap.tmap, eclass, nnode)
			}
		}
	}
}

makeTNode(tmap : TMap, t : TType) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", []);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st))
			))
		}
		TTypeSupertype(unique, subtypes, maxed): {
			supers = fold(subtypes, [], \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, TNodeSupertype(
				makeSet1(unique), 
				supers
			))
		}
	}
}

extractSupers(tmap : TMap, acc : [TNodeName], t : TType) -> [TNodeName] {
	todo = \ -> {
		println("TODO: Figure out how to represent this as a named node: " + prettyTType(t));
		acc;
	}
	switch (t) {
		TTypeSupertype(__, sub, __): fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars): arrayPush(acc, node);
				TNodeOverload(unique, overloads): todo();
				TNodeSupertype(uniques, subtypes): concat(acc, subtypes);
			}
		}
		TTypeName(__, __): {
			arrayPush(acc, makeTNodeName(tmap, t));
		}
		TTypeFunction(args, returnType): {
			arrayPush(acc, makeTNodeName(tmap, t));
		}
		TTypeOverload(unique, overloads): todo();
	}
}

simplifyTNode(tmap : TMap, node : TNode) -> TNode {
	switch (node) {
		TNodeName(name, typars): node;
		TNodeOverload(unique, overloads): {
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				// TODO: Doubt anything else is possible here?
				node;
			}
		}
		TNodeSupertype(uniques, subtypes): {
			// OK, we can calculate potential super types here
			// and reduce them to an overload or a given type
			named = foldi(subtypes, makeSet(), \i, acc, t : TNodeName -> {
				id = t.name;
				supers0 = tmap.resolveSupertypes(id);
				supers = arrayPush(supers0, id);
				supset = buildSet(supers);
				if (i == 0) supset
				else intersectSets(supset, acc)
			});

			nnamed = sizeSet(named);

			// Here we have the names that are possible
			if (nnamed == 1) {
				fnode = instantiateTNodeName(tmap, set2array(named)[0], subtypes);
				unifyTNodeNameWithSuper(tmap, fnode, node);
				fnode;
			} else if (nnamed < length(subtypes)) {	// This condition is a bit arbitrary
				// Make an overload out of the rest
				overloads = map(set2array(named), \n -> {
					instantiateTNodeName(tmap, n, subtypes)
				});
				overload = TNodeOverload(uniques, overloads);
				println("TODO: Supertype " + prettyTNode(tmap, node) + " becomes " + prettyTNode(tmap, overload));
				overload;
			} else {
				if (length(subtypes) > 1) {
					println("TODO: Check if we can unify intra-supers " + prettyTNode(tmap, node));
				}
				node;
			}
		}
	}
}

// We know we want a given name, and we have a set of candidates to pick from
instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName]) -> TNodeName {
	node = filter(nodes, \n -> n.name == name);	
	if (length(node) > 0) {
		node[0];
	} else {
		munion = tmap.resolveUnionName(name);
		switch (munion) {
			None(): {
				typars = if (name == "array" || name == "ref") 1 else 0;
				TNodeName(name, generate(0, typars, \__ -> makeTNodeClass(tmap)));
			}
			Some(union): {
				typars = map(union.typars, \tp -> makeTNodeClass(tmap));
				TNodeName(name, typars);
			}
		}
	}
}

// Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		printCallstack();
		TNodeName("", []);
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, map(typars, \tp -> findOrMakeTNodeClass(tmap, tp)));
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					map(args, \a -> 
						findOrMakeTNodeClass(tmap, a)
					),
					findOrMakeTNodeClass(tmap, returnType)
				)
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

findOrMakeTNodeClass(tmap : TMap, type : TType) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		// OK, make a node out of it
		node = makeTNode(tmap, type);
		// And see if we can find that node!
		sclass = findUnionMap(tmap.tmap, \i, val : TNode -> node == val, -1);

		if (sclass == -1) {
			// OK, could not find it. We need a new class
			nclass = makeTNodeClass(tmap);
			// println("Made e" + i2s(nclass) + " for " + prettyTType(type) + " as " + prettyTNode(tmap, node));
			setUnionMapValue(tmap.tmap, nclass, node);
			nclass;
		} else {
			// println("Found it as an existing node");
			sclass;
		}
	}
}

makeTNodeClass(tmap : TMap) -> int {
	nclass = ^(tmap.nextEClass);
	tmap.nextEClass := nclass + 1;
	nclass;
}

mergeTNodes(tmap : TMap, left : TNode, right : TNode) -> TNode {
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \ -> {
		println("ERROR: Merge " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left)
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					if (lname != rname) {
						todo()
					} else if (length(ltypars) != length(rtypars)) {
						error();
					} else {
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							joinTNodes(tmap, lt, rtypars[i]);
						})))
					}
				}
				TNodeOverload(unique, overloads): {
					todo();
				}
				TNodeSupertype(unique, subtypes): {
					unifyTNodeNameWithSuper(tmap, left, right);
					left;
				}
			}
		}
		TNodeOverload(lunique, loverloads): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error();
					} else if (length(overloads) == 1) {
						// TODO: Unify the typars
						winner = overloads[0];
						mergeTNodes(tmap, winner, right);
//(())						println("TODO: Unify typars for unique " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right) + " for result " + prettyTNode(tmap, overloads[0]));
//						overloads[0];
					} else {
						noverload = TNodeOverload(lunique, overloads);
						println("TODO: Unify typars for " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, noverload));
						left;
					}
				}
				TNodeOverload(unique, overloads): {
					println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
					left;
				}
				TNodeSupertype(uniques, subtypes): {
					todo();
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Check that this name is a supertype
					// of all subtypes
					unifyTNodeNameWithSuper(tmap, right, left);
					right;
				}
				TNodeOverload(runique, roverloads): {
					todo();
				}
				TNodeSupertype(runique, rsubtypes): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes)
					));
				}
			}
		}
	}
}

unifyTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype) -> void {
	munion = tmap.resolveUnionName(node.name);
	found = ref false;
	iter(super.subtypes, \st -> {
		if (st.name == node.name) {
			// OK, the same
			if (length(st.typars) == length(node.typars)) {
				found := true;
				iteri(st.typars, \i, tp -> {
					joinTNodes(tmap, tp, node.typars[i]);
					{}
				})
			} else {
				println("ERROR: Join typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, super));
			}
		} else {
			// OK, we know that the node has to a supertype of st
			switch (munion) {
				None(): {
					println("TODO: Join typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, st));
				}
				Some(union): {
					stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == st.name);
					stype ?? {
						found := true;
						// OK, we have the relation from the union to the struct in this union
						unifyTNodeNameAgainstStruct(tmap, node, st, union, stype);
					} : {
						println("ERROR: Join typars of " + prettyTNode(tmap, node) + " impossible against " + prettyTNode(tmap, super));
					}
				}
			}
		}
	});

	if (!^found) {
		println("ERROR: Join " + prettyTNode(tmap, node) + " impossible against " + prettyTNode(tmap, super));
	}
}

unifyTNodeNameAgainstStruct(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> void {
	if (length(unionNode.typars) == length(unionDef.typars)) {
		// OK, map from the typar to the eclass it is bound to
		typars : Tree<string, int> = foldi(unionDef.typars, makeTree(), \i, acc, tp : DTypePar -> {
			setTree(acc, tp.id, unionNode.typars[i]);
		});
		subtypes = map(subDef.typars, \tp -> {
			dtype2eclass(tmap, typars, tp)
		});
		iteri(subtypes, \i, tp -> {
			if (tp != -1) {
				joinTNodes(tmap, tp, unionNode.typars[i]);
				{}
			} else {
				println("ERROR: Could not match typars " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
			}
		{}
		});
	} else {
		println("ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
	}
}

dtype2eclass(tmap : TMap, typars : Tree<string, int>, d : DType) -> int {
	todo = \ -> {
		println("TODO: Convert " + toString(d) + " to eclass");
		-1;
	}
	switch (d) {
		DTypePar(id, pos): lookupTreeDef(typars, id, -1);
		DTypeName(id, ttypars, pos): todo();
		DTypeFunction(args, returnType, pos): todo();
	}
}

joinTNodes(tmap : TMap, left : int, right : int) -> int {
	lnode = getUnionMapValue(tmap.tmap, left);
	rnode = getUnionMapValue(tmap.tmap, right);
	
	root = unionUnionMap(tmap.tmap, left, right);
	
	if (false) {
		println("  Joining e" + i2s(left) + " and e" + i2s(right) + " to e" + i2s(root) + ": " + debugTNode(tmap, root)
			+ " from " + prettyTNode(tmap, lnode) + " and " + prettyTNode(tmap, rnode));
	}

	if (findUnionMapRoot(tmap.tmap, root) != root) {
		println("ERROR: The root was changed under our feet!");
	}

	root;
}

// Are these node names incompatible forever?
incompatibleTNodeNames(tmap : TMap, node : TNodeName, overload : TNodeName) -> bool {
	if (isEmptyTNode(node) || isEmptyTNode(overload)) {
		false
	} else {
		node.name != overload.name 
		|| length(node.typars) != length(overload.typars)
		|| exists(mapi(node.typars, \i, tp -> {
			incompatibleEClasses(tmap, tp, overload.typars[i])
		}), idfn)
	}
}

isEmptyTNode(n : TNode) -> bool {
	switch (n) {
		TNodeName(name, pars): name == "" && pars == [];
		default: false;
	}
}

incompatibleEClasses(tmap : TMap, left : int, right : int) -> bool {
	lroot = findUnionMapRoot(tmap.tmap, left);
	rroot = findUnionMapRoot(tmap.tmap, right);
	lroot != rroot
	&& {
		lnode = getUnionMapValue(tmap.tmap, lroot);
		rnode = getUnionMapValue(tmap.tmap, rroot);
		incompatibleTNodes(tmap, lnode, rnode);
	}
}

incompatibleTNodes(tmap : TMap, left : TNode, right : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if node " + prettyTNode(tmap, left) + " is compatible with node " + prettyTNode(tmap, right));
		false;
	}
	if (isEmptyTNode(left) || isEmptyTNode(right)) false
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					incompatibleTNodeNames(tmap, left, right)
				}
				default: todo();
			}
		}
		TNodeOverload(lunique, loverloads): {
			todo();
		}
		TNodeSupertype(luniques, lsubtypes): {
			todo();
		}
	}
}

findTNode(tmap : TMap, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tmap.tmap, eclass);
		}
		default: {
			findUnionMap(tmap.tmap, \i, val : TNode -> {
				c = isTTypeInTNode(tmap, type, i, val);
				if (false && c) {
					println("e" + i2s(i) + " has " + prettyTType(type));
				}
				c;
			}, -1);
		}
	}
}

isTTypeInTNode(tmap : TMap, t : TType, nclass : int, n : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if type " + prettyTType(t) + " is node " + prettyTNode(tmap, n));
		false;
	}
	isSameEClass = \ec -> {
		findUnionMapRoot(tmap.tmap, ec) == findUnionMapRoot(tmap.tmap, nclass)
	}
	switch (n) {
		TNodeName(name, typars): {
			switch (t) {
				TTypeName(id, ttypars): {
					if (id == name) areTTypesInTNodes(tmap, ttypars, typars) else false;
				}
				TTypeFunction(args, returnType): {
					if (name == "" && length(typars) == length(args) + 1) {
						areTTypesInTNodes(tmap, args, subrange(typars, 0, length(args)))
						&& areTTypesInTNodes(tmap, [returnType], [typars[length(args)]])
					} else {
						false;
					}
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				TTypeOverload(unique, overloads): false;
				TTypeSupertype(unique, subtypes, maxed): false;
			}
		}
		TNodeOverload(uniques, overloads): {
			switch (t) {
				TTypeOverload(tunique, __): {
					uid = findTNode(tmap, tunique);
					containsSet(uniques, uid);
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
		TNodeSupertype(uniques, subtypes): {
			switch (t) {
				TTypeSupertype(uid, __, maxed): containsSet(uniques, uid);
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
	}
}

areTTypesInTNodes(tmap : TMap, ts : [TType], ns : [int]) -> bool {
	length(ts) == length(ns)
	&& forall(mapi(ts, \i, t -> {
		eclass = ns[i];
		node = getUnionMapValue(tmap.tmap, eclass);
		isTTypeInTNode(tmap, t, eclass, node)
	}), idfn)
}

prettyTNode(tmap : TMap, t : TNode) -> string {
	switch (t) {
		TNodeName(name, typars): {
			if (name == "") {
				if (typars == []) "ε"
				else {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					"(" + superglue(args, \e -> prettyEClass(tmap, e), ", ") + ")"
					+ "->" + prettyEClass(tmap, rt)
				}
			} else {
				name
				+ (if (typars != []) "<" + superglue(typars, \e -> prettyEClass(tmap, e), ",") + ">" else "");
			}
		}
		TNodeOverload(uniques, overloads): {
			"overload" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(overloads, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
		TNodeSupertype(uniques, subtypes): {
			"super" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(subtypes, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
	}
}

prettyEClass(tmap : TMap, eclass : int) -> string {
	node = getUnionMapValue(tmap.tmap, eclass);
	if (isEmptyTNode(node)) "e" + i2s(eclass)
	else prettyTNode(tmap, node)
}

debugTNode(tmap : TMap, root : int) -> string {
	node = getUnionMapValue(tmap.tmap, root);

	childClasses = foldRange(0, ^(tmap.nextEClass), [], \acc2, ec -> {
		r = findUnionMapRoot(tmap.tmap, ec);
		if (r == root) {
			arrayPush(acc2, ec)
		} else acc2;
	});

	rpad(prettyTNode(tmap, node), " ", 30) + "   covers " + superglue(childClasses, \c -> "e" + i2s(c), " ");
}

getTNodes(tmap : TMap) -> Set<int> {
	aroots = getUnionMapRoots(tmap.tmap);
	filterSet(aroots, \r -> {
		r < ^(tmap.nextEClass)
	});
}

// At the end, extract the types

resolveTNodes(tmap : TMap) -> Tree<int, TType> {
	roots = getTNodes(tmap);
	types = ref makeTree();
	visited = ref makeSet();

	iterSet(roots, \root -> {
		node = getUnionMapValue(tmap.tmap, root);
		if (!isEmptyTNode(node)) {
			t = resolveTNode(tmap, types, visited, root);
			println("e" + i2s(root) + " = " + rpad(prettyTType(t), " ", 30) + "   from " + debugTNode(tmap, root));
		}
	});

	^types
}

resolveTNode(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	set = \tt -> {
		acc := setTree(^acc, eclass, tt);
		tt;
	}
	if (containsSet(^visited, eclass)) {
		mkClass(eclass)
	} else {
		visited := insertSet(^visited, eclass);
		node = getUnionMapValue(tmap.tmap, eclass);
		switch (node) {
			TNodeName(name, typars): {
				if (name == "" && typars == []) {
					mkClass(eclass)
				} else if (name == "") {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					set(TTypeFunction(
						map(args, \a -> {
							resolveTNode(tmap, acc, visited, a)
						}),
						resolveTNode(tmap, acc, visited, rt)
					))
				} else {
					set(TTypeName(name, map(typars, \tp -> {
						resolveTNode(tmap, acc, visited, tp)
					})))
				}
			}
			TNodeOverload(unique, overloads): {
				println("TODO: Resolve overload: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
			TNodeSupertype(unique, subtypes): {
				println("TODO: Resolve supertype: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
	}
}
