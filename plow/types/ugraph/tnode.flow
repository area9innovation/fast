import plow/types/ugraph/type;
import plow/types/pretty;

/*
TODO:
- Review positions. They are wrong when reporting a problem in array.flow filtermap.
- ? vs ?? in flowstructs
- isSameStructType
- (downcast in filtermap)
- Handle unions with sub-unions:
  C:/fast/plow/pexp/values.flow:26:13: ERROR: Unknown subtype PExp from super1{PBool}

*/

export {
	// Set up the type unification map
	makeTMap(
		onError : (int, string) -> void, 
		nextEClass : ref int
	) -> TMap;

	// Define the resolvers we need
	setTMapResolvers(t : TMap, 
		resolveUnionName : (string) -> Maybe<DUnion>,
		resolveSupertypes : (string) -> [string], 
	) -> TMap;

	// Make a new type class
	makeTNodeClass(tmap : TMap) -> int;

	// Unify these two types
	unifyTNodes(tmap : TMap, left : TType, right : TType, 
		verbose : bool, reason : string, pos : int) -> void;

	// At the end, extract the types for each type class
	resolveTNodes(tmap : TMap, verbose : bool) -> Tree<int, TType>;
}

makeTMap(onError : (int, string) -> void, nextEClass : ref int) -> TMap {
	self = ref None();
	tmap = TMap(
		makeUnionFindMap(defaultTNode(), \l, r -> {
			switch (^self) {
				None(): {
					println("NOT SUPPOSED TO HAPPEN");
					l;
				}
				Some(s): mergeTNodes(s, l, r);
			}
		}),
		ref \__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		onError,
		nextEClass,
	);
	self := Some(tmap);
	tmap;
}

setTMapResolvers(t : TMap, 
	resolveUnionName : (string) -> Maybe<DUnion>,
	resolveSupertypes : (string) -> [string], 
) -> TMap {
	t.resolveUnionName := resolveUnionName;
	t.resolveSupertypes := \type -> {
		transitiveResolveSuperType(resolveSupertypes, type)
	};
	t;
}

transitiveResolveSuperType(basic : (string) -> [string], name : string) -> [string] {
	supers = basic(name);
	fold(supers, supers, \acc, base -> {
		concat(acc, transitiveResolveSuperType(basic, base))
	})
}

defaultTNode() -> TNode {
	TNodeName("", [], -1);
}

// These two types are unified
unifyTNodes(tmap : TMap, left : TType, right : TType, verbose: bool,
		reason : string, pos : int) -> void {
	lclass = findOrMakeTNodeClass(tmap, left, pos);
	rclass = findOrMakeTNodeClass(tmap, right, pos);
	if (verbose) {
		println("Unify " + rpad(prettyTType(left) + " and " + prettyTType(right), " ", 60) + " " + i2s(lclass) + " vs " + i2s(rclass) + " | " + reason );
		// println("  " + debugTNode(tmap, lclass));
		// println("  " + debugTNode(tmap, rclass));
	}
	if (lclass != -1 && rclass != -1) {
		// println("  Union e" + i2s(lclass) + " and e" + i2s(rclass));
		root = unionUnionMap(tmap.tmap, lclass, rclass);
		
		// println("  to e" + i2s(root) + " =  " + debugTNode(tmap, root));
		{}
	} else {
		println("Not supposed to happen: " + prettyTType(left) + " and " + prettyTType(right));
	}
}

findOrMakeTNodeClass(tmap : TMap, type : TType, pos : int) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		// OK, make a node out of it
		node = makeTNode(tmap, type, pos);
		findOrMakeTNode(tmap, node);
	}
}

findOrMakeTNode(tmap : TMap, node : TNode) -> int {
	// And see if we can find that node!
	sclass = findUnionMap(tmap.tmap, \i, val : TNode -> isSameTNode(tmap, node, val), -1);

	if (sclass == -1) {
		// OK, could not find it. We need a new class
		nclass = makeTNodeClass(tmap);
		// println("Made e" + i2s(nclass) + " as " + prettyTNode(tmap, node));
		setUnionMapValue(tmap.tmap, nclass, node);
		nclass;
	} else {
		// println("Found it as an existing node");
		sclass;
	}
}

makeTNodeClass(tmap : TMap) -> int {
	nclass = ^(tmap.nextEClass);
	tmap.nextEClass := nclass + 1;
	nclass;
}

isSameTNode(tmap : TMap, left : TNode, right : TNode) -> bool {
	left == right
	|| switch (left) {
		TNodeName(lname, ltypars, __): {
			switch (right) {
				TNodeName(rname, rtypars, __): {
					lname == rname 
					&& length(ltypars) == length(rtypars)
					&& forall(mapi(ltypars, \i, tp -> {
						findUnionMapRoot(tmap.tmap, tp)
						== findUnionMapRoot(tmap.tmap, rtypars[i])
					}), idfn)
				}
				default: false;
			}
		}
		TNodeOverload(uniques, overloads, __): {
			switch (right) {
				TNodeOverload(runiques, __, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
		TNodeSupertype(uniques, __, __, __): {
			switch (right) {
				TNodeSupertype(runiques, __, __, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
	}
}

makeTNode(tmap : TMap, t : TType, pos : int) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", [], pos);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t, pos);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t, pos);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st, pos)),
				pos
			))
		}
		TTypeSupertype(unique, subtypes, maxed): {
			emptySuper = TNodeSupertype(makeSet1(unique), [], makeSet(), pos);
			super = fold(subtypes, emptySuper, \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, super);
		}
	}
}

extractSupers(tmap : TMap, acc : TNodeSupertype, t : TType) -> TNodeSupertype {
	todo = \ -> {
		println("TODO: Figure out how to represent this as a named node in a super: " + prettyTType(t));
		acc;
	}
	addName = \n : TNodeName -> {
		TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, n));
	}
	addEClass = \e : int -> {
		TNodeSupertype(acc with unknownSubtypes = insertSet(acc.unknownSubtypes, e));
	}
	switch (t) {
		TTypeSupertype(__, sub, __): {
			fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars, __): {
					if (isEmptyTNode(node)) {
						addEClass(eclass);
					} else {
						addName(node);
					}
				}
				TNodeOverload(unique, overloads, __): todo();
				TNodeSupertype(uniques, subtypes, usub, pos): {
					TNodeSupertype(acc with
						subtypes = concat(acc.subtypes, subtypes),
						unknownSubtypes = mergeSets(acc.unknownSubtypes, usub),
					);
				}
			}
		}
		TTypeName(__, __): {
			addName(makeTNodeName(tmap, t, acc.pos));
		}
		TTypeFunction(args, returnType): {
			addName(makeTNodeName(tmap, t, acc.pos));
		}
		TTypeOverload(unique, overloads): todo();
	}
}

// Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType, pos : int) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		TNodeName("", [], pos);
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, map(typars, \tp -> findOrMakeTNodeClass(tmap, tp, pos)), pos);
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					map(args, \a -> 
						findOrMakeTNodeClass(tmap, a, pos)
					),
					findOrMakeTNodeClass(tmap, returnType, pos)
				), pos
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

// Given a node, simplify overload and supertypes as much as possible.
// - If overloads are unique, pick the one it is
// - If a supertype has unknown subtypes, see if
//   any are known
// - If a supertype has all subtypes known, find the potential
//   supers

simplifyTNode(tmap : TMap, node : TNode) -> TNode {
	switch (node) {
		TNodeName(name, typars, __): node;
		TNodeOverload(unique, overloads, __): {
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				// TODO: Doubt anything else is possible here?
				node;
			}
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes, pos): {
			if (!isEmptySet(unknownSubtypes)) {
				resolved = foldSet(unknownSubtypes, Pair([], makeSet()), 
						\acc : Pair<[TNodeName], Set<int>>, st : int -> {
					unode = getUnionMapValue(tmap.tmap, st);
					unknown = \ -> {
						Pair(acc.first, insertSet(acc.second, st));
					}
					switch (unode) {
						TNodeName(name, typars, __): {
							if (isEmptyTNode(unode)) {
								unknown();
							} else {
								Pair(arrayPush(acc.first, unode), acc.second)
							}
						}
						default: unknown();
					}
				});
				if (resolved.first != []) {
					cleaned = TNodeSupertype(uniques, concat(subtypes, resolved.first), resolved.second, pos);
					// println("Cleaned unknown " + prettyTNode(tmap, cleaned));
					simplifyTNode(tmap, cleaned);
				} else {
					node;
				}
			} else {
				// OK, we can calculate potential super types here
				// and reduce them to an overload or a given type
				named = foldi(subtypes, makeSet(), \i, acc, t : TNodeName -> {
					id = t.name;
					supers0 = ^(tmap.resolveSupertypes)(id);
					println(id + " gives " + toString(supers0));
					supers = arrayPush(supers0, id);
					supset = buildSet(supers);
					if (i == 0) supset
					else intersectSets(supset, acc)
				});

				nnamed = sizeSet(named);

				// Here we have the names that are possible
				if (nnamed == 1) {
					fnode = instantiateTNodeName(tmap, set2array(named)[0], subtypes, pos);
					unifyTNodeNameWithSuper(tmap, fnode, node);
				} else if (false && nnamed != 0 && nnamed < length(subtypes)) {	// This condition is a bit arbitrary
					// Make an overload out of the rest
					overloads = map(set2array(named), \n -> {
						instantiateTNodeName(tmap, n, subtypes, pos)
					});
					overload = TNodeOverload(uniques, overloads, pos);
					println("TODO: Supertype " + prettyTNode(tmap, node) + " becomes " + prettyTNode(tmap, overload));
					overload;
				} else {
					// Remove duplicates
					uni = fold(subtypes, [], \acc, st -> {
						if (exists(acc, \tt -> isSameTNode(tmap, st, tt))) acc
						else arrayPush(acc, st);
					});
					if (length(uni) > 1 && exists(uni, \st -> {
						st.typars != []
					})) {
						println("TODO: Check if we can unify intra-supers " + prettyTNode(tmap, node));
					}
					TNodeSupertype(uniques, uni, unknownSubtypes, pos);
				}
			}
		}
	}
}

// We know we want a given name, and we have a set of candidates to pick from
instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName], pos : int) -> TNodeName {
	node = filter(nodes, \n -> n.name == name);	
	if (length(node) > 0) {
		node[0];
	} else {
		munion = ^(tmap.resolveUnionName)(name);
		switch (munion) {
			None(): {
				typars = if (name == "array" || name == "ref") 1 else 0;
				TNodeName(name, generate(0, typars, \__ -> makeTNodeClass(tmap)), pos);
			}
			Some(union): {
				typars = map(union.typars, \tp -> makeTNodeClass(tmap));
				TNodeName(name, typars, pos);
			}
		}
	}
}

//
// The pure unification
//

mergeTNodes(tmap : TMap, left : TNode, right : TNode) -> TNode {
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \pos -> {
		tmap.onError(pos, "ERROR: Merge " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left)
	else if (isSameTNode(tmap, left, right)) left
	else switch (left) {
		TNodeName(lname, ltypars, pos): {
			switch (right) {
				TNodeName(rname, rtypars, rpos): {
					if (lname != rname) {
						if (lname == "flow") {
							right
						} else if (rname == "flow") {
							left
						} else if (isSingleUnionName(tmap, lname, rname)) {
							// As a special case, if one of these
							// is a singleton union with the other element,
							// it is ok
							left;
						} else {
							error(max(pos, rpos));
							left;
						}
					} else if (length(ltypars) != length(rtypars)) {
						error(max(pos, rpos));
					} else {
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							joinTNodes(tmap, lt, rtypars[i]);
						}), pos))
					}
				}
				TNodeOverload(unique, overloads, __): {
					mergeTNodes(tmap, right, left);
				}
				TNodeSupertype(unique, subtypes, __, __): {
					unifyTNodeNameWithSuper(tmap, left, right);
				}
			}
		}
		TNodeOverload(lunique, loverloads, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error(max(lpos, pos));
					} else if (length(overloads) == 1) {
						winner = overloads[0];
						mergeTNodes(tmap, winner, right);
					} else {
						noverload = TNodeOverload(lunique, overloads, pos);
						// TODO: It could be that we are throwing away information.
						// Maybe we should record the right hand side inside the
						// overload
						if (false) {
							println("Potential information loss: Unify typars for " + prettyTNode(tmap, right) + " and " + prettyTNode(tmap, noverload));
						}
						// println("From " + prettyTNode(tmap, left));
						right;
					}
				}
				TNodeOverload(unique, overloads, pos): {
					println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
					left;
				}
				TNodeSupertype(uniques, subtypes, usub, pos): {
					todo();
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes, lusub, lpos): {
			switch (right) {
				TNodeName(name, typars, pos): {
					unifyTNodeNameWithSuper(tmap, right, left);
				}
				TNodeOverload(runique, roverloads, pos): {
					todo();
				}
				TNodeSupertype(runique, rsubtypes, rusub, pos): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes),
						mergeSets(lusub, rusub),
						max(pos, lpos)
					));
				}
			}
		}
	}
}

// It could be that we have a union with just one struct
isSingleUnionName(tmap : TMap, name1 : string, name2 : string) -> bool {
	// Are these names compatible
	muname1 = ^(tmap.resolveUnionName)(name1);
	switch (muname1) {
		None(): {
			muname2 = ^(tmap.resolveUnionName)(name2);
			switch (muname1) {
				None(): false;
				Some(u): {
					if (length(u.types) == 1) {
						u.types[0].id == name1
					} else false;
				}
			}
		}
		Some(u): {
			if (length(u.types) == 1) {
				u.types[0].id == name2
			} else false;
		}
	}
}

// OK, we have a named type against a super.
unifyTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype) -> TNode {
	// println("Unifying " + prettyTNode(tmap, node) + " vs " + prettyTNode(tmap, super));
	found = ref false;
	iter(super.subtypes, \st -> {
		found := unifyTNodeNameWithSubtype(tmap, node, st) || ^found;
	});

	if (!isEmptySet(super.unknownSubtypes)) {
		eclass = findOrMakeTNode(tmap, node);
		iterSet(super.unknownSubtypes, \st -> {
			joinTNodes(tmap, eclass, st);
			found := true;
		});
	}

	if (!^found) {
		tmap.onError(node.pos, "TODO: Join " + prettyTNode(tmap, node) + " not complete against " + prettyTNode(tmap, super));
	}

	node;
}

// Try to unify this super type against a subtype. Return true if successful
unifyTNodeNameWithSubtype(tmap : TMap, node : TNodeName, subtype : TNodeName) -> bool {
	if (subtype.name == node.name) {
		// OK, the same name, just go
		if (length(subtype.typars) == length(node.typars)) {
			iteri(subtype.typars, \i, tp -> {
				joinTNodes(tmap, tp, node.typars[i]);
				{}
			});
			true;
		} else {
			tmap.onError(node.pos, "ERROR: Mismatch typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype));
			false;
		}
	} else {
		// OK, we know that the node has to a supertype of st
		munion = ^(tmap.resolveUnionName)(node.name);
		switch (munion) {
			None(): {
				tmap.onError(node.pos, "Expected union " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, subtype));
				false;
			}
			Some(union): {
				stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == subtype.name);
				stype ?? {
					// OK, we have the relation from the union to the struct in this union
					unifyTNodeNameAgainstSubtype(tmap, node, subtype, union, stype);
					true;
				} : {
					// TODO. Let us check each of the subtypes and see if they have our guy as a
					// subtype!
					tmap.onError(node.pos, "ERROR: Unknown subtype " + prettyTNode(tmap, node) + " from " + prettyTNode(tmap, subtype));
					false;
				}
			}
		}
	}
}

// OK, we have a union on the left hand side, and a subtype on the right hand side
// We have to figure out how those typars relate to each other.
// Thus, we have unionDef and the corresponding typename instantiation
unifyTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> void {
	msubInstantiated : Maybe<TNodeName>= instantiateTNodeNameAgainstSubtype(tmap, unionNode, subNode, 
		unionDef, subDef);
	msubInstantiated ?? {
		subtypes = msubInstantiated.typars;
		// println("    " + prettyTNode(tmap, subInstantiated) + " vs " + prettyTNode(tmap, subNode));
		if (length(subtypes) == length(subNode.typars)) {
			iteri(subtypes, \i, tp -> {
				if (tp != -1) {
					joinTNodes(tmap, tp, subNode.typars[i]);
					{}
				} else {
					tmap.onError(unionNode.pos, "ERROR: Could not match typars " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
				}
			{}
			});
		} else {
			tmap.onError(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
		}
	} : {
		tmap.onError(unionNode.pos, "ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
	}
}

// Instantiates a typename that we know is in the union
instantiateTNodeNameAgainstSubtype(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> Maybe<TNodeName> {
	// println("  Node " + prettyTNode(tmap, unionNode) + " vs " + prettyTNode(tmap, subNode));
	if (length(unionNode.typars) == length(unionDef.typars)) {
		// OK, map from the typar to the eclass it is bound to
		typars : Tree<string, int> = foldi(unionDef.typars, makeTree(), \i, acc, tp : DTypePar -> {
			setTree(acc, tp.id, unionNode.typars[i]);
		});

		// Consider
		// Maybe<?> ::= None, Some<?>
		// If we are in the None, case, notice we have one too little typars
		sdtype : DTypeName = if (length(subDef.typars) == 0) {
			// So we implicitly extend it when there are none
			DTypeName(subDef with typars = unionDef.typars)
		} else subDef;
		subtypes = map(sdtype.typars, \tp -> {
			dtype2eclass(tmap, typars, tp)
		});
		// OK, instantiate the struct from the union typars
		subInstantiated = TNodeName(subNode.name, subtypes, subNode.pos);
		Some(subInstantiated)
	} else {
		None();
	}	
}


dtype2eclass(tmap : TMap, typars : Tree<string, int>, d : DType) -> int {
	todo = \ -> {
		println("TODO: Convert " + toString(d) + " to eclass");
		-1;
	}
	switch (d) {
		DTypePar(id, pos): lookupTreeDef(typars, id, -1);
		DTypeName(id, ttypars, pos): todo();
		DTypeFunction(args, returnType, pos): todo();
	}
}

joinTNodes(tmap : TMap, left : int, right : int) -> int {
	root = unionUnionMap(tmap.tmap, left, right);
	
	if (false) {
		lnode = getUnionMapValue(tmap.tmap, left);
		rnode = getUnionMapValue(tmap.tmap, right);
		
		println("  Joining e" + i2s(left) + " and e" + i2s(right) + " to e" + i2s(root) + ": " + debugTNode(tmap, root)
			+ " from " + prettyTNode(tmap, lnode) + " and " + prettyTNode(tmap, rnode));
	}

	findUnionMapRoot(tmap.tmap, root);
}

// Are these node names incompatible forever?
incompatibleTNodeNames(tmap : TMap, node : TNodeName, overload : TNodeName) -> bool {
	if (isEmptyTNode(node) || isEmptyTNode(overload)) {
		false
	} else if (node.name == "flow" || overload.name == "flow") {
		// This is always ok
		false
	} else if (isSingleUnionName(tmap, node.name, overload.name)) {
		false
	} else {
		node.name != overload.name 
		|| length(node.typars) != length(overload.typars)
		|| exists(mapi(node.typars, \i, tp -> {
			incompatibleEClasses(tmap, tp, overload.typars[i])
		}), idfn)
	}
}

isEmptyTNode(n : TNode) -> bool {
	switch (n) {
		TNodeName(name, pars, pos): name == "" && pars == [];
		default: false;
	}
}

incompatibleEClasses(tmap : TMap, left : int, right : int) -> bool {
	lroot = findUnionMapRoot(tmap.tmap, left);
	rroot = findUnionMapRoot(tmap.tmap, right);
	lroot != rroot
	&& {
		lnode = getUnionMapValue(tmap.tmap, lroot);
		rnode = getUnionMapValue(tmap.tmap, rroot);
		incompatibleTNodes(tmap, lnode, rnode);
	}
}

incompatibleTNodes(tmap : TMap, left : TNode, right : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if node " + prettyTNode(tmap, left) + " is compatible with node " + prettyTNode(tmap, right));
		false;
	}
	if (isEmptyTNode(left) || isEmptyTNode(right)) false
	else switch (left) {
		TNodeName(lname, ltypars, lpos): {
			switch (right) {
				TNodeName(rname, rtypars, rpos): {
					incompatibleTNodeNames(tmap, left, right)
				}
				default: incompatibleTNodes(tmap, right, left);
			}
		}
		TNodeOverload(lunique, loverloads, pos): {
			todo();
		}
		TNodeSupertype(luniques, lsubtypes, usubs, pos): {
			if (existsSet(usubs, \s -> {
				isEmptyEClass(tmap, s);
			})) {
				// OK, we have some unknown subtypes, so it can be anything
				false
			} else {
				switch (right) {
					TNodeName(rname, rtypars, rpos): {
						println("TODO 2: Check if node " + prettyTNode(tmap, left) + " is compatible with node " + prettyTNode(tmap, right));
						false;
					}
					default: {
						todo();
					}
				}
			}
		}
	}
}

isEmptyEClass(tmap : TMap, eclass : int) -> bool {
	node = getUnionMapValue(tmap.tmap, eclass);
	isEmptyTNode(node);
}

findTNode(tmap : TMap, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tmap.tmap, eclass);
		}
		default: {
			findUnionMap(tmap.tmap, \i, val : TNode -> {
				c = isTTypeInTNode(tmap, type, i, val);
				if (false && c) {
					println("  e" + i2s(i) + " has " + prettyTType(type));
				}
				c;
			}, -1);
		}
	}
}

isTTypeInTNode(tmap : TMap, t : TType, nclass : int, n : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if type " + prettyTType(t) + " is node " + prettyTNode(tmap, n));
		false;
	}
	isSameEClass = \ec -> {
		findUnionMapRoot(tmap.tmap, ec) == findUnionMapRoot(tmap.tmap, nclass)
	}
	switch (n) {
		TNodeName(name, typars, pos): {
			switch (t) {
				TTypeName(id, ttypars): {
					if (id == name) areTTypesInTNodes(tmap, ttypars, typars) else false;
				}
				TTypeFunction(args, returnType): {
					if (name == "" && length(typars) == length(args) + 1) {
						areTTypesInTNodes(tmap, args, subrange(typars, 0, length(args)))
						&& areTTypesInTNodes(tmap, [returnType], [typars[length(args)]])
					} else {
						false;
					}
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				TTypeOverload(unique, overloads): false;
				TTypeSupertype(unique, subtypes, maxed): false;
			}
		}
		TNodeOverload(uniques, overloads, pos): {
			switch (t) {
				TTypeOverload(tunique, __): {
					uid = findTNode(tmap, tunique);
					containsSet(uniques, uid);
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
		TNodeSupertype(uniques, subtypes, __, pos): {
			switch (t) {
				TTypeSupertype(uid, __, maxed): containsSet(uniques, uid);
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
	}
}

areTTypesInTNodes(tmap : TMap, ts : [TType], ns : [int]) -> bool {
	length(ts) == length(ns)
	&& forall(mapi(ts, \i, t -> {
		eclass = ns[i];
		node = getUnionMapValue(tmap.tmap, eclass);
		isTTypeInTNode(tmap, t, eclass, node)
	}), idfn)
}

prettyTNode(tmap : TMap, t : TNode) -> string {
	switch (t) {
		TNodeName(name, typars, pos): {
			if (name == "") {
				if (typars == []) "ε"
				else {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					"(" + superglue(args, \e -> prettyEClass(tmap, e), ", ") + ")"
					+ "->" + prettyEClass(tmap, rt)
				}
			} else {
				name
				+ (if (typars != []) "<" + superglue(typars, \e -> prettyEClass(tmap, e), ",") + ">" else "");
			}
		}
		TNodeOverload(uniques, overloads, pos): {
			"overload" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(overloads, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
		TNodeSupertype(uniques, subtypes, usub, pos): {
			"super" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(subtypes, \o -> prettyTNode(tmap, o), ", ")
			+ (if (isEmptySet(usub)) "" else 
				superglue(set2array(usub), \st -> "e" + i2s(st), ", ")
			)
			+ "}"
			;
		}
	}
}

prettyEClass(tmap : TMap, eclass : int) -> string {
	node = getUnionMapValue(tmap.tmap, eclass);
	if (isEmptyTNode(node)) "e" + i2s(eclass)
	else prettyTNode(tmap, node)
}

debugTNode(tmap : TMap, root : int) -> string {
	node = getUnionMapValue(tmap.tmap, root);

	childClasses = foldRange(0, ^(tmap.nextEClass), [], \acc2, ec -> {
		r = findUnionMapRoot(tmap.tmap, ec);
		if (r == root) {
			arrayPush(acc2, ec)
		} else acc2;
	});

	rpad(prettyTNode(tmap, node), " ", 30) + "   covers " + superglue(childClasses, \c -> "e" + i2s(c), " ");
}

getTNodes(tmap : TMap) -> Set<int> {
	aroots = getUnionMapRoots(tmap.tmap);
	filterSet(aroots, \r -> {
		r < ^(tmap.nextEClass)
	});
}

// At the end, extract the types

resolveTNodes(tmap : TMap, verbose : bool) -> Tree<int, TType> {
	roots = getTNodes(tmap);
	types = ref makeTree();
	visited = ref makeSet();

	iterSet(roots, \root -> {
		node = getUnionMapValue(tmap.tmap, root);
		if (!isEmptyTNode(node)) {
			t = resolveTNodeClass(tmap, types, visited, root);
			if (verbose) {
				println("e" + i2s(root) + " = " + rpad(prettyTType(t), " ", 30) + "   from " + debugTNode(tmap, root));
			}
		}
	});

	^types
}

resolveTNodeClass(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	if (containsSet(^visited, eclass)) {
		mkClass(eclass)
	} else {
		visited := insertSet(^visited, eclass);
		node = getUnionMapValue(tmap.tmap, eclass);
		resolveTNode(tmap, acc, visited, eclass, node);
	}
}

resolveTNode(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int, node : TNode) {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	set = \tt -> {
		acc := setTree(^acc, eclass, tt);
		tt;
	}

	switch (node) {
		TNodeName(name, typars, pos): {
			if (name == "" && typars == []) {
				mkClass(eclass)
			} else if (name == "") {
				args = subrange(typars, 0, length(typars) - 1);
				rt = typars[length(typars) - 1];
				set(TTypeFunction(
					map(args, \a -> {
						resolveTNodeClass(tmap, acc, visited, a)
					}),
					resolveTNodeClass(tmap, acc, visited, rt)
				))
			} else {
				set(TTypeName(name, map(typars, \tp -> {
					resolveTNodeClass(tmap, acc, visited, tp)
				})))
			}
		}
		TNodeOverload(unique, overloads, pos): {
			if (length(overloads) > 0) {
				if (length(overloads) != 1) {
					println("TODO: Picking random overload: " + prettyTNode(tmap, node));
				}
				resolveTNode(tmap, acc, visited, eclass, overloads[0]);
			} else {
				println("TODO: Resolve overload: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
		TNodeSupertype(unique, subtypes, __, pos): {
			simpler = simplifyTNode(tmap, node);
			if (simpler != node) {
				resolveTNode(tmap, acc, visited, eclass, simpler);
			} else if (subtypes != []) {
				if (length(subtypes) != 1) {
					println("TODO: Picking random supertype: " + prettyTNode(tmap, node));
				}
				resolveTNode(tmap, acc, visited, eclass, subtypes[0]);
			} else {
				tmap.onError(pos, "Could not resolve supertype: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
	}
}