import plow/types/ugraph/type;
import plow/types/pretty;

export {
	makeTMap(
		onError : (int, string) -> void, 
		nextEClass : ref int
	) -> TMap;

	setTMapResolvers(t : TMap, 
		resolveUnionName : (string) -> Maybe<DUnion>,
		resolveSupertypes : (string) -> [string], 
	) -> TMap;

	unifyTNodes(tmap : TMap, left : TType, right : TType, reason : string, pos : int) -> void;

	resolveTNodes(tmap : TMap) -> Tree<int, TType>;
}

makeTMap(onError : (int, string) -> void, nextEClass : ref int) -> TMap {
	self = ref None();
	tmap = TMap(
		makeUnionFindMap(defaultTNode(), \l, r -> {
			switch (^self) {
				None(): {
					println("NOT SUPPOSED TO HAPPEN");
					l;
				}
				Some(s): mergeTNodes(s, l, r);
			}
		}),
		ref \__ -> {
			println("TODO: The resolvers are not set");
			None();
		},
		ref \__ -> {
			println("TODO: The resolvers are not set");
			[];
		},
		onError,
		nextEClass,
	);
	self := Some(tmap);
	tmap;
}

setTMapResolvers(t : TMap, 
	resolveUnionName : (string) -> Maybe<DUnion>,
	resolveSupertypes : (string) -> [string], 
) -> TMap {
	t.resolveUnionName := resolveUnionName;
	t.resolveSupertypes := resolveSupertypes;
	t;
}

defaultTNode() -> TNode {
	TNodeName("", []);
}

// These two types are unified
unifyTNodes(tmap : TMap, left : TType, right : TType, reason : string, pos : int) -> void {
	lclass = findOrMakeTNodeClass(tmap, left);
	rclass = findOrMakeTNodeClass(tmap, right);
	// println("Unify " + rpad(prettyTType(left) + " and " + prettyTType(right), " ", 60) + i2s(lclass) + " vs " + i2s(rclass) + " | " + reason );
	// println("  " + debugTNode(tmap, lclass));
	// println("  " + debugTNode(tmap, rclass));
	if (lclass != -1 && rclass != -1) {
		// println("  Union e" + i2s(lclass) + " and e" + i2s(rclass));
		root = unionUnionMap(tmap.tmap, lclass, rclass);
		
		// println("  to e" + i2s(root) + " =  " + debugTNode(tmap, root));
		{}
	} else {
		println("Not supposed to happen: " + prettyTType(left) + " and " + prettyTType(right));
	}
}

findOrMakeTNodeClass(tmap : TMap, type : TType) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		// OK, make a node out of it
		node = makeTNode(tmap, type);
		findOrMakeTNode(tmap, node);
	}
}

findOrMakeTNode(tmap : TMap, node : TNode) -> int {
	// And see if we can find that node!
	sclass = findUnionMap(tmap.tmap, \i, val : TNode -> isSameTNode(tmap, node, val), -1);

	if (sclass == -1) {
		// OK, could not find it. We need a new class
		nclass = makeTNodeClass(tmap);
		// println("Made e" + i2s(nclass) + " as " + prettyTNode(tmap, node));
		setUnionMapValue(tmap.tmap, nclass, node);
		nclass;
	} else {
		// println("Found it as an existing node");
		sclass;
	}
}

makeTNodeClass(tmap : TMap) -> int {
	nclass = ^(tmap.nextEClass);
	tmap.nextEClass := nclass + 1;
	nclass;
}

isSameTNode(tmap : TMap, left : TNode, right : TNode) -> bool {
	left == right
	|| switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					lname == rname 
					&& length(ltypars) == length(rtypars)
					&& forall(mapi(ltypars, \i, tp -> {
						findUnionMapRoot(tmap.tmap, tp)
						== findUnionMapRoot(tmap.tmap, rtypars[i])
					}), idfn)
				}
				default: false;
			}
		}
		TNodeOverload(uniques, overloads): {
			switch (right) {
				TNodeOverload(runiques, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
		TNodeSupertype(uniques, __, __): {
			switch (right) {
				TNodeSupertype(runiques, __, __): !isEmptySet(intersectSets(uniques, runiques));
				default: false;
			}
		}
	}
}

makeTNode(tmap : TMap, t : TType) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", []);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st))
			))
		}
		TTypeSupertype(unique, subtypes, maxed): {
			emptySuper = TNodeSupertype(makeSet1(unique), [], makeSet());
			super = fold(subtypes, emptySuper, \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, super);
		}
	}
}

extractSupers(tmap : TMap, acc : TNodeSupertype, t : TType) -> TNodeSupertype {
	todo = \ -> {
		println("TODO: Figure out how to represent this as a named node in a super: " + prettyTType(t));
		acc;
	}
	addName = \n : TNodeName -> {
		TNodeSupertype(acc with subtypes = arrayPush(acc.subtypes, n));
	}
	addEClass = \e : int -> {
		TNodeSupertype(acc with unknownSubtypes = insertSet(acc.unknownSubtypes, e));
	}
	switch (t) {
		TTypeSupertype(__, sub, __): {
			fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars): {
					if (isEmptyTNode(node)) {
						addEClass(eclass);
					} else {
						addName(node);
					}
				}
				TNodeOverload(unique, overloads): todo();
				TNodeSupertype(uniques, subtypes, usub): {
					TNodeSupertype(acc with
						subtypes = concat(acc.subtypes, subtypes),
						unknownSubtypes = mergeSets(acc.unknownSubtypes, usub)
					);
				}
			}
		}
		TTypeName(__, __): {
			addName(makeTNodeName(tmap, t));
		}
		TTypeFunction(args, returnType): {
			addName(makeTNodeName(tmap, t));
		}
		TTypeOverload(unique, overloads): todo();
	}
}

// Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		printCallstack();
		TNodeName("", []);
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, map(typars, \tp -> findOrMakeTNodeClass(tmap, tp)));
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					map(args, \a -> 
						findOrMakeTNodeClass(tmap, a)
					),
					findOrMakeTNodeClass(tmap, returnType)
				)
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

// Given a node, simplify overload and supertypes as much as possible.
// - If overloads are unique, pick the one it is
// - If a supertype has unknown subtypes, see if
//   any are known
// - If a supertype has all subtypes known, find the potential
//   supers

simplifyTNode(tmap : TMap, node : TNode) -> TNode {
	switch (node) {
		TNodeName(name, typars): node;
		TNodeOverload(unique, overloads): {
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				// TODO: Doubt anything else is possible here?
				node;
			}
		}
		TNodeSupertype(uniques, subtypes, unknownSubtypes): {
			if (!isEmptySet(unknownSubtypes)) {
				resolved = foldSet(unknownSubtypes, Pair([], makeSet()), 
						\acc : Pair<[TNodeName], Set<int>>, st : int -> {
					unode = getUnionMapValue(tmap.tmap, st);
					unknown = \ -> {
						Pair(acc.first, insertSet(acc.second, st));
					}
					switch (unode) {
						TNodeName(name, typars): {
							if (isEmptyTNode(unode)) {
								unknown();
							} else {
								Pair(arrayPush(acc.first, unode), acc.second)
							}
						}
						default: unknown();
					}
				});
				if (resolved.first != []) {
					cleaned = TNodeSupertype(uniques, concat(subtypes, resolved.first), resolved.second);
					// println("Cleaned unknown " + prettyTNode(tmap, cleaned));
					simplifyTNode(tmap, cleaned);
				} else {
					node;
				}
			} else {
				// OK, we can calculate potential super types here
				// and reduce them to an overload or a given type
				named = foldi(subtypes, makeSet(), \i, acc, t : TNodeName -> {
					id = t.name;
					supers0 = ^(tmap.resolveSupertypes)(id);
					supers = arrayPush(supers0, id);
					supset = buildSet(supers);
					if (i == 0) supset
					else intersectSets(supset, acc)
				});

				nnamed = sizeSet(named);

				// Here we have the names that are possible
				if (nnamed == 1) {
					fnode = instantiateTNodeName(tmap, set2array(named)[0], subtypes);
					unifyTNodeNameWithSuper(tmap, fnode, node);
				} else if (nnamed < length(subtypes)) {	// This condition is a bit arbitrary
					// Make an overload out of the rest
					overloads = map(set2array(named), \n -> {
						instantiateTNodeName(tmap, n, subtypes)
					});
					overload = TNodeOverload(uniques, overloads);
					println("TODO: Supertype " + prettyTNode(tmap, node) + " becomes " + prettyTNode(tmap, overload));
					overload;
				} else {
					if (length(subtypes) > 1) {
						println("TODO: Check if we can unify intra-supers " + prettyTNode(tmap, node));
					}
					node;
				}
			}
		}
	}
}

// We know we want a given name, and we have a set of candidates to pick from
instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName]) -> TNodeName {
	node = filter(nodes, \n -> n.name == name);	
	if (length(node) > 0) {
		node[0];
	} else {
		munion = ^(tmap.resolveUnionName)(name);
		switch (munion) {
			None(): {
				typars = if (name == "array" || name == "ref") 1 else 0;
				TNodeName(name, generate(0, typars, \__ -> makeTNodeClass(tmap)));
			}
			Some(union): {
				typars = map(union.typars, \tp -> makeTNodeClass(tmap));
				TNodeName(name, typars);
			}
		}
	}
}

//
// The pure unification
//

mergeTNodes(tmap : TMap, left : TNode, right : TNode) -> TNode {
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \ -> {
		println("ERROR: Merge " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left)
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					if (lname != rname) {
						todo()
					} else if (length(ltypars) != length(rtypars)) {
						error();
					} else {
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							joinTNodes(tmap, lt, rtypars[i]);
						})))
					}
				}
				TNodeOverload(unique, overloads): {
					todo();
				}
				TNodeSupertype(unique, subtypes, __): {
					unifyTNodeNameWithSuper(tmap, left, right);
				}
			}
		}
		TNodeOverload(lunique, loverloads): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error();
					} else if (length(overloads) == 1) {
						// TODO: Unify the typars
						winner = overloads[0];
						mergeTNodes(tmap, winner, right);
//(())						println("TODO: Unify typars for unique " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right) + " for result " + prettyTNode(tmap, overloads[0]));
//						overloads[0];
					} else {
						noverload = TNodeOverload(lunique, overloads);
						println("TODO: Unify typars for " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, noverload));
						left;
					}
				}
				TNodeOverload(unique, overloads): {
					println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
					left;
				}
				TNodeSupertype(uniques, subtypes, usub): {
					todo();
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes, lusub): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Check that this name is a supertype
					// of all subtypes
					unifyTNodeNameWithSuper(tmap, right, left);
				}
				TNodeOverload(runique, roverloads): {
					todo();
				}
				TNodeSupertype(runique, rsubtypes, rusub): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes),
						mergeSets(lusub, rusub)
					));
				}
			}
		}
	}
}

unifyTNodeNameWithSuper(tmap : TMap, node : TNodeName, super : TNodeSupertype) -> TNode {
	// println("Unifying " + prettyTNode(tmap, node) + " vs " + prettyTNode(tmap, super));

	munion = ^(tmap.resolveUnionName)(node.name);
	found = ref false;
	iter(super.subtypes, \st -> {
		if (st.name == node.name) {
			// OK, the same
			if (length(st.typars) == length(node.typars)) {
				found := true;
				iteri(st.typars, \i, tp -> {
					joinTNodes(tmap, tp, node.typars[i]);
					{}
				})
			} else {
				println("ERROR: Join typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, super));
			}
		} else {
			// OK, we know that the node has to a supertype of st
			switch (munion) {
				None(): {
					println("TODO: Join typars of " + prettyTNode(tmap, node) + " against " + prettyTNode(tmap, st));
				}
				Some(union): {
					stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == st.name);
					stype ?? {
						found := true;
						// OK, we have the relation from the union to the struct in this union
						unifyTNodeNameAgainstStruct(tmap, node, st, union, stype);
					} : {
						println("ERROR: Join typars of " + prettyTNode(tmap, node) + " impossible against " + prettyTNode(tmap, super));
					}
				}
			}
		}
	});

	if (!isEmptySet(super.unknownSubtypes)) {
		eclass = findOrMakeTNode(tmap, node);
		iterSet(super.unknownSubtypes, \st -> {
			joinTNodes(tmap, eclass, st);
			found := true;
		});
	}

	if (!^found) {
		println("ERROR: Join " + prettyTNode(tmap, node) + " impossible against " + prettyTNode(tmap, super));
	}

	node;
}

// OK, we have a union on the left hand side, and a subtype on the right hand side
// We have to figure out how those typars relate to each other.
// Thus, we have unionDef and the corresponding typename instantiation
unifyTNodeNameAgainstStruct(tmap : TMap, unionNode : TNodeName, subNode : TNodeName, 
		unionDef : DUnion, subDef : DTypeName) -> void {
	// println("  Node " + prettyTNode(tmap, unionNode) + " vs " + prettyTNode(tmap, subNode));
	if (length(unionNode.typars) == length(unionDef.typars)) {
		// OK, map from the typar to the eclass it is bound to
		typars : Tree<string, int> = foldi(unionDef.typars, makeTree(), \i, acc, tp : DTypePar -> {
			setTree(acc, tp.id, unionNode.typars[i]);
		});

		// Consider
		// Maybe<?> ::= None, Some<?>
		// If we are in the None, case, notice we have one too little typars
		sdtype : DTypeName = if (length(subDef.typars) == 0) {
			// So we implicitly extend it when there are none
			DTypeName(subDef with typars = unionDef.typars)
		} else subDef;

		subtypes = map(sdtype.typars, \tp -> {
			dtype2eclass(tmap, typars, tp)
		});
		// OK, instantiate the struct from the union typars
		subInstantiated = TNodeName(subNode.name, subtypes);
		// println("    " + prettyTNode(tmap, subInstantiated) + " vs " + prettyTNode(tmap, subNode));
		iteri(subtypes, \i, tp -> {
			if (tp != -1) {
				joinTNodes(tmap, tp, subNode.typars[i]);
				{}
			} else {
				println("ERROR: Could not match typars " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
			}
		{}
		});
	} else {
		println("ERROR: Expected typars for " + prettyTNode(tmap, subNode) + " vs " + prettyTNode(tmap, unionNode));
	}
}

dtype2eclass(tmap : TMap, typars : Tree<string, int>, d : DType) -> int {
	todo = \ -> {
		println("TODO: Convert " + toString(d) + " to eclass");
		-1;
	}
	switch (d) {
		DTypePar(id, pos): lookupTreeDef(typars, id, -1);
		DTypeName(id, ttypars, pos): todo();
		DTypeFunction(args, returnType, pos): todo();
	}
}

joinTNodes(tmap : TMap, left : int, right : int) -> int {
	root = unionUnionMap(tmap.tmap, left, right);
	
	if (false) {
		lnode = getUnionMapValue(tmap.tmap, left);
		rnode = getUnionMapValue(tmap.tmap, right);
		
		println("  Joining e" + i2s(left) + " and e" + i2s(right) + " to e" + i2s(root) + ": " + debugTNode(tmap, root)
			+ " from " + prettyTNode(tmap, lnode) + " and " + prettyTNode(tmap, rnode));
	}

	findUnionMapRoot(tmap.tmap, root);
}

// Are these node names incompatible forever?
incompatibleTNodeNames(tmap : TMap, node : TNodeName, overload : TNodeName) -> bool {
	if (isEmptyTNode(node) || isEmptyTNode(overload)) {
		false
	} else {
		node.name != overload.name 
		|| length(node.typars) != length(overload.typars)
		|| exists(mapi(node.typars, \i, tp -> {
			incompatibleEClasses(tmap, tp, overload.typars[i])
		}), idfn)
	}
}

isEmptyTNode(n : TNode) -> bool {
	switch (n) {
		TNodeName(name, pars): name == "" && pars == [];
		default: false;
	}
}

incompatibleEClasses(tmap : TMap, left : int, right : int) -> bool {
	lroot = findUnionMapRoot(tmap.tmap, left);
	rroot = findUnionMapRoot(tmap.tmap, right);
	lroot != rroot
	&& {
		lnode = getUnionMapValue(tmap.tmap, lroot);
		rnode = getUnionMapValue(tmap.tmap, rroot);
		incompatibleTNodes(tmap, lnode, rnode);
	}
}

incompatibleTNodes(tmap : TMap, left : TNode, right : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if node " + prettyTNode(tmap, left) + " is compatible with node " + prettyTNode(tmap, right));
		false;
	}
	if (isEmptyTNode(left) || isEmptyTNode(right)) false
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					incompatibleTNodeNames(tmap, left, right)
				}
				default: todo();
			}
		}
		TNodeOverload(lunique, loverloads): {
			todo();
		}
		TNodeSupertype(luniques, lsubtypes, __): {
			todo();
		}
	}
}

findTNode(tmap : TMap, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tmap.tmap, eclass);
		}
		default: {
			findUnionMap(tmap.tmap, \i, val : TNode -> {
				c = isTTypeInTNode(tmap, type, i, val);
				if (false && c) {
					println("  e" + i2s(i) + " has " + prettyTType(type));
				}
				c;
			}, -1);
		}
	}
}

isTTypeInTNode(tmap : TMap, t : TType, nclass : int, n : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if type " + prettyTType(t) + " is node " + prettyTNode(tmap, n));
		false;
	}
	isSameEClass = \ec -> {
		findUnionMapRoot(tmap.tmap, ec) == findUnionMapRoot(tmap.tmap, nclass)
	}
	switch (n) {
		TNodeName(name, typars): {
			switch (t) {
				TTypeName(id, ttypars): {
					if (id == name) areTTypesInTNodes(tmap, ttypars, typars) else false;
				}
				TTypeFunction(args, returnType): {
					if (name == "" && length(typars) == length(args) + 1) {
						areTTypesInTNodes(tmap, args, subrange(typars, 0, length(args)))
						&& areTTypesInTNodes(tmap, [returnType], [typars[length(args)]])
					} else {
						false;
					}
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				TTypeOverload(unique, overloads): false;
				TTypeSupertype(unique, subtypes, maxed): false;
			}
		}
		TNodeOverload(uniques, overloads): {
			switch (t) {
				TTypeOverload(tunique, __): {
					uid = findTNode(tmap, tunique);
					containsSet(uniques, uid);
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
		TNodeSupertype(uniques, subtypes, __): {
			switch (t) {
				TTypeSupertype(uid, __, maxed): containsSet(uniques, uid);
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
	}
}

areTTypesInTNodes(tmap : TMap, ts : [TType], ns : [int]) -> bool {
	length(ts) == length(ns)
	&& forall(mapi(ts, \i, t -> {
		eclass = ns[i];
		node = getUnionMapValue(tmap.tmap, eclass);
		isTTypeInTNode(tmap, t, eclass, node)
	}), idfn)
}

prettyTNode(tmap : TMap, t : TNode) -> string {
	switch (t) {
		TNodeName(name, typars): {
			if (name == "") {
				if (typars == []) "Îµ"
				else {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					"(" + superglue(args, \e -> prettyEClass(tmap, e), ", ") + ")"
					+ "->" + prettyEClass(tmap, rt)
				}
			} else {
				name
				+ (if (typars != []) "<" + superglue(typars, \e -> prettyEClass(tmap, e), ",") + ">" else "");
			}
		}
		TNodeOverload(uniques, overloads): {
			"overload" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(overloads, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
		TNodeSupertype(uniques, subtypes, usub): {
			"super" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(subtypes, \o -> prettyTNode(tmap, o), ", ")
			+ (if (isEmptySet(usub)) "" else 
				superglue(set2array(usub), \st -> "e" + i2s(st), ", ")
			)
			+ "}"
			;
		}
	}
}

prettyEClass(tmap : TMap, eclass : int) -> string {
	node = getUnionMapValue(tmap.tmap, eclass);
	if (isEmptyTNode(node)) "e" + i2s(eclass)
	else prettyTNode(tmap, node)
}

debugTNode(tmap : TMap, root : int) -> string {
	node = getUnionMapValue(tmap.tmap, root);

	childClasses = foldRange(0, ^(tmap.nextEClass), [], \acc2, ec -> {
		r = findUnionMapRoot(tmap.tmap, ec);
		if (r == root) {
			arrayPush(acc2, ec)
		} else acc2;
	});

	rpad(prettyTNode(tmap, node), " ", 30) + "   covers " + superglue(childClasses, \c -> "e" + i2s(c), " ");
}

getTNodes(tmap : TMap) -> Set<int> {
	aroots = getUnionMapRoots(tmap.tmap);
	filterSet(aroots, \r -> {
		r < ^(tmap.nextEClass)
	});
}

// At the end, extract the types

resolveTNodes(tmap : TMap) -> Tree<int, TType> {
	roots = getTNodes(tmap);
	types = ref makeTree();
	visited = ref makeSet();

	iterSet(roots, \root -> {
		node = getUnionMapValue(tmap.tmap, root);
		if (!isEmptyTNode(node)) {
			t = resolveTNodeClass(tmap, types, visited, root);
			// println("e" + i2s(root) + " = " + rpad(prettyTType(t), " ", 30) + "   from " + debugTNode(tmap, root));
		}
	});

	^types
}

resolveTNodeClass(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	if (containsSet(^visited, eclass)) {
		mkClass(eclass)
	} else {
		visited := insertSet(^visited, eclass);
		node = getUnionMapValue(tmap.tmap, eclass);
		resolveTNode(tmap, acc, visited, eclass, node);
	}
}

resolveTNode(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int, node : TNode) {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	set = \tt -> {
		acc := setTree(^acc, eclass, tt);
		tt;
	}

	switch (node) {
		TNodeName(name, typars): {
			if (name == "" && typars == []) {
				mkClass(eclass)
			} else if (name == "") {
				args = subrange(typars, 0, length(typars) - 1);
				rt = typars[length(typars) - 1];
				set(TTypeFunction(
					map(args, \a -> {
						resolveTNodeClass(tmap, acc, visited, a)
					}),
					resolveTNodeClass(tmap, acc, visited, rt)
				))
			} else {
				set(TTypeName(name, map(typars, \tp -> {
					resolveTNodeClass(tmap, acc, visited, tp)
				})))
			}
		}
		TNodeOverload(unique, overloads): {
			println("TODO: Resolve overload: " + prettyTNode(tmap, node));
			mkClass(eclass);
		}
		TNodeSupertype(unique, subtypes, __): {
			simpler = simplifyTNode(tmap, node);
			if (simpler != node) {
				resolveTNode(tmap, acc, visited, eclass, simpler);
			} else {
				println("TODO: Resolve supertype: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
	}
}