import plow/types/ugraph/type;
import plow/types/pretty;

export {
	makeTMap(
		resolveSupertypes : (string) -> [string], 
		onError : (int, string) -> void, 
		nextEClass : ref int
	) -> TMap;
	unifyTNodes(tmap : TMap, left : TType, right : TType) -> void;

	resolveTNodes(tmap : TMap) -> Tree<int, TType>;
}

makeTMap(
		resolveSupertypes : (string) -> [string], 
		onError : (int, string) -> void, nextEClass : ref int) -> TMap {
	self = TMap(
		makeUnionFindMap(defaultTNode(), \l, r -> {
			println("Not supposed to happen");
			l
		}),
		resolveSupertypes,
		onError,
		nextEClass,
	);
	TMap(
		self with tmap =
			UnionFindMap(self.tmap with mergeFn = \l, r -> {
				mergeTNodes(self, l, r);
			})
	);
}

defaultTNode() -> TNode {
	TNodeName("", []);
}

// These two types are unified
unifyTNodes(tmap : TMap, left : TType, right : TType) -> void {
	// println("Unify " + prettyTType(left) + " and " + prettyTType(right));
	lclass = findTNode(tmap, left);
	rclass = findTNode(tmap, right);
	if (lclass != -1 && rclass != -1) {
		unionUnionMap(tmap.tmap, lclass, rclass);
		{}
	} else if (lclass != -1) {
		addTTypeToEClass(tmap, lclass, right);
	} else if (rclass != -1) {
		addTTypeToEClass(tmap, rclass, left);
	} else {
		println("TODO: Unify unknown " + prettyTType(left) + " and " + prettyTType(right));
	}
}

// We promise there is no node for this
addTTypeToEClass(tmap : TMap, eclass : int, type : TType) -> void {
	switch (type) {
		TTypeEClass(nclass): {
			unionUnionMap(tmap.tmap, eclass, nclass);
			{}
		}
		default: {
			tnode1 = getUnionMapValue(tmap.tmap, eclass);
			if (isEmptyTNode(tnode1)) {
				tnode2 = makeTNode(tmap, type);
				setUnionMapValue(tmap.tmap, eclass, tnode2)
			} else {
				// TODO: We could do it without making a new node
				// if we wanted to be a bit more clean
				// println("Can we add " + prettyTType(type) + " to " + prettyTNode(tmap, tnode1));
				tnode2 = makeTNode(tmap, type);
				nnode = mergeTNodes(tmap, tnode1, tnode2);
				setUnionMapValue(tmap.tmap, eclass, nnode)
			}
		}
	}
}

makeTNode(tmap : TMap, t : TType) -> TNode {
	error = \ -> {
		println("ERROR: Could not make TNode for " + prettyTType(t));
		TNodeName("", []);
	}
	switch (t) {
		TTypeName(id, typars): makeTNodeName(tmap, t);
		TTypeEClass(eclass): {
			getUnionMapValue(tmap.tmap, eclass);
		}
		TTypeFunction(args, returnType): makeTNodeName(tmap, t);
		TTypeOverload(unique, overloads): {
			uid = findTNode(tmap, unique);
			uniques = if (uid == -1) {
				error();
				makeSet();
			} else makeSet1(uid);
			simplifyTNode(tmap, TNodeOverload(
				uniques,
				map(overloads, \st -> makeTNodeName(tmap, st))
			))
		}
		TTypeSupertype(unique, subtypes, maxed): {
			supers = fold(subtypes, [], \acc, st -> extractSupers(tmap, acc, st));
			simplifyTNode(tmap, TNodeSupertype(
				makeSet1(unique), 
				supers
			))
		}
	}
}

extractSupers(tmap : TMap, acc : [TNodeName], t : TType) -> [TNodeName] {
	todo = \ -> {
		println("TODO: Figure out how to represent this as a named node: " + prettyTType(t));
		acc;
	}
	switch (t) {
		TTypeSupertype(__, sub, __): fold(sub, acc, \acc2, st -> extractSupers(tmap, acc2, st));
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(name, typars): arrayPush(acc, node);
				TNodeOverload(unique, overloads): todo();
				TNodeSupertype(uniques, subtypes): concat(acc, subtypes);
			}
		}
		TTypeName(__, __): {
			arrayPush(acc, makeTNodeName(tmap, t));
		}
		TTypeFunction(args, returnType): {
			arrayPush(acc, makeTNodeName(tmap, t));
		}
		TTypeOverload(unique, overloads): todo();
	}
}

simplifyTNode(tmap : TMap, node : TNode) -> TNode {
	switch (node) {
		TNodeName(name, typars): node;
		TNodeOverload(unique, overloads): {
			if (length(overloads) == 1) {
				overloads[0];
			} else {
				// TODO: Doubt anything else is possible here?
				node;
			}
		}
		TNodeSupertype(uniques, subtypes): {
			// TODO: If these are multiple subtypes with the same
			// name, unify their typars

			// OK, we can calculate potential super types here
			// and reduce them to an overload or a given type
			named = foldi(subtypes, makeSet(), \i, acc, t : TNodeName -> {
				id = t.name;
				supers0 = tmap.resolveSupertypes(id);
				supers = arrayPush(supers0, id);
				supset = buildSet(supers);
				if (i == 0) supset
				else intersectSets(supset, acc)
			});
			// Here we have the names that are possible
			if (sizeSet(named) == 1) {
				instantiateTNodeName(tmap, set2array(named)[0], subtypes)
			} else {
				// Make an overload out of the rest!
				overloads = map(set2array(named), \n -> {
					println("TODO: Overload instantiate " + n + " from " + prettyTNode(tmap, node));
					TNodeName(n, []);
				});
				overload = TNodeOverload(uniques, overloads);
				println("TODO: Supertype " + prettyTNode(tmap, node) + " becomes " + prettyTNode(tmap, overload));
				node;
			}
		}
	}
}

// We know we want a given name, and we have a set of candidates to pick from
instantiateTNodeName(tmap : TMap, name : string, nodes : [TNodeName]) -> TNodeName {
	node = filter(nodes, \n -> {
		n.name == name
	});	
	if (length(node) > 0) {
		node[0];
	} else {
		println("TODO: Overload instantiate " + name + " from " + toString(nodes));
		TNodeName(name, []);
	}
}

// Used for the args of overloads and supertypes
makeTNodeName(tmap : TMap, t : TType) -> TNodeName {
	error = \ -> {
		println("ERROR: Could not make TNodeName for " + prettyTType(t));
		printCallstack();
		TNodeName("", []);
	};
	switch (t) {
		TTypeName(id, typars): {
			TNodeName(id, map(typars, \tp -> findOrMakeTNodeClass(tmap, tp)));
		}
		TTypeFunction(args, returnType): {
			TNodeName("", 
				arrayPush(
					map(args, \a -> 
						findOrMakeTNodeClass(tmap, a)
					),
					findOrMakeTNodeClass(tmap, returnType)
				)
			)
		}
		TTypeEClass(eclass): {
			node = getUnionMapValue(tmap.tmap, eclass);
			switch (node) {
				TNodeName(__, __): node;
				default: {
					println("TODO: Lift this up to super or overload: " + prettyTNode(tmap, node));
					error();
				}
			}
		}
		TTypeOverload(unique, overloads): error();
		TTypeSupertype(unique, subtypes, maxed): error();
	}
}

findOrMakeTNodeClass(tmap : TMap, type : TType) -> int {
	eclass = findTNode(tmap, type);
	if (eclass != -1) {
		eclass
	} else {
		node = makeTNode(tmap, type);
		
		sclass = findUnionMap(tmap.tmap, \i, val : TNode -> {
			node == val
		}, -1);

		if (sclass == -1) {
			nclass = ^(tmap.nextEClass);
			tmap.nextEClass := nclass + 1;
			setUnionMapValue(tmap.tmap, nclass, node);
			// println("Made e" + i2s(nclass) + " for " + prettyTType(type) + " as " + prettyTNode(tmap, node));
			nclass;
		} else sclass;
	}
}

mergeTNodes(tmap : TMap, left : TNode, right : TNode) -> TNode {
	todo = \ -> {
		println("TODO: Merge nodes " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	error = \ -> {
		println("ERROR: Merge " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
		left;
	}
	if (isEmptyTNode(left)) simplifyTNode(tmap, right)
	else if (isEmptyTNode(right)) simplifyTNode(tmap, left)
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					if (rname == "" && rtypars == []) {
						left
					} else if (lname != rname) {
						todo()
					} else if (length(ltypars) != length(rtypars)) {
						error();
					} else {
						simplifyTNode(tmap, TNodeName(lname, mapi(ltypars, \i, lt -> {
							unionUnionMap(tmap.tmap, lt, rtypars[i])
						})))
					}
				}
				TNodeOverload(unique, overloads): {
					todo();
				}
				TNodeSupertype(unique, subtypes): {
					todo();
				}
			}
		}
		TNodeOverload(lunique, loverloads): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Find which of the overloads potentially match this one
					overloads = filter(loverloads, \lo : TNodeName -> {
						c = incompatibleTNodeNames(tmap, right, lo);
						if (c) {
							// println("Ignoring incompatible overload " + prettyTNode(tmap, lo) + " for " + prettyTNode(tmap, right));
							false;
						} else {
							true;
						}
					});
					if (overloads == []) {
						error();
					} else if (length(overloads) == 1) {
						// TODO: Unify the typars
						winner = overloads[0];
						mergeTNodes(tmap, winner, right);
//(())						println("TODO: Unify typars for unique " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right) + " for result " + prettyTNode(tmap, overloads[0]));
//						overloads[0];
					} else {
						noverload = TNodeOverload(lunique, overloads);
						println("TODO: Unify typars for " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, noverload));
						left;
					}
				}
				TNodeOverload(unique, overloads): {
					println("TODO: Find the intersection between " + prettyTNode(tmap, left) + " and " + prettyTNode(tmap, right));
					left;
				}
				TNodeSupertype(uniques, subtypes): {
					todo();
				}
			}
		}
		TNodeSupertype(lunique, lsubtypes): {
			switch (right) {
				TNodeName(name, typars): {
					// OK: Check that this name is a supertype
					// of all subtypes
					todo();
				}
				TNodeOverload(runique, roverloads): {
					todo();
				}
				TNodeSupertype(runique, rsubtypes): {
					simplifyTNode(tmap, TNodeSupertype(
						mergeSets(lunique, runique), 
						concat(lsubtypes, rsubtypes)
					));
				}
			}
		}
	}
}

// Are these node names incompatible forever?
incompatibleTNodeNames(tmap : TMap, node : TNodeName, overload : TNodeName) -> bool {
	if (isEmptyTNode(node) || isEmptyTNode(overload)) {
		false
	} else {
		node.name != overload.name 
		|| length(node.typars) != length(overload.typars)
		|| exists(mapi(node.typars, \i, tp -> {
			incompatibleEClasses(tmap, tp, overload.typars[i])
		}), idfn)
	}
}

isEmptyTNode(n : TNode) -> bool {
	switch (n) {
		TNodeName(name, pars): name == "" && pars == [];
		default: false;
	}
}

incompatibleEClasses(tmap : TMap, left : int, right : int) -> bool {
	lroot = findUnionMapRoot(tmap.tmap, left);
	rroot = findUnionMapRoot(tmap.tmap, right);
	lroot != rroot
	&& {
		lnode = getUnionMapValue(tmap.tmap, lroot);
		rnode = getUnionMapValue(tmap.tmap, rroot);
		incompatibleTNodes(tmap, lnode, rnode);
	}
}

incompatibleTNodes(tmap : TMap, left : TNode, right : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if node " + prettyTNode(tmap, left) + " is compatible with node " + prettyTNode(tmap, right));
		false;
	}
	if (isEmptyTNode(left) || isEmptyTNode(right)) false
	else switch (left) {
		TNodeName(lname, ltypars): {
			switch (right) {
				TNodeName(rname, rtypars): {
					incompatibleTNodeNames(tmap, left, right)
				}
				default: todo();
			}
		}
		TNodeOverload(lunique, loverloads): {
			todo();
		}
		TNodeSupertype(luniques, lsubtypes): {
			todo();
		}
	}
}

findTNode(tmap : TMap, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tmap.tmap, eclass);
		}
		default: {
			findUnionMap(tmap.tmap, \i, val : TNode -> {
				c = isTTypeInTNode(tmap, type, i, val);
				// println(i2s(i) + " has " + prettyTType(type) + " is " + b2s(c));
				c;
			}, -1);
		}
	}
}

isTTypeInTNode(tmap : TMap, t : TType, nclass : int, n : TNode) -> bool {
	todo = \ -> {
		println("TODO: Check if type " + prettyTType(t) + " is node " + prettyTNode(tmap, n));
		false;
	}
	isSameEClass = \ec -> {
		findUnionMapRoot(tmap.tmap, ec) == findUnionMapRoot(tmap.tmap, nclass)
	}
	switch (n) {
		TNodeName(name, typars): {
			switch (t) {
				TTypeName(id, ttypars): {
					if (id == name) areTTypesInTNodes(tmap, ttypars, typars) else false;
				}
				TTypeFunction(args, returnType): {
					if (name == "" && length(typars) == length(args) + 1) {
						areTTypesInTNodes(tmap, args, subrange(typars, 0, length(args)))
						&& areTTypesInTNodes(tmap, [returnType], [typars[length(args)]])
					} else {
						false;
					}
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				TTypeOverload(unique, overloads): false;
				TTypeSupertype(unique, subtypes, maxed): false;
			}
		}
		TNodeOverload(uniques, overloads): {
			switch (t) {
				TTypeOverload(tunique, __): {
					uid = findTNode(tmap, tunique);
					containsSet(uniques, uid);
				}
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
		TNodeSupertype(uniques, subtypes): {
			switch (t) {
				TTypeSupertype(uid, __, maxed): containsSet(uniques, uid);
				TTypeEClass(eclass): isSameEClass(eclass);
				default: false;
			}
		}
	}
}

areTTypesInTNodes(tmap : TMap, ts : [TType], ns : [int]) -> bool {
	length(ts) == length(ns)
	&& forall(mapi(ts, \i, t -> {
		eclass = ns[i];
		node = getUnionMapValue(tmap.tmap, eclass);
		isTTypeInTNode(tmap, t, eclass, node)
	}), idfn)
}

prettyTNode(tmap : TMap, t : TNode) -> string {
	switch (t) {
		TNodeName(name, typars): {
			if (name == "") {
				if (typars == []) "ε"
				else {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					"(" + superglue(args, \e -> prettyEClass(tmap, e), ", ") + ")"
					+ "->" + prettyEClass(tmap, rt)
				}
			} else {
				name
				+ (if (typars != []) "<" + superglue(typars, \e -> "e" + i2s(e), ",") + ">" else "");
			}
		}
		TNodeOverload(uniques, overloads): {
			"overload" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(overloads, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
		TNodeSupertype(uniques, subtypes): {
			"super" + superglue(set2array(uniques), i2s, "_") + "{"
			+ superglue(subtypes, \o -> prettyTNode(tmap, o), ", ")
			+ "}";
		}
	}
}

prettyEClass(tmap : TMap, eclass : int) -> string {
	node = getUnionMapValue(tmap.tmap, eclass);
	if (isEmptyTNode(node)) "e" + i2s(eclass)
	else prettyTNode(tmap, node)
}

debugTNode(tmap : TMap, root : int) -> string {
	node = getUnionMapValue(tmap.tmap, root);

	childClasses = foldRange(0, ^(tmap.nextEClass), [], \acc2, ec -> {
		r = findUnionMapRoot(tmap.tmap, ec);
		if (r == root) {
			arrayPush(acc2, ec)
		} else acc2;
	});

	rpad(prettyTNode(tmap, node), " ", 30) + "   covers " + superglue(childClasses, \c -> "e" + i2s(c), " ");
}

getTNodes(tmap : TMap) -> Set<int> {
	aroots = getUnionMapRoots(tmap.tmap);
	filterSet(aroots, \r -> {
		r < ^(tmap.nextEClass)
	});
}

// At the end, extract the types

resolveTNodes(tmap : TMap) -> Tree<int, TType> {
	roots = getTNodes(tmap);
	types = ref makeTree();
	visited = ref makeSet();

	iterSet(roots, \root -> {
		node = getUnionMapValue(tmap.tmap, root);
		if (!isEmptyTNode(node)) {
			t = resolveTNode(tmap, types, visited, root);
			println("e" + i2s(root) + " = " + rpad(prettyTType(t), " ", 30) + "   from " + debugTNode(tmap, root));
		}
	});

	^types
}

resolveTNode(tmap : TMap, acc : ref Tree<int, TType>, visited : ref Set<int>, eclass : int) -> TType {
	mkClass = \ee -> {
		lookupTreeDef(^acc, ee, TTypeEClass(ee))
	}
	set = \tt -> {
		acc := setTree(^acc, eclass, tt);
		tt;
	}
	if (containsSet(^visited, eclass)) {
		mkClass(eclass)
	} else {
		visited := insertSet(^visited, eclass);
		node = getUnionMapValue(tmap.tmap, eclass);
		switch (node) {
			TNodeName(name, typars): {
				if (name == "" && typars == []) {
					mkClass(eclass)
				} else if (name == "") {
					args = subrange(typars, 0, length(typars) - 1);
					rt = typars[length(typars) - 1];
					set(TTypeFunction(
						map(args, \a -> {
							resolveTNode(tmap, acc, visited, a)
						}),
						resolveTNode(tmap, acc, visited, rt)
					))
				} else {
					set(TTypeName(name, map(typars, \tp -> {
						resolveTNode(tmap, acc, visited, tp)
					})))
				}
			}
			TNodeOverload(unique, overloads): {
				println("TODO: Resolve overload: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
			TNodeSupertype(unique, subtypes): {
				println("TODO: Resolve supertype: " + prettyTNode(tmap, node));
				mkClass(eclass);
			}
		}
	}
}
