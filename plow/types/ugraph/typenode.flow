import plow/types/type;
import algorithms;

export {
	TTypeNode(
		best : [TType],
		overload : Maybe<TTypeOverload>,
		supertype : Maybe<TTypeSupertype>,
		reasons : [string],
		positions : [int],
	);

	defaultTTypeNode() -> TTypeNode;

	makeTTypeNode(type : TType, reasons : [string], positions : [int]) -> TTypeNode;

	mergeTTypeNodes(left : TTypeNode, right : TTypeNode) -> TTypeNode;
}

defaultTTypeNode() -> TTypeNode {
	TTypeNode([], None(), None(), [], []);
}

makeTTypeNode(type : TType, reasons : [string], positions : [int]) -> TTypeNode {
	switch (type) {
		TTypeName(id, typars): TTypeNode([type], None(), None(), reasons, positions);
		TTypeEClass(eclass): TTypeNode([type], None(), None(), reasons, positions);
		TTypeFunction(args, returnType): TTypeNode([type], None(), None(), reasons, positions);
		TTypeOverload(unique, overloads): TTypeNode([], Some(type), None(), reasons, positions);
		TTypeSupertype(unique, subtypes, maxed): TTypeNode([], None(), Some(type), reasons, positions);
	}
}

mergeTTypeNodes(left : TTypeNode, right : TTypeNode) -> TTypeNode {
	best = sortUnique(concat(left.best, right.best));
	
	overload = switch (left.overload) {
		None(): right.overload;
		Some(loverload): {
			switch (right.overload) {
				None(): left.overload;
				Some(roverload): {
					Some(TTypeOverload(loverload.unique, sortUnique(concat(loverload.overloads, roverload.overloads))));
				}
			}
		}
	};

	supertype = switch (left.supertype) {
		None(): right.supertype;
		Some(lsupertype): {
			switch (right.supertype) {
				None(): left.supertype;
				Some(rsupertype): {
					st = sortUnique(concat(lsupertype.subtypes, rsupertype.subtypes));
					Some(TTypeSupertype(lsupertype.unique, st, lsupertype.maxed || rsupertype.maxed));
				}
			}
		}
	}
/*	supertypes = filter(, \tt -> {
		!contains(best, tt)
	});*/

	TTypeNode(
		best,
		overload,
		supertype,
		concat(left.reasons, right.reasons),
		uniq(concat(left.positions, right.positions))
	);
}
