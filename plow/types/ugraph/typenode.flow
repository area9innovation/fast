import plow/types/type;
import algorithms;

export {
	TTypeNode(
		// Here we keep the cost of this typenode, as well as the best one we have so far
		// cost : TTypeCost,
		best : [TType],
		overload : Maybe<TTypeOverload>,
		supertype : Maybe<TTypeSupertype>,
		// Here, we keep a history of previous types we had so we can find them again
		originals : Set<TType>,
		reasons : [string],
		positions : [int],
	);

	TTypeCost(
		// The best & cheapest type
		type : TType,
		// Approximately the number of different types possible
		cost : int,
		// How much has been resolved
		benefit : int,
	);

	defaultTTypeNode() -> TTypeNode;

	makeTTypeNode(type : TType, reasons : [string], positions : [int]) -> TTypeNode;

	mergeTTypeNodes(left : TTypeNode, right : TTypeNode) -> TTypeNode;
}

defaultTTypeNode() -> TTypeNode {
	TTypeNode([], None(), None(), makeSet(), [], []);
}

makeTTypeNode(type : TType, reasons : [string], positions : [int]) -> TTypeNode {
	switch (type) {
		TTypeName(id, typars): TTypeNode([type], None(), None(), makeSet(), reasons, positions);
		TTypeEClass(eclass): {
			println("NOT SUPPOSED TO HAPPEN 2");
			printCallstack();
			TTypeNode([type], None(), None(), makeSet(), reasons, positions);
		}
		TTypeFunction(args, returnType): TTypeNode([type], None(), None(), makeSet(), reasons, positions);
		TTypeOverload(unique, overloads): TTypeNode([], Some(type), None(), makeSet(), reasons, positions);
		TTypeSupertype(unique, subtypes, maxed): TTypeNode([], None(), Some(type), makeSet(), reasons, positions);
	}
}

mergeTTypeNodes(left : TTypeNode, right : TTypeNode) -> TTypeNode {
	best = sortUnique(concat(left.best, right.best));
	
	overload : Maybe<TTypeOverload> = switch (left.overload) {
		None(): right.overload;
		Some(loverload): {
			switch (right.overload) {
				None(): left.overload;
				Some(roverload): {
					Some(
						TTypeOverload(loverload.unique, 
							sortUnique(concat(loverload.overloads, roverload.overloads))
						)
					);
				}
			}
		}
	};

	supertype : Maybe<TTypeSupertype> = switch (left.supertype) {
		None(): right.supertype;
		Some(lsupertype): {
			switch (right.supertype) {
				None(): left.supertype;
				Some(rsupertype): {
					st = sortUnique(concat(lsupertype.subtypes, rsupertype.subtypes));
					Some(TTypeSupertype(lsupertype.unique, st, lsupertype.maxed || rsupertype.maxed));
				}
			}
		}
	}

	add = \acc, m -> {
		switch (m) {
			None(): acc;
			Some(t): insertSet(acc, t);
		}
	};
	origs1 = add(mergeSets(left.originals, right.originals), left.overload);
	origs2 = add(origs1, right.overload);
	origs3 = add(origs2, left.supertype);
	origs4 = add(origs3, right.supertype);
	rem = \acc, m : Maybe<TType> -> {
		switch (m) {
			None(): acc;
			Some(t): removeSet(acc, t)
		}
	}
	origs5 = rem(origs4, overload);
	origs6 = rem(origs5, supertype);

	TTypeNode(
		best,
		overload,
		supertype,
		origs6,
		concat(left.reasons, right.reasons),
		uniq(concat(left.positions, right.positions))
	);
}
