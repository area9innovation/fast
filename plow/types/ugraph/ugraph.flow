import plow/types/pretty;
import plow/types/ugraph/type;

export {
	makeTypeGraph(onError : (int, string) -> void) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// What is the current set of roots?
	getEClassRoots(tg : TypeGraph) -> Set<int>;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// Is there an equivalence class for this type? -1 is not
	findEClass(tg : TypeGraph, type : TType) -> int;

	// Find or make an eclass for this type
	makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass;

	// After setting up all the relations, calls resolveEClasses from resolve.flow
	// which will populate the etypes in the TTypeEnv
}

makeTypeGraph(onError : (int, string) -> void) -> TypeGraph {
	TypeGraph(
		makeUnionFindMap(defaultTTypeNode(), mergeTTypeNodes),
		ref 0,
		onError
	)
}

emptyTTypeClass(tg : TypeGraph) -> int {
	ec = ^(tg.nextEClass);
	tg.nextEClass := ec + 1;
	ec;
}

getEClassRoots(tg : TypeGraph) -> Set<int> {
	roots = getUnionMapRoots(tg.umap);
	filterSet(roots, \r -> {
		r < ^(tg.nextEClass)
	})
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	findUnionMapRoot(tg.umap, eclass)
}

findEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): eclass;
		default: {
			findUnionMap(tg.umap, \i, val : TTypeNode -> {
				c = containsNodeTType(tg, ref makeSet(), val, type);
				// println(i2s(i) + " has " + prettyTType(type) + " is " + b2s(c));
				c;
			}, -1)
		}
	}
}

// Does this eclass contain this type?
containsEClassTType(tg : TypeGraph, visited : ref Set<int>, eclass : int, type : TType) -> bool {
	if (containsSet(^visited, eclass)) false
	else {
		node = getUnionMapValue(tg.umap, eclass);
		visited := insertSet(^visited, eclass);
		containsNodeTType(tg, visited, node, type)
	}
}

// Does this type node contain this type?
containsNodeTType(tg : TypeGraph, visited : ref Set<int>, node : TTypeNode, type : TType) -> bool {
	containsSet(node.originals, type)
	|| switch (type) {
		TTypeName(id, typars): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeEClass(eclass): {
			println("Not supposed to happen");
			false;
		}
		TTypeFunction(args, returnType): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeOverload(unique, overloads): {
			switch (node.overload) {
				None(): false;
				Some(no): no.unique == unique;
			}
		}
		TTypeSupertype(unique, subtypes, maxed): {
			switch (node.supertype) {
				None(): false;
				Some(st): {
					st.unique == unique;
				}
			}
		}
	}
}

containsNodeTTypes(tg : TypeGraph, visited : ref Set<int>, i : int, types : [TType], type : TType) -> bool {
	if (i < length(types)) {
		type1 = types[i];
		if (isSameTType(tg, visited, type1, type)) {
			true
		} else {
			containsNodeTTypes(tg, visited, i + 1, types, type)
		}
	} else {
		false;
	}
}

isSameTType(tg : TypeGraph, visited : ref Set<int>, left : TType, right : TType) -> bool {
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): lid == rid && areSameTTypes(tg, visited, ltypars, rtypars);
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeEClass(lclass): {
			switch (right) {
				TTypeEClass(rclass): {
					lroot = rootTTypeEClass(tg, lclass);
					rroot = rootTTypeEClass(tg, rclass);
					lroot == rroot;
				}
				default: {
					containsEClassTType(tg, visited, lclass, right);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					areSameTTypes(tg, visited, largs, rargs)
					&& isSameTType(tg, visited, lreturnType, rreturnType);
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeOverload(lunique, loverloads): {
			switch (right) {
				TTypeOverload(runique, roverloads): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeSupertype(lunique, lsubtypes, lmaxed): {
			switch (right) {
				TTypeSupertype(runique, rsubtypes, rmaxed): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
	}
}

areSameTTypes(tg : TypeGraph, visited : ref Set<int>, left : [TType], right : [TType]) -> bool {
	length(left) == length(right)
	&& forall(mapi(left, \i, l -> isSameTType(tg, visited, l, right[i])), idfn)
}


// Rewrite a type to use as many eclasses as possible
makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass {
	typeclass = findEClass(tg, type);
	if (typeclass == -1) {
		rec = \tt -> makeTTypeEClass(tg, reasons, pos, tt);
		set = \tt -> {
			newclass = emptyTTypeClass(tg);
			node = makeTTypeNode(tt, reasons, pos);
			setUnionMapValue(tg.umap, newclass, node);
			TTypeEClass(newclass);
		}
		switch (type) {
			TTypeName(id, typars): {
				set(TTypeName(id, map(typars, rec)));
			}
			TTypeEClass(eclass): {
				root = rootTTypeEClass(tg, eclass);
				TTypeEClass(root);
			}
			TTypeFunction(args, returnType): {
				set(TTypeFunction(map(args, rec), rec(returnType)));
			}
			TTypeOverload(unique, overloads): {
				set(type);
			}
			TTypeSupertype(unique, subtypes, maxed): {
				set(type);
			}
		}
	} else TTypeEClass(typeclass)
}
