import plow/types/pretty;
import plow/types/ugraph/type;

export {
	makeTypeGraph(onError : (int, string) -> void) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// What is the current set of roots?
	getEClassRoots(tg : TypeGraph) -> Set<int>;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// Is there an equivalence class for this type? -1 is not
	findEClass(tg : TypeGraph, type : TType) -> int;

	unifyTypeToEClass(tg : TypeGraph, eclass : int, type : TType, reasons : [string], pos : [int]) -> void;

	// After setting up all the relations, calls resolveEClasses from resolve.flow
	// which will populate the etypes in the TTypeEnv
}

makeTypeGraph(onError : (int, string) -> void) -> TypeGraph {
	TypeGraph(
		makeUnionFindMap(defaultTTypeNode(), mergeTTypeNodes),
		makeTree(),
		ref 0,
		onError
	)
}

emptyTTypeClass(tg : TypeGraph) -> int {
	ec = ^(tg.nextEClass);
	tg.nextEClass := ec + 1;
	ec;
}

getEClassRoots(tg : TypeGraph) -> Set<int> {
	roots = getUnionMapRoots(tg.umap);
	filterSet(roots, \r -> {
		r < ^(tg.nextEClass)
	})
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	findUnionMapRoot(tg.umap, eclass)
}

findEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): eclass;
		default: {
			findUnionMap(tg.umap, \i, val : TTypeNode -> {
				c = containsNodeTType(tg, val, type);
				// println(i2s(i) + " has " + prettyTType(type) + " is " + b2s(c));
				c;
			}, -1)
		}
	}
}

// Does this eclass contain this type?
containsEClassTType(tg : TypeGraph, eclass : int, type : TType) -> bool {
	node = getUnionMapValue(tg.umap, eclass);
	containsNodeTType(tg, node, type)
}

// Does this type node contain this type?
containsNodeTType(tg : TypeGraph, node : TTypeNode, type : TType) -> bool {
	containsSet(node.originals, type)
	|| switch (type) {
		TTypeName(id, typars): {
			containsNodeTTypes(tg, 0, node.best, type);
		}
		TTypeEClass(eclass): {
			println("Not supposed to happen");
			false;
		}
		TTypeFunction(args, returnType): {
			containsNodeTTypes(tg, 0, node.best, type);
		}
		TTypeOverload(unique, overloads): {
			switch (node.overload) {
				None(): false;
				Some(no): no.unique == unique;
			}
		}
		TTypeSupertype(unique, subtypes, maxed): {
			switch (node.supertype) {
				None(): false;
				Some(st): {
					st.unique == unique;
				}
			}
		}
	}
}

containsNodeTTypes(tg : TypeGraph, i : int, types : [TType], type : TType) -> bool {
	if (i < length(types)) {
		type1 = types[i];
		if (isSameTType(tg, type1, type)) {
			true
		} else {
			containsNodeTTypes(tg, i + 1, types, type)
		}
	} else {
		false;
	}
}

isSameTType(tg : TypeGraph, left : TType, right : TType) -> bool {
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): lid == rid && areSameTTypes(tg, ltypars, rtypars);
				TTypeEClass(eclass): containsEClassTType(tg, eclass, left);
				default: false;
			}
		}
		TTypeEClass(lclass): {
			switch (right) {
				TTypeEClass(rclass): {
					lroot = rootTTypeEClass(tg, lclass);
					rroot = rootTTypeEClass(tg, rclass);
					lroot == rroot;
				}
				default: {
					containsEClassTType(tg, lclass, right);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					areSameTTypes(tg, largs, rargs)
					&& isSameTType(tg, lreturnType, rreturnType);
				}
				TTypeEClass(eclass): containsEClassTType(tg, eclass, left);
				default: false;
			}
		}
		TTypeOverload(lunique, loverloads): {
			switch (right) {
				TTypeOverload(runique, roverloads): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, eclass, left);
				default: false;
			}
		}
		TTypeSupertype(lunique, lsubtypes, lmaxed): {
			switch (right) {
				TTypeSupertype(runique, rsubtypes, rmaxed): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, eclass, left);
				default: false;
			}
		}
	}
}

areSameTTypes(tg : TypeGraph, left : [TType], right : [TType]) -> bool {
	length(left) == length(right)
	&& forall(mapi(left, \i, l -> isSameTType(tg, l, right[i])), idfn)
}

unifyTypeToEClass(tg : TypeGraph, eclass : int, type : TType, reasons : [string], pos : [int]) -> void {
	typeclass = findEClass(tg, type);
	if (typeclass == -1) {
		node1 = getUnionMapValue(tg.umap, eclass);
		node2 = makeTTypeNode(type, reasons, pos);
		node = mergeTTypeNodes(node1, node2);
		setUnionMapValue(tg.umap, eclass, node);
	} else {
		unionUnionMap(tg.umap, eclass, typeclass);
		{}
	}
}
