import plow/types/pretty;
import plow/types/ugraph/type;
import plow/types/ugraph/tnode;
import ds/treeutils;

export {
	// Construct a new graph of our types
	makeTypeGraph(
		onError : (int, string) -> void, nextEClass : ref int
	) -> TypeGraph;

	setTypeGraphResolver(
		t : TypeGraph,
		resolveSupertypes : (string) -> [string], 
	) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// What type node do we have for this equivalence class?
	getEClassTypeNode(tg : TypeGraph, eclass : int) -> TTypeNode;

	// Set the type node for this eq. class
	setEClassTypeNode(tg : TypeGraph, eclass : int, tn : TTypeNode) -> void;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// What is the current set of root equivalence classes?
	getEClassRoots(tg : TypeGraph) -> Set<int>;

	// Is there an equivalence class for this type? -1 is not
	findEClass(tg : TypeGraph, type : TType) -> int;

	// Find or make an eclass for this type. Ensures the class contains this type
	makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass;

	// Make sure this eclass contains this given type
	addTType2EClass(tg : TypeGraph, reasons: [string], pos : [int], eclass : int, type : TType) -> TTypeEClass;

	// Mark these as the same class
	joinTTypeEClasses(tg : TypeGraph, class1 : int, class2 : int) -> int;

	// Normalize dependencies
	normalizeTTypeDependencies(tg : TypeGraph) -> void;
}

makeTypeGraph(
		onError : (int, string) -> void, 
		nextEClass : ref int
	) -> TypeGraph {
	TypeGraph(
		makeUnionFindMap(defaultTTypeNode(), mergeTTypeNodes),
		nextEClass,
		ref makeSet(),
		ref makeTree(),
		makeTMap(\n -> {println("TODO: Updating the resolver"); []}, onError, nextEClass),
		onError
	)
}

setTypeGraphResolver(
	t : TypeGraph,
	resolveSupertypes : (string) -> [string], 
) -> TypeGraph {
	TypeGraph(t with tmap = TMap(t.tmap with resolveSupertypes = resolveSupertypes));
}


emptyTTypeClass(tg : TypeGraph) -> int {
	ec = ^(tg.nextEClass);
	tg.nextEClass := ec + 1;
	ec;
}

getEClassTypeNode(tg : TypeGraph, eclass : int) -> TTypeNode {
	getUnionMapValue(tg.umap, eclass);
}

setEClassTypeNode(tg : TypeGraph, eclass : int, tn : TTypeNode) -> void {
	tg.updated := insertSet(^(tg.updated), eclass);
	updateTTypeNodeDependencies(tg, eclass, tn);
	setUnionMapValue(tg.umap, eclass, tn)
}

getEClassRoots(tg : TypeGraph) -> Set<int> {
	roots = getUnionMapRoots(tg.umap);
	filterSet(roots, \r -> {
		r < ^(tg.nextEClass)
	})
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	if (true) {
		findUnionMapRoot(tg.tmap.tmap, eclass)
	} else {
		findUnionMapRoot(tg.umap, eclass)
	}
}

findEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tg.umap, eclass);
		}
		default: {
			findUnionMap(tg.umap, \i, val : TTypeNode -> {
				c = containsNodeTType(tg, ref makeSet(), val, type);
				// println(i2s(i) + " has " + prettyTType(type) + " is " + b2s(c));
				c;
			}, -1)
		}
	}
}

// Does this eclass contain this type?
containsEClassTType(tg : TypeGraph, visited : ref Set<int>, eclass : int, type : TType) -> bool {
	if (containsSet(^visited, eclass)) false
	else {
		node = getUnionMapValue(tg.umap, eclass);
		visited := insertSet(^visited, eclass);
		containsNodeTType(tg, visited, node, type)
	}
}

// Does this type node contain this type?
containsNodeTType(tg : TypeGraph, visited : ref Set<int>, node : TTypeNode, type : TType) -> bool {
	containsSet(node.originals, type)
	|| switch (type) {
		TTypeName(id, typars): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeEClass(eclass): {
			println("Not supposed to happen");
			false;
		}
		TTypeFunction(args, returnType): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeOverload(unique, overloads): {
			switch (node.overload) {
				None(): false;
				Some(no): no.unique == unique;
			}
		}
		TTypeSupertype(unique, subtypes, maxed): {
			switch (node.supertype) {
				None(): false;
				Some(st): {
					st.unique == unique
					|| forall(subtypes, \ss -> {
						containsNodeTTypes(tg, visited, 0, st.subtypes, ss)
					});
				}
			}
		}
	}
}

containsNodeTTypes(tg : TypeGraph, visited : ref Set<int>, i : int, types : [TType], type : TType) -> bool {
	if (i < length(types)) {
		type1 = types[i];
		if (isSameTType(tg, visited, type1, type)) {
			true
		} else {
			containsNodeTTypes(tg, visited, i + 1, types, type)
		}
	} else {
		false;
	}
}

isSameTType(tg : TypeGraph, visited : ref Set<int>, left : TType, right : TType) -> bool {
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): lid == rid && areSameTTypes(tg, visited, ltypars, rtypars);
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeEClass(lclass): {
			switch (right) {
				TTypeEClass(rclass): {
					lroot = rootTTypeEClass(tg, lclass);
					rroot = rootTTypeEClass(tg, rclass);
					lroot == rroot;
				}
				default: {
					containsEClassTType(tg, visited, lclass, right);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					areSameTTypes(tg, visited, largs, rargs)
					&& isSameTType(tg, visited, lreturnType, rreturnType);
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeOverload(lunique, loverloads): {
			switch (right) {
				TTypeOverload(runique, roverloads): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeSupertype(lunique, lsubtypes, lmaxed): {
			switch (right) {
				TTypeSupertype(runique, rsubtypes, rmaxed): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
	}
}

areSameTTypes(tg : TypeGraph, visited : ref Set<int>, left : [TType], right : [TType]) -> bool {
	length(left) == length(right)
	&& forall(mapi(left, \i, l -> isSameTType(tg, visited, l, right[i])), idfn)
}


// Rewrite a type to use as many eclasses as possible
makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass {
	typeclass = findEClass(tg, type);
	class = if (typeclass == -1) {
		emptyTTypeClass(tg);
	} else {
		typeclass;
	}
	addTType2EClass(tg, reasons, pos, class, type);
}

addTType2EClass(tg : TypeGraph, reasons: [string], pos : [int], eclass : int, type : TType) -> TTypeEClass {
	rec = \tt -> makeTTypeEClass(tg, reasons, pos, tt);
	set = \tt -> {
		node = makeTTypeNode(tt, reasons, pos);
		enode = getUnionMapValue(tg.umap, eclass);
		fnode = mergeTTypeNodes(enode, node);
		// println("Updated e" + i2s(eclass) + " to " + toString(fnode));
		setEClassTypeNode(tg, eclass, fnode);
		TTypeEClass(eclass);
	}
	switch (type) {
		TTypeName(id, typars): {
			set(TTypeName(id, map(typars, rec)));
		}
		TTypeEClass(teclass): {
			// OK, I guess we have to merge these nodes.
			root = rootTTypeEClass(tg, teclass);
			if (root != eclass) {
				// Join these guys and give the new node
				rclass = unionUnionMap(tg.umap, root, eclass);
				tg.updated := insertSet(^(tg.updated), rclass);
				TTypeEClass(rclass);
			} else {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): {
			set(TTypeFunction(map(args, rec), rec(returnType)));
		}
		TTypeOverload(unique, overloads): {
			set(type);
		}
		TTypeSupertype(unique, subtypes, maxed): {
			set(type);
		}
	}
}

joinTTypeEClasses(tg : TypeGraph, class1 : int, class2 : int) -> int {
	root = unionUnionMap(tg.umap, class1, class2);
	tg.updated := insertSet(^(tg.updated), root);
	// TODO: We could normalize the dep. graph, but does it matter?
	root;
}

updateTTypeNodeDependencies(tg : TypeGraph, eclass : int, type : TTypeNode) -> void {
	update = \tt -> {
		updateTTypeDependencies(tg, eclass, tt)
	};
	iter(type.best, update);
	switch (type.overload) {
		None(): {}
		Some(ov): update(ov);
	}
	switch (type.supertype) {
		None(): {}
		Some(st): update(st);
	}
}

updateTTypeDependencies(tg : TypeGraph, eclass : int, type : TType) -> void {
	rec = \tt -> {
		childClass = switch (tt) {
			TTypeEClass(tclass): rootTTypeEClass(tg, tclass);
			default: findEClass(tg, tt);
		}
		if (childClass != -1) {
			tg.dependencies := insertMultimap(^(tg.dependencies), eclass, childClass);
		}
	}
	switch (type) {
		TTypeName(id, typars): iter(typars, rec);
		TTypeEClass(__): {}
		TTypeFunction(args, returnType): {
			iter(args, rec);
			rec(returnType);
		}
		TTypeOverload(unique, overloads): {
			iter(overloads, rec);
		}
		TTypeSupertype(unique, subtypes, maxed): {
			iter(subtypes, rec);
		}
	}
}

normalizeTTypeDependencies(tg : TypeGraph) -> void {
	roots = getEClassRoots(tg);
	ndeps = foldTree(^(tg.dependencies), makeTree(), \eclass : int, deps1 : Set<int>, acc -> {
		// OK, is there a new class for this one?
		root = rootTTypeEClass(tg, eclass);
		deps2 = lookupMultimap(acc, root);
		deps3 = mergeSets(deps1, deps2);
		deps4 = mapSet(deps3, \d -> rootTTypeEClass(tg, d));
		setTree(acc, root, deps4);
	});
	tg.dependencies := ndeps;
}
