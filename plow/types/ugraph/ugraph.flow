import plow/types/pretty;
import plow/types/ugraph/type;

export {
	// Construct a new graph of our types
	makeTypeGraph(onError : (int, string) -> void) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// What type node do we have for this equivalence class?
	getEClassTypeNode(tg : TypeGraph, eclass : int) -> TTypeNode;

	// Set the type node for this eq. class
	setEClassTypeNode(tg : TypeGraph, eclass : int, tn : TTypeNode) -> void;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// What is the current set of root equivalence classes?
	getEClassRoots(tg : TypeGraph) -> Set<int>;

	// Is there an equivalence class for this type? -1 is not
	findEClass(tg : TypeGraph, type : TType) -> int;

	// Find or make an eclass for this type. Ensures the class contains this type
	makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass;

	// Make sure this eclass contains this given type
	addTType2EClass(tg : TypeGraph, reasons: [string], pos : [int], eclass : int, type : TType) -> TTypeEClass;

	// Mark these as the same class
	joinTTypeEClasses(tg : TypeGraph, class1 : int, class2 : int) -> int;
}

makeTypeGraph(onError : (int, string) -> void) -> TypeGraph {
	TypeGraph(
		makeUnionFindMap(defaultTTypeNode(), mergeTTypeNodes),
		ref 0,
		ref makeSet(),
		onError
	)
}

emptyTTypeClass(tg : TypeGraph) -> int {
	ec = ^(tg.nextEClass);
	tg.nextEClass := ec + 1;
	ec;
}

getEClassTypeNode(tg : TypeGraph, eclass : int) -> TTypeNode {
	getUnionMapValue(tg.umap, eclass);
}

setEClassTypeNode(tg : TypeGraph, eclass : int, tn : TTypeNode) -> void {
	tg.updated := insertSet(^(tg.updated), eclass);
	setUnionMapValue(tg.umap, eclass, tn)
}

getEClassRoots(tg : TypeGraph) -> Set<int> {
	roots = getUnionMapRoots(tg.umap);
	filterSet(roots, \r -> {
		r < ^(tg.nextEClass)
	})
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	findUnionMapRoot(tg.umap, eclass)
}

findEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): {
			findUnionMapRoot(tg.umap, eclass);
		}
		default: {
			findUnionMap(tg.umap, \i, val : TTypeNode -> {
				c = containsNodeTType(tg, ref makeSet(), val, type);
				// println(i2s(i) + " has " + prettyTType(type) + " is " + b2s(c));
				c;
			}, -1)
		}
	}
}

// Does this eclass contain this type?
containsEClassTType(tg : TypeGraph, visited : ref Set<int>, eclass : int, type : TType) -> bool {
	if (containsSet(^visited, eclass)) false
	else {
		node = getUnionMapValue(tg.umap, eclass);
		visited := insertSet(^visited, eclass);
		containsNodeTType(tg, visited, node, type)
	}
}

// Does this type node contain this type?
containsNodeTType(tg : TypeGraph, visited : ref Set<int>, node : TTypeNode, type : TType) -> bool {
	containsSet(node.originals, type)
	|| switch (type) {
		TTypeName(id, typars): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeEClass(eclass): {
			println("Not supposed to happen");
			false;
		}
		TTypeFunction(args, returnType): {
			containsNodeTTypes(tg, visited, 0, node.best, type);
		}
		TTypeOverload(unique, overloads): {
			switch (node.overload) {
				None(): false;
				Some(no): no.unique == unique;
			}
		}
		TTypeSupertype(unique, subtypes, maxed): {
			switch (node.supertype) {
				None(): false;
				Some(st): {
					st.unique == unique;
				}
			}
		}
	}
}

containsNodeTTypes(tg : TypeGraph, visited : ref Set<int>, i : int, types : [TType], type : TType) -> bool {
	if (i < length(types)) {
		type1 = types[i];
		if (isSameTType(tg, visited, type1, type)) {
			true
		} else {
			containsNodeTTypes(tg, visited, i + 1, types, type)
		}
	} else {
		false;
	}
}

isSameTType(tg : TypeGraph, visited : ref Set<int>, left : TType, right : TType) -> bool {
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): lid == rid && areSameTTypes(tg, visited, ltypars, rtypars);
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeEClass(lclass): {
			switch (right) {
				TTypeEClass(rclass): {
					lroot = rootTTypeEClass(tg, lclass);
					rroot = rootTTypeEClass(tg, rclass);
					lroot == rroot;
				}
				default: {
					containsEClassTType(tg, visited, lclass, right);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					areSameTTypes(tg, visited, largs, rargs)
					&& isSameTType(tg, visited, lreturnType, rreturnType);
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeOverload(lunique, loverloads): {
			switch (right) {
				TTypeOverload(runique, roverloads): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
		TTypeSupertype(lunique, lsubtypes, lmaxed): {
			switch (right) {
				TTypeSupertype(runique, rsubtypes, rmaxed): {
					lunique == runique;
				}
				TTypeEClass(eclass): containsEClassTType(tg, visited, eclass, left);
				default: false;
			}
		}
	}
}

areSameTTypes(tg : TypeGraph, visited : ref Set<int>, left : [TType], right : [TType]) -> bool {
	length(left) == length(right)
	&& forall(mapi(left, \i, l -> isSameTType(tg, visited, l, right[i])), idfn)
}


// Rewrite a type to use as many eclasses as possible
makeTTypeEClass(tg : TypeGraph, reasons: [string], pos : [int], type : TType) -> TTypeEClass {
	typeclass = findEClass(tg, type);
	class = if (typeclass == -1) {
		emptyTTypeClass(tg);
	} else {
		typeclass;
	}
	addTType2EClass(tg, reasons, pos, class, type);
}

addTType2EClass(tg : TypeGraph, reasons: [string], pos : [int], eclass : int, type : TType) -> TTypeEClass {
	rec = \tt -> makeTTypeEClass(tg, reasons, pos, tt);
	set = \tt -> {
		node = makeTTypeNode(tt, reasons, pos);
		enode = getUnionMapValue(tg.umap, eclass);
		fnode = mergeTTypeNodes(enode, node);
		// println("Updated e" + i2s(eclass) + " to " + toString(fnode));
		tg.updated := insertSet(^(tg.updated), eclass);
		setUnionMapValue(tg.umap, eclass, fnode);
		TTypeEClass(eclass);
	}
	switch (type) {
		TTypeName(id, typars): {
			set(TTypeName(id, map(typars, rec)));
		}
		TTypeEClass(teclass): {
			// OK, I guess we have to merge these nodes.
			root = rootTTypeEClass(tg, teclass);
			if (root != eclass) {
				// Join these guys and give the new node
				rclass = unionUnionMap(tg.umap, root, eclass);
				tg.updated := insertSet(^(tg.updated), rclass);
				TTypeEClass(rclass);
			} else {
				TTypeEClass(root);
			}
		}
		TTypeFunction(args, returnType): {
			set(TTypeFunction(map(args, rec), rec(returnType)));
		}
		TTypeOverload(unique, overloads): {
			set(type);
		}
		TTypeSupertype(unique, subtypes, maxed): {
			set(type);
		}
	}
}

joinTTypeEClasses(tg : TypeGraph, class1 : int, class2 : int) -> int {
	root = unionUnionMap(tg.umap, class1, class2);
	tg.updated := insertSet(^(tg.updated), root);
	root;
}
