import plow/types/pretty;
import plow/types/ugraph/typenode;
import ds/union_find_map;

export {
	makeTypeGraph(onError : (int, string) -> void) -> TypeGraph;

	// Prepare an empty equivalence class
	emptyTTypeClass(tg : TypeGraph) -> int;

	// Get the (or construct a) type equivalence class for this type
	makeTTypeEClass(tg : TypeGraph, type : TType) -> int;

	// What is the current set of roots?
	getEClassRoots(tg : TypeGraph) -> Set<int>;

	// Given this eclass, what is the root equivalence class?
	rootTTypeEClass(tg : TypeGraph, eclass : int) -> int;

	// Join these two types into the same equivalence class
	unifyTTypeEClass(tg : TypeGraph, pos : int, left : TType, right : TType) -> int;

	// After setting up all the relations, calls resolveEClasses from resolve.flow
	// which will populate the etypes in the TTypeEnv

	TypeGraph(
		umap : UnionFindMap<TTypeNode>,
		// What eclass does this node belong to?
		mutable memo : Tree<TTypeNode, int>,
		nextEClass : ref int, 
		onError : (int, string) -> void,
	);
}

makeTypeGraph(onError : (int, string) -> void) -> TypeGraph {
	TypeGraph(
		makeUnionFindMap(defaultTTypeNode(), mergeTTypeNodes),
		makeTree(),
		ref 0,
		onError
	)
}

emptyTTypeClass(tg : TypeGraph) -> int {
	ec = ^(tg.nextEClass);
	tg.nextEClass := ec + 1;
	ec;
}

makeTTypeEClass(tg : TypeGraph, type : TType) -> int {
	switch (type) {
		TTypeEClass(eclass): findUnionMapRoot(tg.umap, eclass);
		default: {
			typenode = canonicalTypeNode(tg, makeTTypeNode(type));
			mid = lookupTree(tg.memo, typenode);
			mid ?? {
				root = findUnionMapRoot(tg.umap, mid);
				if (root != mid) {
					tg.memo ::= setTree(tg.memo, typenode, root);
				}
				root
			} : {
				// OK, go look for it
				eclass = emptyTTypeClass(tg);
				setUnionMapValue(tg.umap, eclass, typenode);
				tg.memo ::= setTree(tg.memo, typenode, eclass);
				eclass;
			}
		}
	}
}

getEClassRoots(tg : TypeGraph) -> Set<int> {
	roots = getUnionMapRoots(tg.umap);
	filterSet(roots, \r -> {
		r < ^(tg.nextEClass)
	})
}

canonicalTypeNode(tg : TypeGraph, tn : TTypeNode) -> TTypeNode {
	TTypeNode(
		sortUnique(map(tn.best, \t -> canonicalTType(tg, t))),
		tn.overload,
		tn.supertypeUnique,
		sortUnique(map(tn.supertypes, \t -> canonicalTType(tg, t))),
	)
}

canonicalTType(tg : TypeGraph, t : TType) -> TType {
	rec = \tt -> canonicalTType(tg, tt);
	switch (t) {
		TTypeName(id, typars): TTypeName(id, map(typars, rec));
		TTypeEClass(eclass): TTypeEClass(rootTTypeEClass(tg, eclass));
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(unique, overloads): TTypeOverload(unique, sortUnique(map(overloads, rec)));
		TTypeSupertype(unique, subtypes): TTypeSupertype(unique, sortUnique(map(subtypes, rec)));
	}
}

rootTTypeEClass(tg : TypeGraph, eclass : int) -> int {
	findUnionMapRoot(tg.umap, eclass)
}

unifyTTypeEClass(tg : TypeGraph, pos : int, left : TType, right : TType) -> int {
	lroot = makeTTypeEClass(tg, left);
	rroot = makeTTypeEClass(tg, right);
	if (lroot != rroot) {
		root = unionUnionMap(tg.umap, lroot, rroot);
		if (false) {
			tg.onError(pos, "Unify " + prettyTType(left) + " and " + prettyTType(right) + " (class " + i2s(lroot) + " and " + i2s(rroot) + " into eclass " + i2s(root) + ")");
		}
		root;
	} else {
		if (false) {
			tg.onError(pos, "Unify " + prettyTType(left) + " and " + prettyTType(right) + " (class " + i2s(lroot) + ")");
		}
		lroot;
	}
}
