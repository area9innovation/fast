import ds/union_find_map;
import plow/types/ugraph/typenode;
import plow/dexp/dexp;

export {
	// TODO: Add a dependency graph between equivalence
	// classes. If a loop forms, the nodes should collapse
	// This dep. graph should be used to propagate updates
	// to the classes
	TypeGraph(
		// The union/find map of typenodes for each equivalence class
		umap : UnionFindMap<TTypeNode>,
		// What is the id of the next eclass?
		nextEClass : ref int, 
		// What eclasses have been updated?
		updated : ref Set<int>,
		// Dependencies between eclasses: When key changes, the immediate 
		// children need an update
		dependencies : ref Tree<int, Set<int>>,

		// The new system:

		// The union/find map of tnodes for each equivalence class
		tmap : TMap,

		// To help report errors, we have this friend
		onError : (int, string) -> void,
	);

	TMap(
		tmap : UnionFindMap<TNode>,
		resolveUnionName : ref (string) -> Maybe<DUnion>,
		resolveSupertypes : ref (string) -> [string],
		onError : (int, string) -> void,
		nextEClass : ref int,
	);

	TNode ::= TNodeName, TNodeOverload, TNodeSupertype;
		// If the name is empty, it is a function. If name is empty, and typars empty, null
		TNodeName(name : string, typars : [int]);
		TNodeOverload(unique : Set<int>, overloads : [TNodeName]);
		TNodeSupertype(
			uniques : Set<int>, 
			subtypes : [TNodeName],
//			unknownSubtypes : Set<int>,
		);
}
