import plow/types/typeenv;
import plow/types/util;
import plow/types/pretty;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(env : TTypeEnv) -> Tree<int, TType>;
}

extractEClassTypes(env : TTypeEnv) -> Tree<int, TType> {
	egraph = env.egraph;
	extract = extractEGraph(egraph, calculateTTypeBenefit);
	extractTTypes(ExtractEnv(env, extract, ref makeTree()));
}

ExtractEnv(
	env : TTypeEnv,
	benefits : Tree<int, EClassBenefit<TType>>,
	// Types we already have extracted
	etypes : ref Tree<int, TType>,
);

extractTTypes(env : ExtractEnv) -> Tree<int, TType> {
	foldTree(env.benefits, makeTree(), \eclass, ebenefit, acc -> {
		mtype = extractTType(env, eclass);
		mtype ?? {
			// println(i2s(eclass) + " = " + prettyTType(mtype) + " at benefit " + toString(ebenefit.benefit));
			setTree(acc, eclass, mtype)
		} : {
			println("Could not extract type from " + ttypeENode2string(ebenefit.node) + " with eclass " + i2s(eclass));
			acc;
		}
	});
}

extractTType(env : ExtractEnv, eclass : int) -> Maybe<TType> {
	mexist = lookupTree(^(env.etypes), eclass);
	mexist ?? {
		Some(mexist)
	} : {
		set = \tt -> {
			env.etypes := setTree(^(env.etypes), eclass, tt);
			Some(tt);
		}
		// TODO: If we already extracted this, no need to do it again
		mbenefit = lookupTree(env.benefits, eclass);
		mbenefit ?? {
			enode = mbenefit.node;

			extractChildren = \ -> {
				filtermap(enode.args, \root : int -> {
					if (root == eclass) None()
					else extractTType(env, root)
				});			
			};

			switch (enode.head : TType) {
				TTypeVar(id): {
					Some(enode.head);
				}
				TTypeName(id, __): {
					mtypars = extractChildren();
					if (length(mtypars) == length(enode.args)) {
						set(TTypeName(id, mtypars));
					} else {
						None();
					}
				}
				TTypeFunction(__, __): {
					children : [TType] = extractChildren();
					// The last child is the return type
					n = length(children);
					if (n != length(enode.args)) {
						None();
					} else {
						set(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
					}
				}
				TTypeOverload(typar, __): {
					children : [TType] = extractChildren();
					if (length(children) != length(enode.args)) {
						None()
					} else {
						set(TTypeOverload(typar, buildSet(children)));
					}
				}
				TTypeSupertype(typar, __): {
					children : [TType] = extractChildren();
					if (length(children) != length(enode.args)) {
						None();
					} else {
						cset = buildSet(children);
						if (children == []) {
							None();
						} else {
							set(TTypeSupertype(typar, cset));
						}
					}
				}
			}
		} : {
			println("Have no benefits for " + i2s(eclass));
			None()
		}
	}
}

calculateTTypeBenefit(e : ENode<TType>, childbenefits : [EClassBenefit<TType>]) -> EClassBenefit<TType> {
	benefits = map(childbenefits, \cc -> cc.benefit);
	cbenefits = sum(benefits);
	switch (e.head) {
		TTypeName(id, typars): {
			if (id == "flow") EClassBenefit(5, e)
			else EClassBenefit(10 + cbenefits, e);
		}
		TTypeVar(id): EClassBenefit(0, e);	// No benefit from these
		TTypeFunction(args, returnType): EClassBenefit(10 + cbenefits, e);
		TTypeOverload(unique, overloads): {
			// We do not want these that much
			EClassBenefit(1 + cbenefits, e);
		}
		TTypeSupertype(unique, subtypes): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
	}
}
