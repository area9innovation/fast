import plow/types/typeenv;
import plow/types/util;
import plow/types/pretty;
import plow/types/supertype;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(env : TTypeEnv) -> Tree<int, TType>;
	containsTTypeClass(t : TType) -> bool;
}

extractEClassTypes(env : TTypeEnv) -> Tree<int, TType> {
	egraph = env.egraph;
	extract = extractEGraph(egraph, calculateTTypeBenefit);
	extractTTypes(ExtractEnv(env, extract, ref makeTree()));
}

ExtractEnv(
	env : TTypeEnv,
	benefits : Tree<int, EClassBenefit<TType>>,
	// Types we already have extracted
	etypes : ref Tree<int, TType>,
);

extractTTypes(env : ExtractEnv) -> Tree<int, TType> {
	traverseInOrder(env.benefits, \eclass, ebenefit -> {
		type = extractTType(env, eclass);
	});
	^(env.etypes)
}

extractTType(env : ExtractEnv, eclass : int) -> TType {
	mexist = lookupTree(^(env.etypes), eclass);
	mexist ?? {
		mexist
	} : {
		set = \tt -> {
			env.etypes := setTree(^(env.etypes), eclass, tt);
			tt;
		}
		mbenefit = lookupTree(env.benefits, eclass);
		mbenefit ?? {
			enode = mbenefit.node;
			extractChildren = \ -> {
				map(enode.args, \root : int -> {
					if (root == eclass) TTypeEClass(eclass)
					else extractTType(env, root)
				});			
			};

			switch (enode.head : TType) {
				TTypeEClass(id): {
					enode.head;
				}
				TTypeName(id, __): {
					typars = extractChildren();
					set(TTypeName(id, typars));
				}
				TTypeFunction(__, __): {
					children : [TType] = extractChildren();
					// The last child is the return type
					n = length(children);
					set(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
				}
				TTypeOverload(typar, __): {
					children : [TType] = extractChildren();
					cset = buildSet(children);
					set(TTypeOverload(typar, buildSet(children)));
				}
				TTypeSupertype(typar, __): {
					children : [TType] = extractChildren();
					cset = buildSet(children);
					super = TTypeSupertype(typar, cset);
					set(resolveTSupertype(env.env, super));
				}
			}
		} : {
			TTypeEClass(eclass);
		}
	}
}

calculateTTypeBenefit(e : ENode<TType>, childbenefits : [EClassBenefit<TType>]) -> EClassBenefit<TType> {
	benefits = map(childbenefits, \cc -> cc.benefit);
	cbenefits = sum(benefits);
	switch (e.head) {
		TTypeName(id, typars): {
			if (id == "flow") EClassBenefit(5, e)
			else EClassBenefit(10 + cbenefits, e);
		}
		TTypeEClass(id): EClassBenefit(0, e);	// No benefit from these
		TTypeFunction(args, returnType): EClassBenefit(5 + cbenefits, e);
		TTypeOverload(unique, overloads): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
		TTypeSupertype(unique, subtypes): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
	}
}

containsTTypeClass(t : TType) -> bool {
	switch (t) {
		TTypeName(id, typars): exists(typars, containsTTypeClass);
		TTypeEClass(eclass): true;
		TTypeFunction(args, returnType): exists(args, containsTTypeClass) || containsTTypeClass(returnType);
		TTypeOverload(unique, overloads): existsSet(overloads, containsTTypeClass);
		TTypeSupertype(unique, subtypes): existsSet(subtypes, containsTTypeClass);
	}
}
