import plow/types/typeenv;
import plow/types/util;
import plow/types/pretty;
import math/math;
import ds/egraph_extract;

export {
	// Extracts the types of the eclass we can find
	extractEClassTypes(env : TTypeEnv) -> Tree<int, TType>;
}

extractEClassTypes(env : TTypeEnv) -> Tree<int, TType> {
	egraph = env.egraph;
	extract = extractEGraph(egraph, calculateTTypeBenefit);
	extractTTypes(env, extract);
}

extractTTypes(env : TTypeEnv, benefits : Tree<int, EClassBenefit<TType>>) -> Tree<int, TType> {
	foldTree(benefits, makeTree(), \eclass, ebenefit, acc -> {
		mtype = extractTType(env, benefits, eclass);
		mtype ?? {
			// println(i2s(eclass) + " = " + prettyTType(mtype) + " at benefit " + toString(ebenefit.benefit));
			setTree(acc, eclass, mtype)
		} : {
			println("Could not extract type from " + ttypeENode2string(ebenefit.node) + " with eclass " + i2s(eclass));
			acc;
		}
	});
}

extractTType(env : TTypeEnv, benefits : Tree<int, EClassBenefit<TType>>, eclass : int) -> Maybe<TType> {
	// TODO: If we already extracted this, no need to do it again

	mbenefit = lookupTree(benefits, eclass);
	mbenefit ?? {
		enode = mbenefit.node;
		switch (enode.head : TType) {
			TTypeVar(id): {
				Some(enode.head);
			}
			TTypeName(id, __): {
				mtypars = filtermap(enode.args, \root : int -> {
					extractTType(env, benefits, root)
				});
				if (length(mtypars) == length(enode.args)) {
					Some(TTypeName(id, mtypars));
				} else {
					None();
				}
			}
			TTypeFunction(__, __): {
				children : [TType] = filtermap(enode.args, \root -> extractTType(env, benefits, root));
				// The last child is the return type
				n = length(children);
				if (n != length(enode.args)) {
					None();
				} else {
					Some(TTypeFunction(subrange(children, 0, n - 1), children[n - 1]));
				}
			}
			TTypeOverload(typar, __): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(env, benefits, root);
				});
				if (length(children) != length(enode.args)) {
					None()
				} else {
					Some(TTypeOverload(typar, buildSet(children)));
				}
			}
			TTypeSupertype(typar, __): {
				children : [TType] = filtermap(enode.args, \root -> {
					extractTType(env, benefits, root);
				});
				if (length(children) != length(enode.args)) {
					None();
				} else {
					cset = buildSet(children);
					if (children == []) {
						println("No super found");
						Some(TTypeVar(env.mkTyvar()))
					} else if (sizeSet(cset) == 1) {
						Some(children[0]);
					} else {
						Some(TTypeSupertype(typar, cset));
					}
				}
			}
		}
	} : {
		println("Have no benefits for " + i2s(eclass));
		None()
	}
}

calculateTTypeBenefit(e : ENode<TType>, childbenefits : [EClassBenefit<TType>]) -> EClassBenefit<TType> {
	benefits = map(childbenefits, \cc -> cc.benefit);
	cbenefits = sum(benefits);
	switch (e.head) {
		TTypeName(id, typars): {
			if (id == "flow") EClassBenefit(5, e)
			else EClassBenefit(10 + cbenefits, e);
		}
		TTypeVar(id): EClassBenefit(0, e);	// No benefit from these
		TTypeFunction(args, returnType): EClassBenefit(10 + cbenefits, e);
		TTypeOverload(unique, overloads): {
			// We do not want these that much
			EClassBenefit(1 + cbenefits, e);
		}
		TTypeSupertype(unique, subtypes): {
			// We do not want these that much
			EClassBenefit(1, e);
		}
	}
}
