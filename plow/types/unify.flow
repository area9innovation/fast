import plow/types/pretty;
import plow/types/typeenv;
import ds/egraph_dot;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, left : TType, right : TType) -> void;

	// Structurally, transitively unify this recursive type against this class
	unifyEClassChildren(egraph : EGraph<TType>, eclass : int, type : TType) -> void;
}

unifyTType(env : TTypeEnv, left : TType, right : TType) -> void {
	//println("Unify " + prettyTType(left) + " and " + prettyTType(right));
	lroot = addEExp(env.egraph, left);
	rroot = addEExp(env.egraph, right);
	unionEClass(env.egraph, lroot, rroot);

	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, ltypars, rtypars);
					}
				}
				default: {}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, largs, rargs);
					unifyTType(env, lreturnType, rreturnType);
				}
				default: {}
			}
		}
		TTypeVar(lid): {}
		TTypeOverload(lunique, loverloads): {}
		TTypeSupertype(unique, subtypes): {}
	}
}

unifyTTypes(env : TTypeEnv, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, larg, right[i])
		});
	}
}

unifyEClassChildren(egraph : EGraph<TType>, eclass : int, type : TType) -> void {
	split = egraph.splitChildren(type);
	nodes = getEClassNodes(egraph, eclass);
	iterSet(nodes, \node -> {
		cnode = canonicalizeENode(egraph, node);
		// println("We have a match " + toString(cnode.head) + " to " + prettyTType(type));
		if (cnode.head == split.first && length(split.second) == length(cnode.args)) {
			iteri(split.second, \i, child -> {
				childClass = addEExp(egraph, child);
				unionEClass(egraph, childClass, cnode.args[i]);
				{}
			})
		}
	});
}
