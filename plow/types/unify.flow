import plow/types/pretty;
import plow/types/typeenv;
import plow/types/polymorphism;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, topid : string, reason : string, pos : int, left : TType, right : TType) -> void;

	// Unify this type into this eclass
	unifyTypeToEClass(env : TTypeEnv, eclass : int, type : TType, reasons : [string], pos : [int]) -> void;

	// Clean up this eclass
	clarifyEClass(env : TTypeEnv, eclass : int, merge : TTypeNode) -> void;

	possibleTTypeNodeMatch(env : TTypeEnv, node : TTypeNode, type : TType) -> bool;
}

uniindent = ref "";
unifyTType(env : TTypeEnv, topid : string, reason : string, pos : int, left : TType, right : TType) -> void {
	indent = ^uniindent;
	if (isTracingId(env.tracing, StageTypeInference(), 2, topid)) {
		println(indent + "Unify " + topid + ": " + prettyTType(left) + "   vs   " + prettyTType(right) + ". " + reason);
		uniindent :=indent + "  ";
	}
	// env.onError(pos, reason + " unify " + prettyTType(left) + " vs " + prettyTType(right));
	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, topid, pos, ltypars, rtypars);
					} else {
						unifyTTypeNames(env, reason, pos, left, right);
					}
				}
				TTypeEClass(eclass): {
					unifyTypeToEClass(env, eclass, left, [reason], [pos]);
				}
				TTypeFunction(args, returnType): {
					env.onError(pos, lid + " is not a function");
				}
				TTypeOverload(unique, overloads): {
					unifyTTypeOverload(env, topid, reason, pos, right, left);
				}
				TTypeSupertype(unique, subtypes, maxed): {
					unifyTSupertype(env, topid, reason, pos, right, left);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, topid, pos, largs, rargs);
					unifyTType(env, topid, "fn return", pos, lreturnType, rreturnType);
				}
				TTypeOverload(__, __): {
					unifyTTypeOverload(env, topid, reason, pos, right, left);
				}
				TTypeName(id, typars): {
					env.onError(pos, id + " is not a function " + prettyTType(left));
				}
				TTypeEClass(eclass): {
					// We know eclass is a function, which is recorded in the environment
					unifyTypeToEClass(env, eclass, left, [reason], [pos]);
				}
				TTypeSupertype(unique, subtypes, maxed): {
					unifyTSupertype(env, topid, reason, pos, right, left);
				}
			}
		}
		TTypeEClass(lid): {
			switch (right) {
				TTypeEClass(rid): {
					// OK, merge eclasses
					unifyEClasses(env, lid, rid);
				}
				TTypeName(id, typars): {
					unifyTypeToEClass(env, lid, right, [reason], [pos]);
				}
				TTypeFunction(args, returnType): {
					unifyTypeToEClass(env, lid, right, [reason], [pos]);
				}
				TTypeOverload(__, __): {
					unifyTTypeOverload(env, topid, reason, pos, right, left);
				}
				TTypeSupertype(unique, subtypes, maxed): {
					unifyTSupertype(env, topid, reason, pos, right, left);
				}
			}
		}
		TTypeOverload(lunique, loverloads): {
			switch (right) {
				TTypeEClass(eclass): {
					unifyTypeToEClass(env, eclass, left, [reason], [pos]);
				}
				default: {
					unifyTTypeOverload(env, topid, reason, pos, left, right);
				}
			}
		}
		TTypeSupertype(unique, subtypes, maxed): {
			switch (right) {
				TTypeEClass(eclass): {
					unifyTypeToEClass(env, eclass, left, [reason], [pos]);
				}
				default: {
					unifyTSupertype(env, topid, reason, pos, left, right);
				}
			}
		}
	}
	uniindent := indent;
}

unifyTTypeNames(env : TTypeEnv, reason : string, pos : int, left : TTypeName, right : TTypeName) {
	// TODO: This is correct if one is a union with exactly the other type in it
	// otherwise, it is a problem
	env.onError(pos, left.id + " and " + right.id + " are not compatible (TODO: Check if one is a single-struct union) " + reason);
}

unifyTTypeOverload(env : TTypeEnv, topid : string, reason : string, pos : int, overload : TTypeOverload, type : TType) -> void {
	good = if (true) filter(overload.overloads, \ol -> {
		possibleTTypeMatch(env, ol, type)
	}) else overload.overloads;
	n = length(good);
	if (n == 1) {
		// println("Resolved overload");
		winner = good[0];
		unifyTType(env, topid, "overload", pos, winner, type);
	} else {
		eoverload = TTypeOverload(overload with overloads = good);
		switch (type) {
			TTypeName(id, typars): {
				if (n == 0) {
					env.onError(pos, id + " can not be overloaded");
				} else {
					unifyTType2(env, reason, pos, eoverload, type);
				}
			}
			TTypeEClass(eclass): unifyTypeToEClass(env, eclass, eoverload, [reason], [pos]);
			TTypeFunction(args, returnType): {
				unifyTType2(env, reason, pos, eoverload, type);
			}
			TTypeOverload(unique, overloads): {
				println("TODO: Overload against overload");
			}
			TTypeSupertype(unique, subtypes, maxed): {
				unifyTType2(env, reason, pos, eoverload, type);
			}
		}
	}
}

unifyTTypes(env : TTypeEnv, topid : string, pos : int, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, topid, "types #" + i2s(i), pos, larg, right[i])
		});
	}
}

unifyTSupertype(env : TTypeEnv, topid : string, reason : string, pos : int, super : TTypeSupertype, type : TType) -> void {
	// println(^uniindent + "Super " + prettyTType(super) + "   vs   " + prettyTType(type) + ". " + reason);
	iter(super.subtypes, \st -> {
		subtypeUnifyTType(env, topid, pos, st, type);
	});
	// OK, another thing we can do is to unify identical supertype typepars:
	
	// unify(super(Maybe<t1>, Maybe<t2>), type<t1>)
	// -> unify(super(Maybe<super(t1, t2)>), type)
/*	named : Tree<string, [TTypeName]> = fold(super.subtypes, makeTree(), \acc, st -> {
		switch (st) {
			TTypeName(id, tps): treePushToArrayValue(acc, id, st);
			default: acc;
		}
	});
	traverseInOrder(named, \name, tns : [TTypeName] -> {
		if (length(tns) > 1) {
			representative = tns[0];
			typars = mapi(representative.typars, \i, __ -> {
				// println("Making a new supertype here");
				TTypeSupertype(env.mkUnique(), map(tns, \tn -> tn.typars[i]), super.maxed);
			});
			stype = TTypeSupertype(super with subtypes = [
				TTypeName(representative with typars = typars)
			]);
			unifyTType(env, topid, "intrasupers " + name, pos, stype, type)
		}
	});
*/
	switch (type) {
		TTypeEClass(eclass): unifyTypeToEClass(env, eclass, super, [reason], [pos]);
		TTypeName(id, typars): {
			// List<?> vs supertype1{e25}
			eclass = findEClass(env.tgraph, type);
			superclass = if (eclass == -1) {
				// Have to make a new class
				sclass = findEClass(env.tgraph, super);
				if (sclass == -1) {
					println("We do not have a class for " + prettyTType(type) + " nor " + prettyTType(super));
					supertype : TTypeEClass = makeTTypeEClass(env.tgraph, [reason], [pos], super);
					supertype.eclass;
				} else sclass;
			} else eclass;

			// In this case, we do a
			// overload(List<?>, Cons<?>, EmptyList<?>) vs into the eclass with the supertype1{e25}
			subs = env.resolveSubtypes(id);
			munion = env.resolveUnionName(id);
			munion ?? {
				// OK, we can not decide, so set up an overload
				overloads = arrayPush(filtermap(subs, \su -> {
					instantiateTTypeNameFromUnion(env, munion, type, su);
				}), type);
				if (length(overloads) == 1) {
					// println("Found a super");
					unifyTypeToEClass(env, superclass, overloads[0], ["super resolved"], [pos]);
				} else {
					overload = TTypeOverload(TTypeEClass(superclass), overloads);
					// println("Adding overload to class " + i2s(superclass) + ": " + prettyTType(overload));
					unifyTypeToEClass(env, superclass, overload, ["super overload"], [pos]);
				}
			} : {
				// OK, not a supertype, so we can resolve immediately
				unifyTypeToEClass(env, superclass, type, ["super unique"], [pos]);
			}
		}
		TTypeFunction(args, returnType): {
			unifyTType2(env, reason, pos, super, type);
		}
		TTypeOverload(unique, overloads): env.onError(pos, "Supertype can not be overloaded");
		TTypeSupertype(unique, subtypes, maxed): unifyTType2(env, reason, pos, super, type);
	}
}


// Check that st is a subtype of type, and if so, unify any typars
subtypeUnifyTType(env : TTypeEnv, topid : string, pos : int, sub : TType, super : TType) -> void {
	// println(^uniindent + "Sub type " + prettyTType(sub) + " vs " + prettyTType(super));
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	};
	switch (sub) {
		TTypeName(subid, subtypars): {
			switch (super) {
				TTypeName(superid, supertypars): {
					subtypeTTypenames(env, topid, pos, sub, super);
				}
				TTypeEClass(id): {
					supers = env.resolveSupertypes(subid);
					if (supers == []) {
						// OK, there are no supers, so this has to be it
						unifyTType(env, topid, "unique super", pos, sub, super);
					}
				}
				TTypeSupertype(__, supers, maxed): {
					// This is probably true
					// TODO: We know subid and the supers are related by a common
					// supertype
				}
				TTypeFunction(args, returnType): error();
				TTypeOverload(unique, overloads): error();
			}
		}
		TTypeEClass(id): {
			switch (super) {
				TTypeName(superid, __): {
					subs = env.resolveSubtypes(superid);
					if (subs == []) {
						// OK, there are no subs, so this has to be it
					//	println(prettyTType(sub) + " vs " + prettyTType(super) + " unique");
						unifyTType(env, topid, "unique sub", pos, sub, super);
					}
				}
				TTypeEClass(__): {}
				TTypeFunction(args, returnType): {
					subfn = copyTTypeFunction(env, super);
					unifyTType(env, topid, "stub fn", pos, subfn, super)
				}
				TTypeOverload(unique, overloads): {
					iter(overloads, \s -> {
						switch (s) {
							TTypeFunction(__, __): {
								env.onError(pos, "TODO: We know 1 " + i2s(id) + " should be a function");
							}
							default: {}
						}
					});
				}
				TTypeSupertype(unique, subtypes, maxed): {
					stubfn = fold(subtypes, sub, \acc, s -> {
						if (acc != sub) acc
						else switch (s) {
							TTypeFunction(__, __): {
								copyTTypeFunction(env, s);
							}
							default: acc;
						}
					});
					if (stubfn != sub) {
						unifyTType(env, topid, "stub fn", pos, stubfn, super)
					}
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (super) {
				TTypeFunction(rargs, rreturnType): {
					if (length(largs) == length(rargs)) {
						// We reverse the polarity
						iteri(largs, \i, larg -> {
							subtypeUnifyTType(env, topid, pos, rargs[i], larg)
						});
						subtypeUnifyTType(env, topid, pos, lreturnType, rreturnType)
					} else {
						error();
					}
				}
				TTypeEClass(id): {
					superfn = copyTTypeFunction(env, sub);
					unifyTType(env, topid, "stub fn", pos, sub, superfn)
				}
				TTypeName(id, typars): error();
				TTypeOverload(unique, overloads): error();
				TTypeSupertype(unique, subtypes, maxed): {
					superfn = copyTTypeFunction(env, sub);
					unifyTType(env, topid, "stub super fn", pos, sub, superfn)
					// TODO: We know subid and the supers are related by a common
					// supertype
					// println("TODO: Sub function against supertype " + prettyTType(sub) + " vs " + prettyTType(super));
				}
			}
		}
		TTypeOverload(unique, overloads): {
			iter(overloads, \sb -> {
				subtypeUnifyTType(env, topid, pos, sb, super)
			})
		}
		TTypeSupertype(unique, subtypes, maxed): {
			// unifyTSupertype(env, "sub", pos, sub, super);
			iter(subtypes, \sb -> {
				subtypeUnifyTType(env, topid, pos, sb, super)
			})
		}
	}
}

subtypeTTypenames(env : TTypeEnv, topid : string, pos : int, sub : TTypeName, super : TTypeName) -> void {
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	}
	if (sub.id == super.id) {
		if (length(sub.typars) == length(super.typars)) {
			iteri(sub.typars, \i, larg -> {
				if (true) {
					unifyTType(env, topid, "typename", pos, larg, super.typars[i])
				} else {
					subtypeUnifyTType(env, topid, pos, larg, super.typars[i])
				}
			});
		} else {
			error();
		}
	} else if (sub.id == "flow" || super.id == "flow") {
	} else {
		supers = env.resolveSupertypes(sub.id);
		if (contains(supers, super.id)) {
			munion = env.resolveUnionName(super.id);
			munion ?? {
			//	println("We have a subtype " + toString(sub) + " against a super " + super.id);
				mstruct = instantiateTTypeNameFromUnion(env, munion, super, sub.id);
				switch (mstruct) {
					None(): error();
					Some(struct): {
						// OK, we unify the instantiated struct with the subtype
						unifyTType(env, topid, "sub against super-instance", pos, sub, struct);
					}
				}
			} : {
				env.onError(pos, "Unknown union " + super.id + " when checking if " + prettyTType(sub) + " is a subtype of " + prettyTType(super));
			}
		} else {
			error();
		}
	}
}

possibleTTypeNodeMatch(env : TTypeEnv, node : TTypeNode, type : TType) -> bool {
	exists(node.best, \t -> {
		possibleTTypeMatch(env, t, type)
	})
	|| switch (node.supertype) {
		None(): false;
		Some(supertype): {
			exists(supertype.subtypes, \t -> {
				possibleSuperTType(env, t, type)
			})
		}
	}
}

// Can these two types potentially match? Used to resolve overloads
possibleTTypeMatch(env : TTypeEnv, left : TType, right : TType) -> bool {
	if (left == right) true
	else {
		switch (left) {
			TTypeEClass(__): true;
			TTypeName(lid, ltps): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(rid, rtps): {
						lid == rid
						&& length(ltps) == length(rtps)
						&& forall(mapi(ltps, \i, ltp -> possibleTTypeMatch(env, ltp, rtps[i])), idfn)
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes, maxed): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeFunction(largs, lrt): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(id, typars): false;
					TTypeFunction(rargs, rrt): {
						length(largs) == length(rargs)
						&& forall(mapi(largs, \i, la -> possibleTTypeMatch(env, la, rargs[i])), idfn)
						&& possibleTTypeMatch(env, lrt, rrt)
					}
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes, maxed): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeOverload(unique, overloads): exists(overloads, \ol -> possibleTTypeMatch(env, ol, right));
			TTypeSupertype(__, lsubtypes, maxed): {
				forall(lsubtypes, \st -> {
					possibleSuperTType(env, st, right)
				})
			}
		}
	}
}

possibleSuperTType(env : TTypeEnv, subtype : TType, supertype : TType) -> bool {
	switch (subtype) {
		TTypeName(sid, __): {
			supers = env.resolveSupertypes(sid);
			if (supers == []) false
			else switch (supertype) {
				TTypeName(superid, __): {
					contains(supers, superid);
				}
				TTypeEClass(__): true;
				default: false;
			}
		}
		TTypeEClass(__): true;
		default: {
			println("TODO: Is this a possible supertype? " + prettyTType(subtype) + " vs " + prettyTType(supertype));
			false;
		}
	}
}

copyTTypeFunction(env : TTypeEnv, t : TTypeFunction) -> TTypeFunction {
	TTypeFunction(
		map(t.args, \__ -> TTypeEClass(env.mkEClass())),
		TTypeEClass(env.mkEClass())
	);
}

unifyTType2(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void {
	// println("We need a new class for these two " + prettyTType(left) + " and " + prettyTType(right));

	leftclass = findEClass(env.tgraph, left);
	rightclass = findEClass(env.tgraph, right);
	if (leftclass != -1) {
		unifyTypeToEClass(env, leftclass, right, [], []);
	} else if (rightclass != -1) {
		unifyTypeToEClass(env, leftclass, left, [], []);
	} else {
		ltype = makeTTypeEClass(env.tgraph, [reason], [pos], left);
		unifyTypeToEClass(env, ltype.eclass, right, [], []);
	}
}

unifyTypeToEClass(env : TTypeEnv, eclass : int, type : TType, reasons : [string], pos : [int]) -> void {
	typeclass = findEClass(env.tgraph, type);
	if (typeclass == -1) {
		jclass = addTType2EClass(env.tgraph, reasons, pos, eclass, type);
 	} else {
		unifyEClasses(env, eclass, typeclass);
	}
}

unifyEClasses(env : TTypeEnv, class1 : int, class2 : int) -> void {
	if (class1 != class2) {
		// Merge the classes
		eclass = joinTTypeEClasses(env.tgraph, class1, class2);
	}
}

clarifyEClass(env : TTypeEnv, eclass : int, merge : TTypeNode) -> void {
	pos = elementAt(merge.positions, 0, -1);

	// TODO
	topid = "";
	// Now, merge among ourselves
	iteri(merge.best, \i, b1 -> {
		iter(subrange(merge.best, i + 1, length(merge.best)), \b2 -> {
			// println([b1, b2]);
			unifyTType(env, topid, "eclass e" + i2s(eclass) + " clean", pos, b1, b2);
		})
	});

	// Unify best against the overloads
	switch (merge.overload) {
		None(): {}
		Some(overload): {
			iter(merge.best, \b -> {
				unifyTType(env, topid, "eclass e" + i2s(eclass) + " clean overload", pos, b, overload);
			});
		}
	}

	// Unify best against the supertype
	switch (merge.supertype) {
		None(): {}
		Some(supertype): {
			iter(merge.best, \b -> {
				// println("Clean super " + i2s(eclass) + " " + prettyTType(b) + " vs " + prettyTType(supertype));
				unifyTType(env, topid, "eclass e" + i2s(eclass) + " super clean", pos, b, supertype);
			});
		}
	}

	iterSet(merge.originals, \i -> {
		iter(merge.best, \b -> {
			unifyTType2(env, "eclass e" + i2s(eclass) + " clean original", pos, b, i);
		})
	})
}
