import plow/types/pretty;
import plow/types/typeenv;
import plow/types/polymorphism;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void;
}

unifyTType(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void {
	// env.onError(pos, reason + " unify " + prettyTType(left) + " vs " + prettyTType(right));
	// OK, mark these types are unified
	unifyTTypeEClass(env.tgraph, pos, left, right);

	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, pos, ltypars, rtypars);
					} else {
						unifyTTypeNames(env, reason, pos, left, right);
					}
				}
				TTypeEClass(eclass): {}
				TTypeFunction(args, returnType): {
					env.onError(pos, lid + " is not a function");
				}
				TTypeOverload(unique, overloads): {
					unifyTTypeOverload(env, pos, right, left);
				}
				TTypeSupertype(unique, subtypes): {
					unifyTSupertype(env, pos, right, left);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, pos, largs, rargs);
					unifyTType(env, "fn return", pos, lreturnType, rreturnType);
				}
				TTypeOverload(__, __): unifyTTypeOverload(env, pos, right, left);
				TTypeName(id, typars): {
					env.onError(pos, id + " is not a function " + prettyTType(left));
				}
				TTypeEClass(eclass): {}
				TTypeSupertype(unique, subtypes): unifyTSupertype(env, pos, right, left);
			}
		}
		TTypeEClass(lid): {}
		TTypeOverload(lunique, loverloads): {
			unifyTTypeOverload(env, pos, left, right);
		}
		TTypeSupertype(unique, subtypes): {
			unifyTSupertype(env, pos, left, right);
		}
	}
}

unifyTTypeNames(env : TTypeEnv, reason : string, pos : int, left : TTypeName, right : TTypeName) {
	// TODO: This is correct if one is a union with exactly the other type in it
	// otherwise, it is a problem
	env.onError(pos, left.id + " and " + right.id + " are not compatible (TODO: Check if one is a single-struct union) " + reason);
}

unifyTTypeOverload(env : TTypeEnv, pos : int, overload : TTypeOverload, type : TType) -> void {
	good = filter(overload.overloads, \ol -> {
		possibleTTypeMatch(env, ol, type)
	});
	n = length(good);
	if (n < length(overload.overloads)) {
		// OK, we have new information
		if (n == 1) {
			// println("Resolved overload");
			winner = good[0];
			unifyTType(env, "overload", pos, winner, type);
		} else {
			// At least the type overload is smaller
			// We could probably unify this into the set, but hey, it is not required
		}
	}
}

unifyTTypes(env : TTypeEnv, pos : int, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, "types #" + i2s(i), pos, larg, right[i])
		});
	}
}

unifyTSupertype(env : TTypeEnv, pos : int, super : TTypeSupertype, type : TType) -> void {
	iter(super.subtypes, \st -> {
		subtypeUnifyTType(env, pos, st, type);
	});
	// OK, another thing we can do is to unify identical supertype typepars:
	
	// unify(super(Maybe<t1>, Maybe<t2>), type<t1>)
	// -> unify(super(Maybe<super(t1, t2)>), type)
	named : Tree<string, [TTypeName]> = fold(super.subtypes, makeTree(), \acc, st -> {
		switch (st) {
			TTypeName(id, tps): treePushToArrayValue(acc, id, st);
			default: acc;
		}
	});
	traverseInOrder(named, \name, tns : [TTypeName] -> {
		if (length(tns) > 1) {
			representative = tns[0];
			typars = mapi(representative.typars, \i, __ -> {
				TTypeSupertype(env.mkUnique(), map(tns, \tn -> tn.typars[i]));
			});
			stype = TTypeSupertype(super.unique, typars);
			unifyTType(env, "intrasupers " + name, pos, stype, type)
		}
	});
}

// Check that st is a sutype of type, and if so, unify any typars
subtypeUnifyTType(env : TTypeEnv, pos : int, sub : TType, super : TType) -> void {
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	};
	switch (sub) {
		TTypeName(subid, subtypars): {
			switch (super) {
				TTypeName(superid, supertypars): {
					subtypeTTypenames(env, pos, sub, super);
				}
				TTypeEClass(id): {}
				TTypeSupertype(__, supers): {
					// This is probably true
				}
				TTypeFunction(args, returnType): error();
				TTypeOverload(unique, overloads): error();
			}
		}
		TTypeEClass(id): {
			switch (super) {
				TTypeName(superid, __): {
				}
				TTypeEClass(__): {}
				TTypeFunction(args, returnType): {
					env.onError(pos, "TODO: We know " + i2s(id) + " should be a function");
				}
				TTypeOverload(unique, overloads): {
				//	env.onError(pos, "TODO: Check if any overloads are structural here");
				}
				TTypeSupertype(unique, subtypes): {
				//	env.onError(pos, "TODO: Check if any supertypes are structural here");
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (super) {
				TTypeFunction(rargs, rreturnType): {
					if (length(largs) == length(rargs)) {
						// We reverse the polarity
						iteri(largs, \i, larg -> {
							subtypeUnifyTType(env, pos, rargs[i], larg)
						});
						subtypeUnifyTType(env, pos, lreturnType, rreturnType)
					} else {
						error();
					}
				}
				TTypeEClass(id): {}
				default: error();
			}
		}
		TTypeOverload(unique, overloads): {
			iter(overloads, \sb -> {
				subtypeUnifyTType(env, pos, sb, super)
			})
		}
		TTypeSupertype(unique, subtypes): {
			iter(subtypes, \sb -> {
				subtypeUnifyTType(env, pos, sb, super)
			})
		}
	}
}

subtypeTTypenames(env : TTypeEnv, pos : int, sub : TTypeName, super : TTypeName) -> void {
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	}
	if (sub.id == super.id) {
		if (length(sub.typars) == length(super.typars)) {
			iteri(sub.typars, \i, larg -> {
				subtypeUnifyTType(env, pos, larg, super.typars[i])
			});
		} else {
			error();
		}
	} else if (sub.id == "flow" || super.id == "flow") {
	} else {
		supers = env.resolveSupertypes(sub.id);
		if (contains(supers, super.id)) {
			munion = env.resolveUnionName(super.id);
			munion ?? {
				mstruct = instantiateTTypeNameFromUnion(env, munion, super, sub.id);
				switch (mstruct) {
					None(): error();
					Some(struct): {
						// OK, we unify the instantiated struct with the subtype
						unifyTType(env, "sub against super-instance", pos, sub, struct);
					}
				}
			} : {
				env.onError(pos, "Unknown union " + super.id + " when checking if " + prettyTType(sub) + " is a subtype of " + prettyTType(super));
			}
		} else {
			error();
		}
	}
}

// Can these two types potentially match? Used to resolve overloads
possibleTTypeMatch(env : TTypeEnv, left : TType, right : TType) -> bool {
	if (left == right) true
	else {
		switch (left) {
			TTypeEClass(__): true;
			TTypeName(lid, ltps): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(rid, rtps): {
						lid == rid
						&& length(ltps) == length(rtps)
						&& forall(mapi(ltps, \i, ltp -> possibleTTypeMatch(env, ltp, rtps[i])), idfn)
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeFunction(largs, lrt): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(id, typars): false;
					TTypeFunction(rargs, rrt): {
						length(largs) == length(rargs)
						&& forall(mapi(largs, \i, la -> possibleTTypeMatch(env, la, rargs[i])), idfn)
						&& possibleTTypeMatch(env, lrt, rrt)
					}
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeOverload(unique, overloads): exists(overloads, \ol -> possibleTTypeMatch(env, ol, right));
			TTypeSupertype(__, lsubtypes): {
				forall(lsubtypes, \st -> {
					possibleSuperTType(env, st, right)
				})
			}
		}
	}
}

possibleSuperTType(env : TTypeEnv, subtype : TType, supertype : TType) -> bool {
	switch (subtype) {
		TTypeName(sid, __): {
			supers = env.resolveSupertypes(sid);
			if (supers == []) false
			else switch (supertype) {
				TTypeName(superid, __): {
					contains(supers, superid);
				}
				TTypeEClass(__): true;
				default: false;
			}
		}
		TTypeEClass(__): true;
		default: {
			println("TODO: Is this a possible supertype? " + prettyTType(subtype) + " vs " + prettyTType(supertype));
			false;
		}
	}
}
