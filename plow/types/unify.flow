import plow/types/pretty;
import plow/types/typeenv;
import ds/egraph_dot;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, left : TType, right : TType) -> void;
}

unifyTType(env : TTypeEnv, left : TType, right : TType) -> void {
	//println("Unify " + prettyTType(left) + " and " + prettyTType(right));
	lroot = addEExp(env.egraph, left);
	rroot = addEExp(env.egraph, right);
	root = unionEClass(env.egraph, lroot, rroot);

	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, ltypars, rtypars);
					} else {
						println("TODO: Find the relation between these named types and unify typars");
					}
				}
				default: {}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, largs, rargs);
					unifyTType(env, lreturnType, rreturnType);
				}
				TTypeOverload(__, __): unifyTTypeOverload(env, right, left);
				default: {}
			}
		}
		TTypeVar(lid): {}
		TTypeOverload(lunique, loverloads): {
			unifyTTypeOverload(env, left, right);
		}
		TTypeSupertype(unique, subtypes): {
			println("TODO: Unify supertypes");
		}
	}
}

unifyTTypeOverload(env : TTypeEnv, overload : TTypeOverload, type : TType) -> void {
	good = filter(set2array(overload.overloads), \ol -> {
		possibleTTypeMatch(ol, type)
	});
	n = length(good);
	if (n < sizeSet(overload.overloads)) {
		// OK, we have new information
		if (n == 1) {
			// println("Resolved overload");
			winner = good[0];
			unifyTType(env, winner, type);
		} else {
			// At least the type overload is smaller
			// We could probably unify this into the set, but hey, it is not required
		}
	}
}

unifyTTypes(env : TTypeEnv, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, larg, right[i])
		});
	}
}

// Can these two types potentially match? Used to resolve overloads
possibleTTypeMatch(left : TType, right : TType) -> bool {
	if (left == right) true
	else {
		switch (left) {
			TTypeVar(__): true;
			TTypeName(lid, ltps): {
				switch (right) {
					TTypeVar(__): true;
					TTypeName(rid, rtps): {
						lid == rid
						&& length(ltps) == length(rtps)
						&& forall(mapi(ltps, \i, ltp -> possibleTTypeMatch(ltp, rtps[i])), idfn)
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): possibleTTypeMatch(right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(right, left);
				}
			}
			TTypeFunction(largs, lrt): {
				switch (right) {
					TTypeVar(__): true;
					TTypeName(id, typars): false;
					TTypeFunction(rargs, rrt): {
						length(largs) == length(rargs)
						&& forall(mapi(largs, \i, la -> possibleTTypeMatch(la, rargs[i])), idfn)
						&& possibleTTypeMatch(lrt, rrt)
					}
					TTypeOverload(unique, overloads): possibleTTypeMatch(right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(right, left);
				}
			}
			TTypeOverload(unique, overloads): existsSet(overloads, \ol -> possibleTTypeMatch(ol, right));
			TTypeSupertype(__, lsubtypes): {
				switch (right) {
					TTypeVar(id): true;
					TTypeName(id, typars): {
						println("TODO: Is " + id + " a super type for " + toString(set2array(lsubtypes)));
						false;
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): false;
					TTypeSupertype(__, rsubtypes): {
						println("TODO: Is this a super type?");
						false;
					}
				}
			}
		}
	}
}
