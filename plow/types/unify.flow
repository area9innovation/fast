import plow/types/pretty;
import plow/types/typeenv;
import ds/egraph_dot;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, left : TType, right : TType) -> void;
}

unifyTType(env : TTypeEnv, left : TType, right : TType) -> void {
	// println("Unify " + prettyTType(left) + " and " + prettyTType(right));
	lroot = addEExp(env.egraph, left);
	rroot = addEExp(env.egraph, right);
	root = unionEClass(env.egraph, lroot, rroot);

	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, ltypars, rtypars);
					} else {
						unifyTTypeNames(env, left, right);
					}
				}
				default: {}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, largs, rargs);
					unifyTType(env, lreturnType, rreturnType);
				}
				TTypeOverload(__, __): unifyTTypeOverload(env, right, left);
				default: {}
			}
		}
		TTypeVar(lid): {}
		TTypeOverload(lunique, loverloads): {
			unifyTTypeOverload(env, left, right);
		}
		TTypeSupertype(unique, subtypes): {
			unifyTSupertype(env, left, right);
		}
	}
}

unifyTTypeNames(env : TTypeEnv, left : TTypeName, right : TTypeName) {
	// TODO: This is correct if one is a union with exactly the other type in it
	// otherwise, it is a problem
	env.onError(-1, left.id + " and " + right.id + " are not compatible (TODO: Check if one is a single-struct union)");
}

unifyTTypeOverload(env : TTypeEnv, overload : TTypeOverload, type : TType) -> void {
	good = filter(set2array(overload.overloads), \ol -> {
		possibleTTypeMatch(env, ol, type)
	});
	n = length(good);
	if (n < sizeSet(overload.overloads)) {
		// OK, we have new information
		if (n == 1) {
			// println("Resolved overload");
			winner = good[0];
			unifyTType(env, winner, type);
		} else {
			// At least the type overload is smaller
			// We could probably unify this into the set, but hey, it is not required
		}
	}
}

unifyTSupertype(env : TTypeEnv, super : TTypeSupertype, type : TType) -> void {
	iterSet(super.subtypes, \st -> {
		subtypeUnifyTType(env, st, type);
	})
}

unifyTTypes(env : TTypeEnv, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, larg, right[i])
		});
	}
}

// Check that st is a sutype of type, and if so, unify any typars
subtypeUnifyTType(env : TTypeEnv, sub : TType, super : TType) -> void{
	error = \ -> {
		env.onError(-1, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	};
	switch (sub) {
		TTypeName(subid, subtypars): {
			switch (super) {
				TTypeName(superid, supertypars): {
					subtypeTTypenames(env, sub, super);
				}
				TTypeVar(id): {}
				default: error();
			}
		}
		TTypeVar(id): {}
		TTypeFunction(largs, lreturnType): {
			switch (super) {
				TTypeFunction(rargs, rreturnType): {
					if (length(largs) == length(rargs)) {
						// We reverse the polarity
						iteri(largs, \i, larg -> {
							subtypeUnifyTType(env, rargs[i], larg)
						});
						subtypeUnifyTType(env, lreturnType, rreturnType)
					} else {
						error();
					}
				}
				TTypeVar(id): {}
				default: error();
			}
		}
		TTypeOverload(unique, overloads): {
			error();
		}
		TTypeSupertype(unique, subtypes): {
			error();
		}
	}
}

subtypeTTypenames(env : TTypeEnv, sub : TTypeName, super : TTypeName) -> void {
	if (sub.id == super.id) {
		if (length(sub.typars) == length(super.typars)) {
			iteri(sub.typars, \i, larg -> {
				subtypeUnifyTType(env, larg, super.typars[i])
			});
		} else {
			env.onError(-1, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
		}
	} else {
		supers = env.resolveSupertypes(sub.id);
		if (contains(supers, super.id)) {
			println("TODO: Unify typars for " + sub.id + " with supertype " + super.id);
		} else {
			env.onError(-1, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
		}
	}
}


// Can these two types potentially match? Used to resolve overloads
possibleTTypeMatch(env : TTypeEnv, left : TType, right : TType) -> bool {
	if (left == right) true
	else {
		switch (left) {
			TTypeVar(__): true;
			TTypeName(lid, ltps): {
				switch (right) {
					TTypeVar(__): true;
					TTypeName(rid, rtps): {
						lid == rid
						&& length(ltps) == length(rtps)
						&& forall(mapi(ltps, \i, ltp -> possibleTTypeMatch(env, ltp, rtps[i])), idfn)
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeFunction(largs, lrt): {
				switch (right) {
					TTypeVar(__): true;
					TTypeName(id, typars): false;
					TTypeFunction(rargs, rrt): {
						length(largs) == length(rargs)
						&& forall(mapi(largs, \i, la -> possibleTTypeMatch(env, la, rargs[i])), idfn)
						&& possibleTTypeMatch(env, lrt, rrt)
					}
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeOverload(unique, overloads): existsSet(overloads, \ol -> possibleTTypeMatch(env, ol, right));
			TTypeSupertype(__, lsubtypes): {
				forall(set2array(lsubtypes), \st -> {
					possibleSuperTType(env, st, right)
				})
			}
		}
	}
}

possibleSuperTType(env : TTypeEnv, subtype : TType, supertype : TType) -> bool {
	switch (subtype) {
		TTypeName(sid, __): {
			supers = env.resolveSupertypes(sid);
			if (supers == []) false
			else switch (supertype) {
				TTypeName(superid, __): {
					contains(supers, superid);
				}
				TTypeVar(__): true;
				default: false;
			}
		}
		default: {
			println("TODO: Is this a possible supertype?");
			false;
		}
	}
}

