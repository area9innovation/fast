import plow/types/pretty;
import plow/types/typeenv;
import plow/types/polymorphism;

export {
	// Unify these two types into the same equivalence class
	unifyTType(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void;
}

uniindent = ref "";
unifyTType(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void {
	indent = ^uniindent;
	if (false) {
		println(indent + "Unify " + prettyTType(left) + "   vs   " + prettyTType(right) + ". " + reason);
		uniindent :=indent + "  ";
	}
	// env.onError(pos, reason + " unify " + prettyTType(left) + " vs " + prettyTType(right));
	// Do recursive unification
	switch (left) {
		TTypeName(lid, ltypars): {
			switch (right) {
				TTypeName(rid, rtypars): {
					if (lid == rid) {
						unifyTTypes(env, pos, ltypars, rtypars);
					} else {
						unifyTTypeNames(env, reason, pos, left, right);
					}
				}
				TTypeEClass(eclass): {
					unifyTypeToEClass(env.tgraph, eclass, left, [reason], [pos]);
				}
				TTypeFunction(args, returnType): {
					env.onError(pos, lid + " is not a function");
				}
				TTypeOverload(unique, overloads): {
					unifyTTypeOverload(env, reason, pos, right, left);
				}
				TTypeSupertype(unique, subtypes, maxed): {
					unifyTSupertype(env, reason, pos, right, left);
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (right) {
				TTypeFunction(rargs, rreturnType): {
					unifyTTypes(env, pos, largs, rargs);
					unifyTType(env, "fn return", pos, lreturnType, rreturnType);
				}
				TTypeOverload(__, __): unifyTTypeOverload(env, reason, pos, right, left);
				TTypeName(id, typars): {
					env.onError(pos, id + " is not a function " + prettyTType(left));
				}
				TTypeEClass(eclass): {
					// We know eclass is a function, which is recorded in the environment
					unifyTypeToEClass(env.tgraph, eclass, left, [reason], [pos]);
				}
				TTypeSupertype(unique, subtypes, maxed): unifyTSupertype(env, reason, pos, right, left);
			}
		}
		TTypeEClass(lid): {
			switch (right) {
				TTypeEClass(rid): {
					// OK, merge eclasses
					unionUnionMap(env.tgraph.umap, lid, rid);
					{}
				}
				TTypeName(id, typars): {
					unifyTypeToEClass(env.tgraph, lid, right, [reason], [pos]);
				}
				TTypeFunction(args, returnType): {
					unifyTypeToEClass(env.tgraph, lid, right, [reason], [pos]);
				}
				TTypeOverload(__, __): {
					unifyTTypeOverload(env, reason, pos, right, left);
				}
				TTypeSupertype(unique, subtypes, maxed): {
					unifyTSupertype(env, reason, pos, right, left);
				}
			}
		}
		TTypeOverload(lunique, loverloads): {
			unifyTTypeOverload(env, reason, pos, left, right);
		}
		TTypeSupertype(unique, subtypes, maxed): {
			unifyTSupertype(env, reason, pos, left, right);
		}
	}
	uniindent := indent;
}

unifyTTypeNames(env : TTypeEnv, reason : string, pos : int, left : TTypeName, right : TTypeName) {
	// TODO: This is correct if one is a union with exactly the other type in it
	// otherwise, it is a problem
	env.onError(pos, left.id + " and " + right.id + " are not compatible (TODO: Check if one is a single-struct union) " + reason);
}

unifyTTypeOverload(env : TTypeEnv, reason : string, pos : int, overload : TTypeOverload, type : TType) -> void {
	good = filter(overload.overloads, \ol -> {
		possibleTTypeMatch(env, ol, type)
	});
	n = length(good);
	if (n == 1) {
		// println("Resolved overload");
		winner = good[0];
		unifyTType(env, "overload", pos, winner, type);
	} else {
		eoverload = TTypeOverload(overload with overloads = good);
		switch (type) {
			TTypeName(id, typars): env.onError(pos, id + " can not be overloaded");
			TTypeEClass(eclass): unifyTypeToEClass(env.tgraph, eclass, eoverload, [reason], [pos]);
			TTypeFunction(args, returnType): {
				unifyTType2(env, reason, pos, eoverload, type);
			}
			TTypeOverload(unique, overloads): {
				println("TODO: Overload against overload");
			}
			TTypeSupertype(unique, subtypes, maxed): env.onError(pos, "Supertype can not be overloaded");
		}
	}
}

unifyTTypes(env : TTypeEnv, pos : int, left : [TType], right : [TType]) -> void {
	if (length(left) == length(right)) {
		iteri(left, \i, larg -> {
			unifyTType(env, "types #" + i2s(i), pos, larg, right[i])
		});
	}
}

unifyTSupertype(env : TTypeEnv, reason : string, pos : int, super : TTypeSupertype, type : TType) -> void {
	iter(super.subtypes, \st -> {
		subtypeUnifyTType(env, pos, st, type);
	});
	// OK, another thing we can do is to unify identical supertype typepars:
	
	// unify(super(Maybe<t1>, Maybe<t2>), type<t1>)
	// -> unify(super(Maybe<super(t1, t2)>), type)
	named : Tree<string, [TTypeName]> = fold(super.subtypes, makeTree(), \acc, st -> {
		switch (st) {
			TTypeName(id, tps): treePushToArrayValue(acc, id, st);
			default: acc;
		}
	});
	traverseInOrder(named, \name, tns : [TTypeName] -> {
		if (length(tns) > 1) {
			representative = tns[0];
			typars = mapi(representative.typars, \i, __ -> {
				TTypeSupertype(env.mkUnique(), map(tns, \tn -> tn.typars[i]), super.maxed);
			});
			stype = TTypeSupertype(super with subtypes = [
				TTypeName(representative with typars = typars)
			]);
			unifyTType(env, "intrasupers " + name, pos, stype, type)
		}
	});

	switch (type) {
		TTypeEClass(eclass): unifyTypeToEClass(env.tgraph, eclass, super, [reason], [pos]);
		TTypeName(id, typars): unifyTType2(env, reason, pos, super, type);
		TTypeFunction(args, returnType): {
			unifyTType2(env, reason, pos, super, type);
		}
		TTypeOverload(unique, overloads): env.onError(pos, "Supertype can not be overloaded");
		TTypeSupertype(unique, subtypes, maxed): unifyTType2(env, reason, pos, super, type);
	}
}

unifyTType2(env : TTypeEnv, reason : string, pos : int, left : TType, right : TType) -> void {
	nameclass = findEClass(env.tgraph, left);
	if (nameclass != -1) {
		unifyTypeToEClass(env.tgraph, nameclass, right, [reason], [pos]);
	} else {
		superclass = findEClass(env.tgraph, right);
		if (superclass != -1) {
			unifyTypeToEClass(env.tgraph, superclass, left, [reason], [pos]);
		} else {
			// println("We need a new class for these two " + prettyTType(left) + " and " + prettyTType(right));
			newclass = emptyTTypeClass(env.tgraph);
			node1 = makeTTypeNode(left, [reason], [pos]);
			node2 = makeTTypeNode(right, [], []);
			node = mergeTTypeNodes(node1, node2);
			setUnionMapValue(env.tgraph.umap, newclass, node);
		}
	}	
}

// Check that st is a subtype of type, and if so, unify any typars
subtypeUnifyTType(env : TTypeEnv, pos : int, sub : TType, super : TType) -> void {
	// println("Sub type " + prettyTType(sub) + " vs " + prettyTType(super));
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	};
	switch (sub) {
		TTypeName(subid, subtypars): {
			switch (super) {
				TTypeName(superid, supertypars): {
					subtypeTTypenames(env, pos, sub, super);
				}
				TTypeEClass(id): {
					supers = env.resolveSupertypes(subid);
					if (supers == []) {
						// OK, there are no supers, so this has to be it
						unifyTType(env, "unique super", pos, sub, super);
					}
				}
				TTypeSupertype(__, supers, maxed): {
					// This is probably true
					// TODO: We know subid and the supers are related by a common
					// supertype
				}
				TTypeFunction(args, returnType): error();
				TTypeOverload(unique, overloads): error();
			}
		}
		TTypeEClass(id): {
			switch (super) {
				TTypeName(superid, __): {
					subs = env.resolveSubtypes(superid);
					if (subs == []) {
						// OK, there are no subs, so this has to be it
					//	println(prettyTType(sub) + " vs " + prettyTType(super) + " unique");
						unifyTType(env, "unique sub", pos, sub, super);
					}
				}
				TTypeEClass(__): {}
				TTypeFunction(args, returnType): {
					subfn = copyTTypeFunction(env, super);
					unifyTType(env, "stub fn", pos, subfn, super)
				}
				TTypeOverload(unique, overloads): {
					iter(overloads, \s -> {
						switch (s) {
							TTypeFunction(__, __): {
								env.onError(pos, "TODO: We know 1 " + i2s(id) + " should be a function");
							}
							default: {}
						}
					});
				}
				TTypeSupertype(unique, subtypes, maxed): {
					stubfn = fold(subtypes, sub, \acc, s -> {
						if (acc != sub) acc
						else switch (s) {
							TTypeFunction(__, __): {
								copyTTypeFunction(env, s);
							}
							default: acc;
						}
					});
					if (stubfn != sub) {
						unifyTType(env, "stub fn", pos, stubfn, super)
					}
				}
			}
		}
		TTypeFunction(largs, lreturnType): {
			switch (super) {
				TTypeFunction(rargs, rreturnType): {
					if (length(largs) == length(rargs)) {
						// We reverse the polarity
						iteri(largs, \i, larg -> {
							subtypeUnifyTType(env, pos, rargs[i], larg)
						});
						subtypeUnifyTType(env, pos, lreturnType, rreturnType)
					} else {
						error();
					}
				}
				TTypeEClass(id): {
					superfn = copyTTypeFunction(env, sub);
					unifyTType(env, "stub fn", pos, sub, superfn)
				}
				TTypeName(id, typars): error();
				TTypeOverload(unique, overloads): error();
				TTypeSupertype(unique, subtypes, maxed): {
					superfn = copyTTypeFunction(env, sub);
					unifyTType(env, "stub super fn", pos, sub, superfn)
					// TODO: We know subid and the supers are related by a common
					// supertype
					// println("TODO: Sub function against supertype " + prettyTType(sub) + " vs " + prettyTType(super));
				}
			}
		}
		TTypeOverload(unique, overloads): {
			iter(overloads, \sb -> {
				subtypeUnifyTType(env, pos, sb, super)
			})
		}
		TTypeSupertype(unique, subtypes, maxed): {
			// unifyTSupertype(env, "sub", pos, sub, super);
			iter(subtypes, \sb -> {
				subtypeUnifyTType(env, pos, sb, super)
			})
		}
	}
}

subtypeTTypenames(env : TTypeEnv, pos : int, sub : TTypeName, super : TTypeName) -> void {
	error = \ -> {
		env.onError(pos, prettyTType(sub) + " is not a subtype of " + prettyTType(super));
	}
	if (sub.id == super.id) {
		if (length(sub.typars) == length(super.typars)) {
			iteri(sub.typars, \i, larg -> {
				if (true) {
					unifyTType(env, "typename", pos, larg, super.typars[i])
				} else {
					subtypeUnifyTType(env, pos, larg, super.typars[i])
				}
			});
		} else {
			error();
		}
	} else if (sub.id == "flow" || super.id == "flow") {
	} else {
		supers = env.resolveSupertypes(sub.id);
		if (contains(supers, super.id)) {
			munion = env.resolveUnionName(super.id);
			munion ?? {
			//	println("We have a subtype " + toString(sub) + " against a super " + super.id);
				mstruct = instantiateTTypeNameFromUnion(env, munion, super, sub.id);
				switch (mstruct) {
					None(): error();
					Some(struct): {
						// OK, we unify the instantiated struct with the subtype
						unifyTType(env, "sub against super-instance", pos, sub, struct);
					}
				}
			} : {
				env.onError(pos, "Unknown union " + super.id + " when checking if " + prettyTType(sub) + " is a subtype of " + prettyTType(super));
			}
		} else {
			error();
		}
	}
}

// Can these two types potentially match? Used to resolve overloads
possibleTTypeMatch(env : TTypeEnv, left : TType, right : TType) -> bool {
	if (left == right) true
	else {
		switch (left) {
			TTypeEClass(__): true;
			TTypeName(lid, ltps): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(rid, rtps): {
						lid == rid
						&& length(ltps) == length(rtps)
						&& forall(mapi(ltps, \i, ltp -> possibleTTypeMatch(env, ltp, rtps[i])), idfn)
					}
					TTypeFunction(args, returnType): false;
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes, maxed): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeFunction(largs, lrt): {
				switch (right) {
					TTypeEClass(__): true;
					TTypeName(id, typars): false;
					TTypeFunction(rargs, rrt): {
						length(largs) == length(rargs)
						&& forall(mapi(largs, \i, la -> possibleTTypeMatch(env, la, rargs[i])), idfn)
						&& possibleTTypeMatch(env, lrt, rrt)
					}
					TTypeOverload(unique, overloads): possibleTTypeMatch(env, right, left);
					TTypeSupertype(unique, subtypes, maxed): possibleTTypeMatch(env, right, left);
				}
			}
			TTypeOverload(unique, overloads): exists(overloads, \ol -> possibleTTypeMatch(env, ol, right));
			TTypeSupertype(__, lsubtypes, maxed): {
				forall(lsubtypes, \st -> {
					possibleSuperTType(env, st, right)
				})
			}
		}
	}
}

possibleSuperTType(env : TTypeEnv, subtype : TType, supertype : TType) -> bool {
	switch (subtype) {
		TTypeName(sid, __): {
			supers = env.resolveSupertypes(sid);
			if (supers == []) false
			else switch (supertype) {
				TTypeName(superid, __): {
					contains(supers, superid);
				}
				TTypeEClass(__): true;
				default: false;
			}
		}
		TTypeEClass(__): true;
		default: {
			println("TODO: Is this a possible supertype? " + prettyTType(subtype) + " vs " + prettyTType(supertype));
			false;
		}
	}
}

copyTTypeFunction(env : TTypeEnv, t : TTypeFunction) -> TTypeFunction {
	TTypeFunction(
		map(t.args, \__ -> TTypeEClass(env.mkEClass())),
		TTypeEClass(env.mkEClass())
	);
}
