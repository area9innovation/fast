import plow/types/typeenv;
import plow/types/pretty;
import plow/types/util;
import plow/types/comparison;

export {
	// Extract the best type
	eclass2TType(env : TTypeEnv, eclass : int) -> TType;
}

/*
TODO:
- The structure of this thing should be different.
We should iterate over all eclasses, and attempt to extract new
information from them. If we can find a new type, or resolve
something, we should unify with that result in a loop.
*/

eclass2TType(env : TTypeEnv, eclass : int) -> TType {
	mtype = lookupTree(^(env.etypes), eclass);
	mtype ?? {
		mtype
	} : {
		// Set up that we have an empty type going here
		env.etypes := setTree(^(env.etypes), eclass, emptyTType);
		nodes = getEClassNodes(env.egraph, eclass);
		tt = extractTType(env, eclass, nodes);
		if (tt != emptyTType) {
			// If this type is new, we should unify it
			env.etypes := setTree(^(env.etypes), eclass, tt);

			nclass = addEExp(env.egraph, tt);
			if (nclass != eclass) {
				println("More work to do");
			}
		}
		// println("Resolved " + i2s(eclass) + " as " + prettyTType(tt));
		tt;
	}
}

extractTType(env : TTypeEnv, eclass : int, nodes : Set<ENode<TType>>) -> TType {
	mtype = foldSet(nodes, emptyTType, \acc, node -> {
		ntype = enode2TType(env, node);
		bestTType(env, acc, ntype);
	});
	if (mtype != emptyTType) {
		mtype;
	} else {
		println("Unbounded type");
		TTypeVar(env.mkTyvar());
	}
}

enode2TType(env : TTypeEnv, enode : ENode<TType>) -> TType {
	switch (enode.head : TType) {
		TTypeVar(id): resolveTTypeVar(env, id);
		TTypeName(id, typars): {
			TTypeName(id, map(enode.args, \root -> {
				eclass2TType(env, root)
			}))
		}
		TTypeFunction(args, returnType): {
			children : [TType] = map(enode.args, \root -> eclass2TType(env, root));
			// The last child is the return type
			n = length(children);
			if (n == 0) {
				println("Not supposed to happen 2");
				TTypeVar(env.mkTyvar());
			} else {
				TTypeFunction(subrange(children, 0, n - 1), children[n - 1]);
			}
		}
		TTypeOverload(typar, overloads): {
			children : [TType] = uniq(map(enode.args, \root -> {
				eclass2TType(env, root);
			}));
			if (length(children) == 1) {
				// OK, structural change! Merge this into the graph!
				children[0];
			} else {
				TTypeOverload(typar, buildSet(children));
			}
		}
		TTypeSupertype(typar, subtypes): {
			children : [TType] = uniq(map(enode.args, \root -> {
				eclass2TType(env, root);
			}));
			makeTTypeSupertype(typar, children);
		}
	}
}

bestTType(env : TTypeEnv, left : TType, right : TType) -> TType {
	com = compareTType(env, left, right);
	switch (com) {
		TTypeEqual(type): type;
		TTypeSubtype(subtype, supertype): {
			// TODO: Depending on we want the max or min, we should give either here
			subtype;
		}
		TTypeDifferent(error): {
			env.onError(-1, "Incompatible types: " + error);
			left;
		}
		TTypeMorePrecise(precise, imprecise): {
			precise;
		}
	}
}

resolveTTypeVar(env : TTypeEnv, tyvar : int) -> TType {
	// Reverse mapping
	foldTree(env.typars, TTypeVar(tyvar), \tp, tvv, acc -> {
		if (tvv == tyvar) TTypeName(tp, [])
		else acc;
	})
}
