import plow/types/typeenv;
import plow/types/pretty;
import plow/types/util;
import plow/types/typeof;

export {
	// Instantiates typars into tyvars
	instantiateTTypePar(env : TTypeEnv, t : TType) -> TType;

	// Given this typename, instantiate it as either a union or struct typename, or a basic type
	instantiateTTypeName(env : TTypeEnv, name : string) -> TType;

	// Given a typename we know is part of the union, with this instantiation,
	// instantiate the corresponding typename
	instantiateTTypeNameFromUnion(env : TTypeEnv, union : DUnion, unionInstance : TTypeName, struct : string) -> Maybe<TType>;

	// Given this struct definition, instantiate a typename for it, and a consistent set of field types
	// Instantiates polymorphism.
	instantiateTTypeNameForStruct(env : TTypeEnv, struct : DStruct) -> Pair<TType, [Pair<string, TType>]>;
}

instantiateTTypePar(env : TTypeEnv, t : TType) -> TType {
	doInstantiateTTypePar(env, ref makeTree(), t);
}

doInstantiateTTypePar(env : TTypeEnv, typars : ref Tree<string, TTypeVar>, t : TType) -> TType {
	rec = \tt -> doInstantiateTTypePar(env, typars, tt);
	switch (t) {
		TTypeName(id, tyargs): {
			ityargs = map(tyargs, rec);
			if (id != "" && trim2(id, "?") == "") {
				mtype = lookupTree(^typars, id);
				mtype ?? {
					mtype;
				} : {
					tv = TTypeVar(env.mkEClass());
					typars := setTree(^typars, id, tv);
					tv;
				}
			} else {
				TTypeName(id, ityargs);
			}
		}
		TTypeVar(id): t;
		TTypeFunction(args, returnType): TTypeFunction(map(args, rec), rec(returnType));
		TTypeOverload(typar, overloads): {
			TTypeOverload(rec(typar), mapSet(overloads, rec));
		}
		TTypeSupertype(typar, subtypes): {
			TTypeSupertype(rec(typar), mapSet(subtypes, rec));
		}
	}
}

instantiateTTypeNameFromUnion(env : TTypeEnv, union : DUnion, unionInstance : TTypeName, struct : string) -> Maybe<TType> {
	stype : Maybe<DTypeName> = find(union.types, \tn -> tn.id == struct);
	stype ?? {
		if (length(unionInstance.typars) == length(union.typars)) {
			typars : Tree<TType, TType> = foldi(unionInstance.typars, makeTree(), \i, acc : Tree<TType, TType>, typar : TType -> {
				name : string = union.typars[i].id;
				setTree(acc, TTypeName(name, []), typar);
			});
			Some(replaceTType(typars, dtype2ttype(env, false, stype)));
		} else {
			env.onError(-1, "Expected #" + i2s(length(union.typars)) + " typars, got " + prettyTType(unionInstance));
			None();
		}
	} : None();
}

instantiateTTypeNameForStruct(env : TTypeEnv, struct : DStruct) -> Pair<TType, [Pair<string, TType>]> {
	typars = map(struct.typars, \tp -> TTypeVar(env.mkEClass()));

	typarTree = foldi(struct.typars, makeTree(), \i, acc, tp -> {
		setTree(acc, tp, typars[i].tyvar)
	});

	tn = TTypeName(struct.id, typars);
	fields = map(struct.structArgs, \sa -> {
		Pair(sa.id, dtype2ttype(TTypeEnv(env with typars = typarTree), true, sa.type))
	});

	Pair(tn, fields);
}

instantiateTTypeName(env : TTypeEnv, name : string) -> TType {
	mstruct = env.resolveStructName(name);
	mstruct ?? {
		instantiateTTypeNameForStruct(env, mstruct).first
	} : {
		munion = env.resolveUnionName(name);
		switch (munion) {
			None(): {
				typars = if (name == "array" || name == "ref") 1 else 0;
				TTypeName(name, generate(0, typars, \__ -> TTypeVar(env.mkEClass())));
			}
			Some(union): {
				typars = map(union.typars, \tp -> TTypeVar(env.mkEClass()));
				TTypeName(name, typars);
			}
		}
	}
}
