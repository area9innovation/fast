import plow/types/unify;
import plow/types/builtin;
import plow/dexp/pretty;

export {
	ttypeInferenceDExp(env : TTypeEnv, id : string, d : DExp) -> TTypeEClass;
}

inferenceIndent = ref "  ";

ttypeInferenceDExp(env : TTypeEnv, topid : string, d : DExp) -> TTypeEClass {
	if (true) {
		doTTtypeInferenceDExp(env, topid, d);
	} else {
		indent = ^inferenceIndent;
		if (true) {
			locals = getTreeKeys(env.localTypes);
			println(indent + "Locals " + toString(locals) + " for inference of " + summarizeDExp(env, d));
			// prettyDExp(env, "", indent, d);
		}

		inferenceIndent := indent + "  ";
		t = doTTtypeInferenceDExp(env, topid, d);
		inferenceIndent := indent;

		println(indent + "gave " + prettyTType(t));
		t;
	}
}

doTTtypeInferenceDExp(env : TTypeEnv, topid : string, d : DExp) -> TTypeEClass {
	restype = \reason, tv, type -> {
		if (true) {
			tclass = findOrMakeTNodeClass(env.tgraph.tmap, type, d.pos);
			unifyEClass(env.tgraph.tmap, tclass, tv);
		} else {
			unifyTType(env, topid, reason, d.pos, type, TTypeEClass(tv));
		}
		// We return the class, so anything will unify against this
		TTypeEClass(tv);
	};
	res = \type -> {
		eclass = findOrMakeTNodeClass(env.tgraph.tmap, type, d.pos);
		TTypeEClass(eclass);
	}
	supertype = \types : [TType], maxed : bool -> makeTTypeSupertype(env.mkUnique, types, maxed);

	switch (d) {
		DVoid(pos): res(TTypeName("void", []));
		DBool(v, pos): res(TTypeName("bool", []));
		DInt(v, pos): res(TTypeName("int", [])); 
		DDouble(v, pos): res(TTypeName("double", []));
		DString(v, pos): res(TTypeName("string", []));
		DStringInclude(path, pos): res(TTypeName("string", []));
		DVar(id, pos, eclass): {
			mtype = lookupTree(env.localTypes, id);
			type = mtype ?? {
				// Local types should NOT be instantiated
				mtype
			} : {
				moptype = getBuiltinTType(id);
				externalType = switch (moptype) {
					None(): {
						modtype : Maybe<TType> = lookupTree(env.moduleTypes, id);
						switch (modtype) {
							None(): env.resolveId(pos, id);
							Some(mdtype): {
								mdtype;
							}
						}
					}
					Some(optype): optype;
				};
				if (isTracingId(env.tracing, StageTypeInference(), 2, topid)) {
					println(id + " : " + prettyTType(externalType));
				}

				// Any other type needs instantiation
				instantiateTTypePar(env, externalType);
			};

			if (isTracingId(env.tracing, StageTypeInference(), 2, topid)) {
				println(id + " : " + prettyTType(type));
			}
			
			restype("var " + id, eclass, type);
		}
		DTyped(value, type, pos, eclass): {
			valtype = ttypeInferenceDExp(env, topid, value);
			ttype = TTypeEClass(dtype2eclass(env.tgraph.tmap, makeTree(), type));
			unifyTType(env, topid, "typed", pos, if (false) valtype else supertype([valtype], false), ttype);
			restype("typed", eclass, ttype);
		}
		DLet(id, value, body, pos, eclass): {
			tvalue = ttypeInferenceDExp(env, topid, value);
			nenv = TTypeEnv(env with localTypes = setTree(env.localTypes, id, tvalue));
			tbody = ttypeInferenceDExp(nenv, topid, body);
			restype("let " +id, eclass, tbody);
		}
		DIf(cond, then, else_, pos, eclass): {
			tcond = ttypeInferenceDExp(env, topid, cond);
			unifyTType(env, topid, "if-cond", pos, tcond, TTypeName("bool", []));

			tthen = ttypeInferenceDExp(env, topid, then);
			telse = ttypeInferenceDExp(env, topid, else_);
			type = supertype([tthen, telse], false);
			restype("if-body", eclass, type);
		}
		DCall(fn, args, pos, eclass): {
			fntype1 = ttypeInferenceDExp(env, topid, fn);
			// println(summarizeDExp(env, fn) + " : " + prettyTType(fntype1));
			argtypes = map(args, \a -> supertype([ttypeInferenceDExp(env, topid, a)], false));
			rettype = TTypeEClass(env.mkEClass());
			fntype2 = TTypeFunction(argtypes, rettype);
			// println(prettyTType(fntype1) + " vs " + prettyTType(fntype2));
			unifyTType(env, topid, "call", pos, fntype1, fntype2);

			restype("call-ret", eclass, rettype);
		}
		DConstruct(structid, args, pos, eclass): {
			mstruct = env.resolveStructName(structid);
			mstruct ?? {
				argTypes = map(args, \arg -> {
					ttypeInferenceDExp(env, topid, arg)
				});
				itype = instantiateTTypeNameForStruct(env, mstruct);
				if (length(argTypes) == length(itype.second)) {
					iteri(itype.second, \i, fields : Pair<string, TType> -> {
						unifyTType(env, topid, "construct call", pos, supertype([argTypes[i]], false), fields.second);
					});
				} else {
					env.onError(pos, "Struct " + structid + " expects " + i2s(length(itype.second)) + " arguments, got " + i2s(length(argTypes)));
				}

				restype("construct type", eclass, itype.first);
			} : {
				env.onError(pos, "Unknown struct " + structid);
				TTypeEClass(env.mkEClass());
			}
		}
		DLambda(args, body, pos, eclass): {
			argTypes = map(args, \arg -> {
				TTypeEClass(dtype2eclass(env.tgraph.tmap, makeTree(), arg.type));
			});
			nenv = foldi(args, env, \i, acc, arg -> {
				aclass = findOrMakeTNodeClass(env.tgraph.tmap, argTypes[i], arg.pos);
				TTypeEnv(acc with localTypes = setTree(acc.localTypes, arg.id, TTypeEClass(aclass)))
			});
			retType = ttypeInferenceDExp(nenv, topid, body);
			// TODO: With this as true, we have a problem that super(fn-type) does not preserve
			// the supertype of the return value
			type = TTypeFunction(argTypes, if (false) retType else supertype([retType], false));
			restype("lambda", eclass, type);
		}
		DRef(value, pos, eclass): {
			vtype = ttypeInferenceDExp(env, topid, value);
			type = TTypeName("ref", [supertype([vtype], false)]);
			restype("ref", eclass, type);
		}
		DField(value, field, pos, eclass): {
			// OK, this is an overload of all structs with a field
			tvalue = ttypeInferenceDExp(env, topid, value);

			fieldStructs : [DStruct] = env.resolveField(field);

			// Types for overload functions
			fieldFnTypes : [TTypeFunction] = filtermap(fieldStructs, \struct : DStruct -> {
				getDStructFieldType(env, struct, field);
			});

			fieldUnions : Set<string> = env.resolveUnionField(field);
			unionFns = map(set2array(fieldUnions), \un -> {
				utype = instantiateTTypeName(env, un);

				munion = env.resolveUnionName(un);
				fieldType = switch (munion) {
					None(): TTypeEClass(env.mkEClass());
					Some(union): {
						// Find the type of this field
						fieldType : Maybe<TTypeFunction> = fold(union.types, None(), \acc, type -> {
							mstruct = env.resolveStructName(type.id);
							mstruct ?? {
								getDStructFieldType(env, mstruct, field)
							} : acc;
						});
						switch (fieldType) {
							None(): TTypeEClass(env.mkEClass());
							Some(ft): {
								ft.returnType
							}
						}
					}
				};
				TTypeFunction([utype], fieldType);
			});

			fnTypes = concat(fieldFnTypes, unionFns);

			fntype = if (fnTypes == []) {
				env.onError(pos, "Unknown field " + field);
				TTypeEClass(env.mkEClass());
			} else if (length(fnTypes) == 1) {
				fnTypes[0]
			} else TTypeOverload(TTypeEClass(eclass), sort(fnTypes));

			rtype = TTypeEClass(eclass);
			calltype = TTypeFunction([tvalue], rtype);

			unifyTType(env, topid, "field", pos, calltype, fntype);
			rtype;
		}
		DSetMutable(left, field, value, pos, eclass): {
			ltype = ttypeInferenceDExp(env, topid, left);
			valtype = ttypeInferenceDExp(env, topid, value);

			fieldStructs : [DStruct] = env.resolveField(field);

			fieldFnTypes = filtermap(fieldStructs, \struct : DStruct -> {
				stypenameFields = instantiateTTypeNameForStruct(env, struct);
				stypename = stypenameFields.first;
				fields = stypenameFields.second;

				mft : Maybe<Pair<string, TType>> = find(fields, \sa -> sa.first == field);
				fieldType : Maybe<TType> = maybeMap(mft, \ft -> {
					// OK, the typars are wrong here, since we should use the type
					// of the field
					ft.second
				});
				fieldType ?? {
					Some(TTypeFunction([stypename], fieldType));
				} : None();
			});

			fntype = if (fieldFnTypes == []) {
				env.onError(pos, "Unknown field " + field);
				TTypeEClass(env.mkEClass());
			} else if (length(fieldFnTypes) == 1) {
				fieldFnTypes[0]
			} else TTypeOverload(TTypeEClass(eclass), sort(fieldFnTypes));

			calltype = TTypeFunction([ltype], supertype([valtype], false));

			unifyTType(env, topid, "field", pos, calltype, fntype);
			restype("setmutable", eclass, voidTType)
		}
		DArray(exps, pos, eclass): {
			vtypes = map(exps, \e -> {
				ttypeInferenceDExp(env, topid, e);
			});
			type = if (vtypes == []) {
				// OK, set up a type var for this thing
				TTypeName("array", [TTypeEClass(env.mkEClass())]);
			} else {
				TTypeName("array", [supertype(vtypes, false)]);
			}
			restype("array", eclass, type);
		}
		DSequence(exps, pos, eclass): {
			stype = fold(exps, voidTType, \acc, e -> {
				ttypeInferenceDExp(env, topid, e);
			});
			restype("seq", eclass, stype);
		}
		DSwitch(value, type, cases, defaultCase, pos, eclass): {
			tvalue = ttypeInferenceDExp(env, topid, value);

			ttype = TTypeEClass(dtype2eclass(env.tgraph.tmap, makeTree(), type));
			unifyTType(env, topid, "switch val", pos, supertype([tvalue], false), ttype);

			// Relate the type of the value with all structs mentioned
			caseTypes = map(cases, \c -> instantiateTTypeName(env, c.id));
			unifyTType(env, topid, "switch res", pos, supertype(caseTypes, defaultCase == None()), ttype);

			// Find the resulting type of the bodies
			caseBodyTypes = map(cases, \c -> ttypeInferenceDExp(env, topid, c.body));
			bodytypes = defaultCase ?? {
				arrayPush(caseBodyTypes, ttypeInferenceDExp(env, topid, defaultCase));
			} : {
				caseBodyTypes
			};
			restype("switch ret", eclass, supertype(bodytypes, false));
		}
		DCast(value, target, pos): {
			tvalue = ttypeInferenceDExp(env, topid, value);
			ttarget = TTypeEClass(dtype2eclass(env.tgraph.tmap, makeTree(), target));
			// We allow casting a type to a supertype
			unifyTType(env, topid, "cast", pos, 
				supertype([tvalue], true), 
				if (true) {
					supertype([ttarget], true)
				} else {
					// If we do not allow downcasts, use this one
					ttarget
				}
			);
			// TODO: Add an eclass?
			res(ttarget);
		}
		DDowncast(oldid, newid, subtype, supereclass, scope, pos, eclass): {
			tsubtype = TTypeEClass(dtype2eclass(env.tgraph.tmap, makeTree(), subtype));
			teclass = TTypeEClass(findOrMakeTNodeClass(env.tgraph.tmap, tsubtype, pos));

			nenv = TTypeEnv(env with 
				localTypes = setTree(
					env.localTypes,
//					setTree(env.localTypes, oldid, tsubtype),
					newid, teclass
				)
			);
			dtype = ttypeInferenceDExp(nenv, topid, scope);

			// Relate the subtype with the supertype
			etype = TTypeEClass(supereclass);
			unifyTType(env, topid, "downcast super", pos, supertype([teclass], false), etype);

			restype("downcast", eclass, dtype);
		}
	}
}

getDStructFieldType(env : TTypeEnv, struct : DStruct, field : string) -> Maybe<TTypeFunction> {
	stypenameFields = instantiateTTypeNameForStruct(env, struct);
	stypename = stypenameFields.first;
	fields = stypenameFields.second;

	mft : Maybe<Pair<string, TType>> = find(fields, \sa -> sa.first == field);
	fieldType : Maybe<TType> = maybeMap(mft, \ft -> {
		// OK, the typars are wrong here, since we should use the type
		// of the field
		ft.second
	});
	fieldType ?? {
		Some(TTypeFunction([stypename], fieldType));
	} : None();
}
