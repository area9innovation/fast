import plow/types/unify;
import plow/types/builtin;
import plow/dexp/pretty;

export {
	ttypeInferenceDExp(env : TTypeEnv, d : DExp) -> TType;
}

inferenceIndent = ref "  ";

ttypeInferenceDExp(env : TTypeEnv, d : DExp) -> TType {
	if (true) {
		doTTypeInferenceDExp(env, d);
	} else {
		indent = ^inferenceIndent;
		if (true) {
			locals = getTreeKeys(env.localTypes);
			println(indent + "Locals " + toString(locals) + " for inference of");
			prettyDExp(env, "", indent, d);
		}

		inferenceIndent := indent + "  ";
		t = doTTypeInferenceDExp(env, d);
		inferenceIndent := indent;

		println(indent + "gave " + prettyTType(t));
		t;
	}
}

doTTypeInferenceDExp(env : TTypeEnv, d : DExp) -> TType {
	restype = \tv, type -> {
		unifyTType(env, d.pos, type, TTypeEClass(tv));
		type;
	};
	supertype = \types : [TType] -> makeTTypeSupertype(env.mkUnique, types);

	switch (d) {
		DVoid(pos): TTypeName("void", []);
		DBool(v, pos): TTypeName("bool", []);
		DInt(v, pos): TTypeName("int", []); 
		DDouble(v, pos): TTypeName("double", []);
		DString(v, pos): TTypeName("string", []);
		DStringInclude(path, pos): TTypeName("string", []);
		DVar(id, pos, eclass): {
			mtype = lookupTree(env.localTypes, id);
			utype = mtype ?? {
				mtype
			} : {
				moptype = getBuiltinTType(id);
				switch (moptype) {
					None(): {
						modtype = lookupTree(env.moduleTypes, id);
						switch (modtype) {
							None(): env.resolveId(pos, id);
							Some(mdtype): mdtype;
						}
					}
					Some(optype): optype;
				}
			};

			type = instantiateTTypePar(env, utype);
			restype(eclass, type);
		}
		DTyped(value, type, pos): {
			valtype = ttypeInferenceDExp(env, value);
			ttype = dtype2ttype(env, true, type);

			unifyTType(env, pos, supertype([valtype, ttype]), ttype);
			valtype;
		}
		DLet(id, value, body, pos, eclass): {
			tvalue = ttypeInferenceDExp(env, value);
			nenv = TTypeEnv(env with localTypes = setTree(env.localTypes, id, tvalue));
			tbody = ttypeInferenceDExp(nenv, body);
			restype(eclass, tbody);
		}
		DIf(cond, then, else_, pos, eclass): {
			tcond = ttypeInferenceDExp(env, cond);
			unifyTType(env, pos, tcond, TTypeName("bool", []));

			tthen = ttypeInferenceDExp(env, then);
			telse = ttypeInferenceDExp(env, else_);
			type = supertype([tthen, telse]);
			restype(eclass, type);
		}
		DCall(fn, args, pos, eclass): {
			fntype1 = ttypeInferenceDExp(env, fn);
			argtypes = map(args, \a -> supertype([ttypeInferenceDExp(env, a)]));
			rettype = TTypeEClass(env.mkEClass());
			fntype2 = TTypeFunction(argtypes, rettype);

			unifyTType(env, pos, fntype1, fntype2);

			restype(eclass, rettype);
		}
		DConstruct(structid, args, pos, eclass): {
			mstruct = env.resolveStructName(structid);
			mstruct ?? {
				argTypes = map(args, \arg -> {
					ttypeInferenceDExp(env, arg)
				});
				itype = instantiateTTypeNameForStruct(env, mstruct);
				if (length(argTypes) == length(itype.second)) {
					iteri(itype.second, \i, fields : Pair<string, TType> -> {
						unifyTType(env, pos, supertype([argTypes[i]]), fields.second);
					});
				} else {
					env.onError(pos, "Struct " + structid + " expects " + i2s(length(itype.second)) + " arguments, got " + i2s(length(argTypes)));
				}

				restype(eclass, itype.first);
			} : {
				env.onError(pos, "Unknown struct " + structid);
				TTypeEClass(env.mkEClass());
			}
		}
		DLambda(args, body, pos, eclass): {
			argTypes = map(args, \arg -> {
				dtype2ttype(env, true, arg.type)
			});
			nenv = foldi(args, env, \i, acc, arg -> {
				TTypeEnv(acc with localTypes = setTree(acc.localTypes, arg.id, argTypes[i]))
			});
			retType = ttypeInferenceDExp(nenv, body);
			type = TTypeFunction(argTypes, retType);
			restype(eclass, type);
		}
		DRef(value, pos, eclass): {
			vtype = ttypeInferenceDExp(env, value);
			type = TTypeName("ref", [supertype([vtype])]);
			restype(eclass, type);
		}
		DField(value, field, pos, eclass): {
			// OK, this is an overload of all structs with a field
			tvalue = ttypeInferenceDExp(env, value);
			fieldStructs : [DStruct] = env.resolveField(field);

			fieldFnTypes = filtermap(fieldStructs, \struct : DStruct -> {
				stypenameFields = instantiateTTypeNameForStruct(env, struct);
				stypename = stypenameFields.first;
				fields = stypenameFields.second;

				mft : Maybe<Pair<string, TType>> = find(fields, \sa -> sa.first == field);
				fieldType : Maybe<TType> = maybeMap(mft, \ft -> {
					// OK, the typars are wrong here, since we should use the type
					// of the field
					ft.second
				});
				fieldType ?? {
					Some(TTypeFunction([stypename], fieldType));
				} : None();
			});

			fntype = if (fieldFnTypes == []) {
				env.onError(pos, "Unknown field " + field);
				TTypeEClass(env.mkEClass());
			} else if (length(fieldFnTypes) == 1) {
				fieldFnTypes[0]
			} else TTypeOverload(TTypeEClass(eclass), buildSet(fieldFnTypes));

			rtype = TTypeEClass(eclass);
			calltype = TTypeFunction([tvalue], rtype);

			unifyTType(env, pos, calltype, fntype);
			rtype;
		}
		// DSetMutable(lhs, field, value, pos, eclass): 
		DArray(exps, pos, eclass): {
			vtypes = map(exps, \e -> {
				ttypeInferenceDExp(env, e);
			});
			type = TTypeName("array", [supertype(vtypes)]);
			restype(eclass, type);
		}
		DSequence(exps, pos, eclass): {
			stype = fold(exps, voidTType, \acc, e -> {
				ttypeInferenceDExp(env, e);
			});
			restype(eclass, stype);
		}
		DSwitch(value, type, cases, defaultCase, pos, eclass): {
			tvalue = ttypeInferenceDExp(env, value);
			ttype = dtype2ttype(env, true, type);
			unifyTType(env, pos, supertype([tvalue]), ttype);

			// Relate the type of the value with all structs mentioned
			caseTypes = map(cases, \c -> instantiateTTypeName(env, c.id));
			unifyTType(env, pos, supertype(caseTypes), supertype([tvalue]));

			// Find the resulting type of the bodies
			caseBodyTypes = map(cases, \c -> ttypeInferenceDExp(env, c.body));
			bodytypes = defaultCase ?? {
				arrayPush(caseBodyTypes, ttypeInferenceDExp(env, defaultCase));
			} : {
				caseBodyTypes
			};
			restype(eclass, supertype(bodytypes));
		}
		DCast(value, target, pos): {
			tvalue = ttypeInferenceDExp(env, value);
			ttarget = dtype2ttype(env, true, target);
			// We allow casting a type to a supertype
			unifyTType(env, pos, supertype([tvalue]), ttarget);
			ttarget;
		}
		DDowncast(var, subtype, scope, pos, eclass): {
			tsubtype = dtype2ttype(env, true, subtype);
			nenv = TTypeEnv(env with localTypes = setTree(env.localTypes, var, tsubtype));
			dtype = ttypeInferenceDExp(nenv, scope);

			etype = lookupTree(env.localTypes, var);
			etype ?? {
				// Relate the subtype with the supertype
				unifyTType(env, pos, supertype([etype, tsubtype]), etype);
			} : {}

			restype(eclass, dtype);
		}
		// DWith(struct, value, fields, pos, eclass): 
		default: {
			println("TODO: Infer the type of " + d.structname);
			TTypeEClass(env.mkEClass());
		}
	}
}
