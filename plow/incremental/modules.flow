import plow/bexp/bmodule;
import plow/incremental/serialize;
import sys/concurrent;

import plow/dexp/desugar;

export {
	// A concurrent hash map from flowpath to BModule 
	BModules(modules : native);

	makeBModules() -> BModules;

	getDummyBModule() -> BModule;

	hasCachedBModule(m : BModules, flowpath : string) -> bool;
	getCachedBModule(m : BModules, flowpath : string) -> BModule;
	setCachedBModule(m : BModules, flowpath : string, bmod : BModule) -> void;
}

makeBModules() -> BModules {
	BModules(initConcurrentHashMap())
}

getDummyBModule() -> BModule {
	BModule("", "", [], [], DExport(makeSet(), makeSet(), makeSet(), -1), makeTree(), makeTree(), makeTree(), makeTree(), makeTree(), []);
}

hasCachedBModule(m : BModules, flowpath : string) -> bool {
	if (containsConcurrentHashMap(m.modules, flowpath)) {
		true
	} else {
		incremental = readBModule(flowpath);
		incremental ?? {
			setCachedBModule(m, flowpath, incremental);
			true;
		} : {
			false;
		}
	};
}

getCachedBModule(m : BModules, flowpath : string) -> BModule {
	getConcurrentHashMap(m.modules, flowpath, getDummyBModule());
}

setCachedBModule(m : BModules, flowpath : string, bmod : BModule) -> void {
	setConcurrentHashMap(m.modules, flowpath, bmod);
	writeBModule(bmod);
}
