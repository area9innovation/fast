import plow/backends/link;
import plow/backends/back_eval;
import plow/backends/pretty;
import plow/backends/koka/koka_backend;
import plow/backends/utils;

export {
	// Compiles the given flow path to Koka as a single string
	bmodule2koka(cache : PlowCache, flowpath : string, shortenIds : bool) -> string;
}

bmodule2koka(cache : PlowCache, flowpath : string, shortenIds : bool) -> string {
	bprogram2koka(linkBExpProgram(cache, flowpath, shortenIds, kokaBackendSpec()), flowpath);
}

bprogram2koka(b : BExpProgram, flowpath : string) -> string {
	backend = kokaBackend();
	unions = superglue(getTreeValues(b.unions), \u : DUnion -> dunion2koka(backend, u), "\n");
	structs = superglue(getTreeValues(b.structs), \s : DStruct -> dstruct2koka(backend, s), "\n");
	body = superglue(b.declarations, \d : BExpDeclaration -> bdeclaration2koka(backend, d), "\n");

	// The backend keeps track of what requirements are used by the various
	// constructs used
	strReplace(
		getBackendRequirements(backend)
	//	+ "// RUNTIME\n" 
	//	+ runtime + "\n"
		+ "// UNIONS\n"
		+ unions + "\n"
		+ "// STRUCTS\n"
		+ structs + "\n"
		+ "// BODY\n"
		+ body,
		"\t",
		"  "
	)
}

bdeclaration2koka(backend : Backend, d : BExpDeclaration) -> string {
	switch (d) {
		BGlobalVar(id, body, type): "val " + id + " : " + btype2koka(backend, true, type) + bexp2koka(backend, body) + ";";
		BExpFunction(id, args, body, type): {
			blueprint("
				fun %id%(%args%) {
					%body%
				}
			", [
				"id", id,
				// TODO: Add types and typars
				"args", strGlue(args, ", "),
				"body", bexp2koka(backend, body)
			])
		}
		BExpNative(id, isio, type, nativeName): "-- TODO: Native " + id;
	}
}

dunion2koka(backend : Backend, u : DUnion) -> string {
	blueprint("
		type %name% {
			%members%
		}", [
			"name", decapitalize(u.id),
			"members", superglue(u.types, \t -> {
				dtype2koka(backend, false, t);
			}, "\n")
		]
	);
}

dstruct2koka(backend : Backend, s : DStruct) -> string {
	"struct " + decapitalize(s.id) + "{"
	+ superglue(s.structArgs, \sa -> {
		sa.id + " : " + dtype2koka(backend, true, sa.type)
	}, "; ") + "}";
}


dtype2koka(backend : Backend, decap : bool, type : DType) -> string {
	btype2koka(backend, decap, dtype2btype(type));
}

btype2koka(backend : Backend, decap : bool, btype : BType) -> string {
	switch (btype) {
		BTypePar(id): {
			// In Koka, we use a, b, c, ...
			len = strlen(id) - 1;
			fromCharCode(getCharCodeAt("a", 0) + len);
		}
		BTypeName(id, typars): {
			if (id == "void") "()"
			else if (id == "bool" || id == "double" || id == "string") id
			else if (id == "int") "int32"
			else if (id == "array") {
				"vector<" + btype2koka(backend, true, typars[0]) + ">"
			} else if (id == "ref") {
				"ref<" + btype2koka(backend, true, typars[0]) + ">"
			} else {
				(if (decap) decapitalize(id) else id)
				+ (if (typars != []) {
					"<" + superglue(typars, \tp -> btype2koka(backend, true, tp), ", ") + ">"
				} else "")
			}
		}
		BTypeFunction(args, returnType): {
			"(" + superglue(args, \tp -> btype2koka(backend, true, tp), ", ") + ")"
			+ " -> " + btype2koka(backend, true, returnType)
		}
	}
}

bexp2koka(backend : Backend, bexp : BExp) -> string {
	todo = \ -> "TODO " + toString(bexp);
	rec = \ee -> bexp2koka(backend, ee);
	switch (bexp) {
		BVoid(): "()";
		BBool(v): if (v) "True" else "False";
		BInt(v): i2s(v);
		BDouble(v): double2string(v);
		BString(v): toString(v);
		BVar(id, type): id;
		BLet(id, value, body, type): {
			blueprint("
				val %id% = %value%
				%body%", [
				"id", id,
				"value", rec(value),
				"body", rec(body),
			])
		}
		BIf(cond, then, else_, type): {
			blueprint("
					if (%c%) {
						%then%
					} else {
						%else%
					}",
				[
					"c", rec(cond),
					"then", rec(then),
					"else", rec(else_),
			]);
		}
		BCall(fn, args, type): {
			blueprint("%fn%(%args%)",
				[
					"fn", rec(fn),
					"args", superglue(args, rec, ", "),
			]);
		}
		BLambda(args, body, type): {
			blueprint("
					fn(%args%) {
						%body%
					}",
				[
					"args", strGlue(args, ", "),
					"body", rec(body),
			]);
		}
		BSequence(exps, type): {
			blueprint("
					%exps%",
				[
					"exps", superglue(exps, rec, ";\n"),
			]);
		}
		BConstruct(struct, args, type): {
			blueprint("%struct%(%args%)",
				[
					"struct", struct,
					"args", superglue(args, rec, ", "),
			]);
		}
		BField(value, field, type): {
			blueprint("
					%value%.%field%",
				[
					"value", rec(value),
					"field", field,
			]);
		}
		BSetMutable(left, field, value, type): todo();
		BSwitch(value, switchType, cases, defaultCase, type): {
			/*
			match(m) {
				Nothing -> 0
				Just(i) -> i
				_ -> 2
			}
			*/
			blueprint("
					match (%value%) {
						%cases%
						%default%
					}",
				[
					"value", rec(value),
					"cases", superglue(cases, \case -> {
						blueprint("
							%id%() -> {
								%body%
							}",
							[
								"id", case.id,
								"body", rec(case.body)
							]);
					}, ";\n"),
					"default", defaultCase ?? ("_ -> " + rec(defaultCase)) : "",
			]);
		}
		BArray(args, type): {
			blueprint("[%args%]",
				[
					"args", superglue(args, rec, ", "),
			]);
		}
	}
}
