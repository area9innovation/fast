import plow/backends/backend;
import text/blueprint;

export {
	jsBackend() -> Backend;
}

jsBackend() -> Backend {
	comparison = \name, target, prec -> {
		[
			BackGen(name, BTypeFunction([bTypeBool, bTypeBool], bTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, BTypeFunction([bTypeInt, bTypeInt], bTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, BTypeFunction([bTypeDouble, bTypeDouble], bTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, BTypeFunction([bTypeString, bTypeString], bTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			// TODO: We need something fancy for other types here
		]
	};

	makeBackend("js", [
			// Keywords
			"abstract", "arguments",  "await",        "boolean",
			"break",    "byte",       "case",         "catch",
			"char",     "class",      "const",        "continue",
			"debugger", "default",    "delete",       "do",
			"double",   "else",       "enum",         "eval",
			"export",   "extends",    "false",        "final",
			"finally",  "float",      "for",          "function",
			"goto",     "if",         "implements",   "import",
			"in",       "instanceof", "int",          "interface",
			"let",      "long",       "native",       "new",
			"null",     "package",    "private",      "protected",
			"public",   "return",     "short",        "static",
			"super",    "switch",     "synchronized", "this",
			"throw",    "throws",     "transient",    "true",
			"try",      "typeof",     "var",          "void",
			"volatile", "while",      "with",         "yield",
			"R_" // Used by runtime for references
		], 

		//
		// Inlined operators
		//
		concatA([

		// In JS, there is ? here for if

		[
			BackGen("||", bTypeBool, BackBinOp("||", 10, BackArg(0), BackArg(1))),
			BackGen("&&", bTypeBool, BackBinOp("&&", 20, BackArg(0), BackArg(1))),
		],

		//	BackBinOp("|", 25, BackArg(0), BackArg(1)),
		//	BackBinOp("^", 26, BackArg(0), BackArg(1)),
		// 	BackBinOp("^", 27, BackArg(0), BackArg(1)),

		comparison("==", "===", 30),
		comparison("!=", "!==", 30),

		comparison("<=", "<=", 35),
		comparison("<", "<", 35),
		comparison(">=", ">=", 35),
		comparison(">", ">", 35),

		[
			// General deep comparison of objects
			BackGen("==", bTypeVoid, 
				BackRequire(
					BackText(
						blueprint("
							var deepEquality = function(a, b) {
								if (a === b) return true;

								var isArray = Array.isArray;
								var hasProp = Object.prototype.hasOwnProperty;

								if (a && b && (typeof a == 'object') && (typeof b == 'object')) {
									var arrA = isArray(a), arrB = isArray(b), i, length, key;
									if (arrA && arrB) {
										length = a.length;
										if (length != b.length) return false;
										for (i = length; i-- !== 0;) {
											if (!deepEquality(a[i], b[i])) return false;
										}
										return true;
									}

									if (arrA != arrB) return false;
									var result = false;

									if (hasProp.call(a, '_id') && hasProp.call(b, '_id')) {
										if (a._id !== b._id) {
											return false;
										} else {
											result = true;
										}
										for (field in a) {
											if (!deepEquality(a[field], b[field])) return false;
										}
									}
									if (hasProp.call(a, '__v') && hasProp.call(b, '__v')) {
										return false;
									}
									return result;
								}
								return false;
							}
							", []
						)
					),
					BackCall("deepEquality", [BackArg(0), BackArg(1)])
				)
			),
			BackGen("<", bTypeVoid, 
				BackRequire(
					BackText(
						blueprint("
							let compareByValue = function(o1, o2) {
								if (o1 === o2) return 0;
								if (o1 == null || o2 == null) {
									return 1;
								}
								var isArray = Array.isArray;
								if (isArray(o1)) {
									if (!isArray(o2)) {
										return 1;
									}
									var l1 = o1.length;
									var l2 = o2.length;
									var l = l1 < l2 ? l1 : l2;
									for (var i = 0; i < l; ++ i) {
										var c = compareByValue(o1[i], o2[i]);
										if(c != 0) {
											return c;
										}
									}
									if (l1 == l2) {
										return 0;
									} else if (l1 < l2) {
										return -1;
									} else {
										return 1;
									}
								}
								var hasProp = Object.prototype.hasOwnProperty;
								if (hasProp.call(o1, '_id')) {
									if (!hasProp.call(o2, '_id')) {
										return 1;
									}
									var i1 = o1._id;
									var i2 = o2._id;
									if (i1 < i2) {
										return -1;
									}
									if (i1 > i2) {
										return 1;
									}
									for (field in a) {
										var c = compareByValue(o1[field], o2[field]);
										if(c != 0) {
											return c;
										}
									}
									return 0;
								}
								if (o1 < o2) {
									return -1;
								} else {
									return 1;
								}
							};
							", []
						)
					),
					BackBinOp("<", 35,
						BackCall("compareByValue", [BackArg(0), BackArg(1)]),
						BackText("0")
					)
				)
			),
		],

		// In JS, we have bitshifts here <<, >>, >>>

		[
			BackGen("+", bTypeInt, BackBinOp("|", 25, BackBinOp("+", 40, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("+", bTypeDouble, BackBinOp("+", 40, BackArg(0), BackArg(1))),
			BackGen("+", bTypeString, BackBinOp("+", 40, BackArg(0), BackArg(1))),

			BackGen("-", bTypeInt, BackBinOp("|", 25, BackBinOp("-", 40, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("-", bTypeDouble, BackBinOp("-", 40, BackArg(0), BackArg(1))),

			BackGen("*", bTypeInt, 
				BackRequire(
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
					BackText("if (!Math.imul) Math.imul = function(opA, opB) {var result = (opA & 0x003fffff) * opB;if (opA & 0xffc00000) result += (opA & 0xffc00000) * opB |0;return result |0;};"),
					BackCall("Math.imul", [BackArg(0), BackArg(1)])
				)
			),
			BackGen("*", bTypeDouble, BackBinOp("*", 50, BackArg(0), BackArg(1))),

			BackGen("/", bTypeInt, BackBinOp("|", 25, BackBinOp("/", 50, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("/", bTypeDouble, BackBinOp("/", 50, BackArg(0), BackArg(1))),

			BackGen("%", bTypeInt, BackBinOp("|", 25, BackBinOp("%", 50, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("%", bTypeDouble, BackBinOp("%", 50, BackArg(0), BackArg(1))),

			BackGen("__negate", BTypeFunction([bTypeInt], bTypeInt), BackBinOp("|", 25, BackPreOp("-", 60, BackArg(0)), BackText("0"))),
			BackGen("__negate", BTypeFunction([bTypeDouble], bTypeDouble), BackPreOp("-", 60, BackArg(0))),
			BackGen("__not", bTypeVoid, BackPreOp("!", 60, BackArg(0))),

			// Cast and type is ignored
			BackGen(":", bTypeVoid, BackArg(0)),

			BackGen("__ref", bTypeVoid, 
				BackRequire(
					// Alternative: class R_ {constructor(v) { this.__v = v; } }
					BackText("function R_(v){this.v=v}"),
					BackCall("new R_", [BackArg(0)])
				)
			),
			BackGen("__deref", bTypeVoid, BackPostOp(".v", 60, BackArg(0))),
			BackGen(":=", bTypeVoid, BackBinOp(".v=", 70, BackArg(0), BackArg(1))),

			BackGen("[", bTypeVoid, BackConcat([BackText("["), BackArg(0), BackText("]")])),
			BackGen(",", bTypeVoid, BackBinOp(",", 80, BackArg(0), BackArg(1))),
			BackGen("__index", bTypeVoid, BackConcat([BackBinOp("[", 80, BackArg(0), BackArg(1)), BackText("]")])),

			BackGen(".", bTypeVoid, BackBinOp(".", 60, BackArg(0), BackUnquote(BackArg(1)))),

			// Inlined natives
			BackGen("Native.println", bTypeVoid, BackText("console.log")),

			BackGen("Native.fold", bTypeVoid, BackText("function(values,init,fn){for(var i=0;i<values.length;i++){init=fn(init,values[i]);}return init;}")),
			BackGen("Native.map", bTypeVoid, BackText("function(a,fn){return a.map(fn);}")),
			BackGen("Native.filter", bTypeVoid, BackText("function(a,fn){return a.filter(fn);}")),
			BackGen("Native.enumFromTo", bTypeVoid, BackText("function(init,n){var r=[];for(var i=init;i<=n;i++){r.push(i);}return r;}")),
			BackGen("Native.length", bTypeVoid, BackText("function(a){return a.length;}")),

			BackGen("Native.isSameStructType", bTypeVoid, 
				BackText("function(a,b){return Object.prototype.hasOwnProperty.call(a,'_id')&&Object.prototype.hasOwnProperty.call(b,'_id')&&a._id==b._id}")
			),

			BackGen("Native.quit", bTypeVoid, 
				BackIfDef("browser",
					BackText("function(c) {window.open('','_top').close();}"),
					BackText("function(c) {}")
				)
			),
			BackGen("Native.sin", bTypeVoid, BackText("Math.sin")),
			BackGen("Native.asin", bTypeVoid, BackText("Math.asin")),
			BackGen("Native.cos", bTypeVoid, BackText("Math.cos")),
			BackGen("Native.acos", bTypeVoid, BackText("Math.acos")),
			BackGen("Native.atan", bTypeVoid, BackText("Math.atan")),
			BackGen("Native.atan2", bTypeVoid, BackText("Math.atan2")),
			BackGen("Native.exp", bTypeVoid, BackText("Math.exp")),
			BackGen("Native.log", bTypeVoid, BackText("Math.log")),
			// d->i
			BackGen("Native.trunc", bTypeVoid, BackText("function(d){return (d)|0;}")),
			BackGen("Native.i2d", bTypeVoid, BackText("function(i){return i;}")),
			BackGen("Native.i2s", bTypeVoid, BackText("function(i){return String(i);}")),
			BackGen("Native.d2s", bTypeVoid, BackText("function(d){return String(d);}")),
			BackGen("Native.bitXor", bTypeVoid, BackText("function(a,b){return a^b;}")),
			BackGen("Native.bitAnd", bTypeVoid, BackText("function(a,b){return a&b;}")),
			BackGen("Native.bitOr", bTypeVoid, BackText("function(a,b){return a|b;}")),
			BackGen("Native.bitUshr", bTypeVoid, BackText("function(a,b){return a>>>b;}")),
			BackGen("Native.bitShl", bTypeVoid, BackText("function(a,b){return a<<b;}")),
			BackGen("Native.bitNot", bTypeVoid, BackText("function(a){return ~a;}")),

			BackGen("Native.strlen", bTypeVoid, BackText("function(s){return s.length;}")),
			BackGen("Native.strIndexOf", bTypeVoid, BackText("function(str,substr) {return str.indexOf(substr,0);}")),

			BackGen("Native.substring", bTypeVoid, 
				// It turns out that Chrome does NOT copy strings out when doing substring,
				// and thus we never free the original string
				BackText("function(str,start,len){
					var s = str.slice(start,start+len);
					if (2 * s.length < str.length){return (' '+s).slice(1);} else return s;
				}")
			),
			BackGen("Native.cloneString", bTypeVoid, BackText("function(s){return (' '+s).slice(1);}")),

			BackGen("Native.getCharCodeAt", bTypeVoid, BackText("function(s,i){return s.charCodeAt(i);}")),
			BackGen("Native.getCharAt", bTypeVoid, BackText("function(s,i){return s.charAt(i);}")),

			BackGen("Native.toString", bTypeVoid, 
				BackRequire(
					BackText(blueprint("
						var toString = function(value, keepStringEscapes) {
							if (keepStringEscapes == null) {
								keepStringEscapes = false;
							}
							if (value == null) {
								return '{}';
							}
							if (!Reflect.isObject(value)) {
								return Std.string(value);
							}
							if (Array.isArray(value)) {
								var r = '[';
								var s = '';
								for (i in value) {
									r += s + toString(value[i]);
									s = ', ';
								}
								return r + ']';
							}
							if (Object.prototype.hasOwnProperty.call(value,'__v')) {
								return 'ref ' + toString(value.__v);
							}
							if (Object.prototype.hasOwnProperty.call(value, '_id')) {
								var id = value._id;
								var r = id + '(';
								if (id == 'DLink') {
									return r + '...)';
								}
								var s = '';
								var first = true;
								for (field in value) {
									if (field != '_id') {
										r += s + toString(value[field]);
										s = ', ';
									}
								}
								r += ')';
								return r;
							}
							if (Reflect.isFunction(value)) {
								return '<function>';
							}
							try {
								var s = value;
								if (!keepStringEscapes) {
									s = StringTools.replace(s,'\\\\','\\\\\\\\');
									s = StringTools.replace(s,'\\\"','\\\\\"');
									s = StringTools.replace(s,'\\n','\\\\n');
									s = StringTools.replace(s,'\\t','\\\t');
									return '\\\"' + s + '\\\"';
								} else {
									StringTools.replace(s,'\\\\','\\\\\\\\');
									return s;
								}
							} catch ( _g ) {
								//haxe_NativeStackTrace.lastError = _g;
								return '<native>';
							}
						};
						", []
					)),
					BackText("toString")
				)
			),




/*
Native.toLowerCase = function(str) {
	return str.toLowerCase();
};
Native.toUpperCase = function(str) {
	return str.toUpperCase();
};
Native.strReplace = function(str,find,replace) {
	return StringTools.replace(str,find,replace);
};

Native.concat = function(arr1,arr2) {
	return arr1.concat(arr2);
};

Native.iter = function(values,clos) {
	var _g = 0;
	while(_g < values.length) {
		var v = values[_g];
		++_g;
		clos(v);
	}
};
*/

		]
		]),
	);
}
