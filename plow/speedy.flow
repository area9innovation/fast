import string;
import formats/json/json;

/*
This is a general facility to make serialization of typed structures into
a performant, but tight string-representations.
It uses a cache of strings and objects, so when deserialization, we do not
use as much memory, since objects can be reused by pointers.

TODO:
- Handle the situation where the struct signatures drift, with fixups or otherwise
- Optimize the representation. We are pretty stupid around int, string & 
  double being bigger than they need to be
- Check that emojiis are handled correctly
- Better error checking on array out of bounds and such
*/

export {
	// Given the type definitions and default values of types in play,
	// serialize this given value to a string
	serializeSpeedy(structs : Tree<string, SpeedyStruct>, value : flow) -> string;

	// Given the current type definitions and default values of types in play,
	// deserialize this string as best as possible
	deserializeSpeedy(structs : Tree<string, SpeedyStruct>, onError : (string) -> void, value : string) -> flow;
		SpeedyStruct(struct : SpeedyStructDef, defValue : flow);

	SpeedyStructDef(id : string, typars : [string], structArgs : [SpeedyStructArg]);
		SpeedyStructArg(id : string, type : SpeedyType);
	SpeedyType(id : string, typars : [SpeedyType]);
}

SpeedyOut(
	onError : (string) -> void,
	structs : Tree<string, SpeedyStruct>,
	structIds : Tree<string, int>,
	output : ref List<string>,
	// Cache for objects & strings
	objects : ref Tree<flow, int>,
	// Id of the next object
	nobject : ref int
);

/*
Format:

speedy0
<int> : number of struct definitions
<structdef>
...
<structdef>
<value>

--

<structdef>: 
	<string>	Name of the struct
	<int> 		is # fields
	<structfield>
	...
	<structfield>

<structfield>:
	<string>	Name of the field
	<type>

<type>:
	<string>	Name of the type
	<int>		# type pars
	<type>
	...
	<type>

--

<bool>
	t	true
	f	false

<string>
	S : empty string
	s<int><chars> : string of <int> chars
	o<int>  : object #int from cache

<int>:
	0		: 0 int
	1<hex>  : int of 1 char in hex
	2<hex>  : int of 2 chars in hex
	...
	8<hex>  : int of 8 chars in hex

<double>:
	D		: 0.0 double
	d<int>d	: double in ASCII format

<struct>:
	c
	<int> : index of the struct from the manifest
	<structvalue>
	<structvalue>
	...

<structvalue>:
	=		The default value
	<value>

<array>
	A	The empty array
	a<int><values>
*/

serializeSpeedy(structs : Tree<string, SpeedyStruct>, value : flow) -> string {
	// OK, build a manifest from the types
	used = extractSpeedyStructs(structs, println, makeTree(), value);

	ser = SpeedyOut(println, used, 
		foldTree(used, Pair(0, makeTree()), \s, __, acc -> {
			Pair(acc.first + 1, setTree(acc.second, s, acc.first))
		}).second,
		ref makeList1("speedy0"), ref makeTree(), ref 0
	);

	// Serialize the structure of all structs we use
	soutInt(ser, sizeTree(used));
	traverseInOrder(used, \s, st -> {
		soutStructSignature(ser, st.struct);
	});

	serializeSpeedyValue(ser, value);

	list2string(
		^(ser.output)
	);
}

// Find which structs are referenced in this value
// TODO: We could also build up the cache of objects in this pass
extractSpeedyStructs(structs : Tree<string, SpeedyStruct>, onError : (string) -> void, 
	acc : Tree<string, SpeedyStruct>, value : flow) -> Tree<string, SpeedyStruct> {
	if (isSameStructType(value, value)) {
		// OK, it is a struct
		name = value.structname;
		mspeedy = lookupTree(structs, name);
		mspeedy ?? {
			acc1 = setTree(acc, name, mspeedy);
			args = extractStructArguments(value);
			fold(args, acc1, \acc2, arg -> {
				if (isSameStructType(arg, arg) || isArray(arg)) {
					// OK, it could have structure
					extractSpeedyStructs(structs, onError, acc2, arg)
				} else {
					// Basic types without internal structure
					acc2;
				}
			});
		} : {
			onError("Unknown structure " + name);
			acc;
		}
	} else if (isArray(value)) {
		fold(value, acc, \acc2, val -> {
			extractSpeedyStructs(structs, onError, acc2, val)
		})
	} else {
		onError("Expected structure");
		acc;
	}
}

// Build a manifest of how each structure is laid out
soutStructSignature(sout : SpeedyOut, d : SpeedyStructDef) -> void {
	soutString(sout, d.id);
	soutInt(sout, length(d.structArgs));
	iter(d.structArgs, \sa -> {
		soutString(sout, sa.id);
		soutSpeedyType(sout, sa.type)
	});
}

// Read the struct signature
spinStructSignature(spin : SpeedyIn) -> SpeedyStructDef {
	id = spinString(spin);
	nargs = spinInt(spin);
	SpeedyStructDef(id, [],
		generate(0, nargs, \a -> {
			SpeedyStructArg(spinString(spin), spinSpeedyType(spin))
		}),
	)
}

soutSpeedyType(sout : SpeedyOut, t : SpeedyType) -> void {
	soutString(sout, t.id);
	soutInt(sout, length(t.typars));
	iter(t.typars, \tp -> {
		soutSpeedyType(sout, tp)
	});
}

spinSpeedyType(spin : SpeedyIn) -> SpeedyType {
	name = spinString(spin);
	ntypars = spinInt(spin);
	SpeedyType(
		name,
		generate(0, ntypars, \tp -> {
			spinSpeedyType(spin)
		}),
	)
}

serializeSpeedyValue(sout : SpeedyOut, value : flow) -> void {
	if (isSameStructType(value, value)) {
		// OK, it is a struct
		name = value.structname;
		soutSpeedyTyped(sout, value, SpeedyType(name, []));
	} else if (isArray(value)) {
		if (value ==[]) {
			soutConstant(sout, "A");
		} else {
			array = cast(value : flow -> [flow]);
			len = length(array);
			soutConstant(sout, "a");
			soutInt(sout, len);
			iter(array, \val -> {
				serializeSpeedyValue(sout, val);
			});
		}
	} else {
		sout.onError("Expected structure");
	}
}

// TODO: Arguably, we should also send the default value in here
soutSpeedyTyped(sout : SpeedyOut, value : flow, type : SpeedyType) -> void {
	id = type.id;
	if (id == "array") {
		if (value ==[]) {
			soutConstant(sout, "A");
		} else {
			// TODO: Add check on whether we should cache this or not
			array = cast(value : flow -> [flow]);
			len = length(array);
			soutConstant(sout, "a");
			soutInt(sout, len);
			iter(array, \val -> {
				soutSpeedyTyped(sout, val, type.typars[0]);
			});
		}
	} else if (id == "bool") {
		if (value == true) {
			soutConstant(sout, "t");
		} else {
			soutConstant(sout, "f");
		}
	} else if (id == "int") {
		soutInt(sout, value);
	} else if (id == "double") {
		soutDouble(sout, value);
	} else if (id == "string") {
		soutString(sout, value);
	} else {
		mstruct = lookupTree(sout.structs, id);
		mstruct ?? {
			checkSoutCache(sout, value, \ -> {
				fields : [SpeedyType] = instantiateSpeedyDFields(mstruct.struct, type);
				def = mstruct.defValue;
				args = extractStructArguments(value);
				defargs = extractStructArguments(def);

				// Output the struct #
				structId = lookupTreeDef(sout.structIds, id, -1);
				soutConstant(sout, "c");
				soutInt(sout, structId);
				iteri(args, \i, arg : flow -> {
					if (arg == defargs[i]) {
						// The same as the default value here
						soutConstant(sout, "=");
					} else {
						soutSpeedyTyped(sout, arg, fields[i])
					}
				});
				if (length(args) > 0) {
					addSoutCache(sout, value);
				}
			})
		} : {
			// OK, it is a union. Just go with the struct type then
			serializeSpeedyValue(sout, value);
		}
	}
}

spinValue(spin : SpeedyIn) -> flow {
	char = spinTake(spin, 1);
	if (char == "A") flow([])
	else if (char == "a") {
		len = spinInt(spin);
		flow(generate(0, len, \i -> {
			spinValue(spin);
		}))
	} else if (char == "t") { flow(true)
	} else if (char == "f") { flow(false)
	} else if (char == "0") { flow(0)
	} else if ("1" <= char && char <= "9") {
		h = spinTake(spin, s2i(char));
		flow(parseHex(h));
	} else if (char == "D") { flow(0.0)
	} else if (char == "d") {
		len = spinInt(spin);
		h = spinTake(spin, len);
		flow(s2d(h));
	} else if (char == "S") { ""
	} else if (char == "s") {
		len = spinInt(spin);
		s = spinTake(spin, len);
		if (strlen(s) > 4) {
			addSpinCache(spin, s);
		} else flow(s);
	} else if (char == "o") {
		// cache
		spinCache(spin);
	} else if (char == "c") {
		structId = spinInt(spin);
		structSig = spin.structSignatures[structId];
		mstructDef = lookupTree(spin.structs, structSig.id);
		def = mstructDef ?? {
			mstructDef.defValue;
		} : {
			spin.onError("Unknown struct " + structSig.id);
			None();
		};
		defArgs = extractStructArguments(def);
		args = mapi(structSig.structArgs, \i, sa : SpeedyStructArg -> {
			achar = spinPeek(spin);
			if (achar == "=") {
				// Default value!
				spinTake(spin, 1);
				defArgs[i];
			} else {
				spinValue(spin);
			}
		});
		val = makeStructValue(structSig.id, args, IllegalStruct());

		if (val == IllegalStruct()) {
			spin.onError("Could not make struct " + structSig.id);
		}

		if (length(args) > 0) {
			addSpinCache(spin, val);
		} else val;
	} else {
		spin.onError("Unknown code " + char);
		"";
	}
}

instantiateSpeedyDFields(s : SpeedyStructDef, typename : SpeedyType) -> [SpeedyType] {
	bindings : Tree<string, SpeedyType> = foldi(s.typars, makeTree(), \i, acc, tp -> {
		setTree(acc, tp, typename.typars[i])
	});
	map(s.structArgs, \sa -> {
		instantiateSpeedyTypars(bindings, sa.type)
	})
}

instantiateSpeedyTypars(bindings : Tree<string, SpeedyType>, type : SpeedyType) -> SpeedyType {
	if (type.typars == []) {
		lookupTreeDef(bindings, type.id, type)
	} else {
		SpeedyType(type.id, map(type.typars, \tt -> instantiateSpeedyTypars(bindings, tt)))
	}
}

checkSoutCache(sout : SpeedyOut, value : flow, nonCache : () -> void) -> void {
	mcached = lookupTree(^(sout.objects), value);
	mcached	?? {
		// OK, it is a cached entry.
		soutConstant(sout, "o");
		soutInt(sout, mcached);
	} : {
		nonCache();
	}
}

soutString(sout : SpeedyOut, s : string) -> void {
	checkSoutCache(sout, s, \ -> {
		if (s == "") {
			soutConstant(sout, "S"); // the empty string
		} else {
			soutConstant(sout, "s");
			soutInt(sout, strlen(s));
			soutConstant(sout, s);
	
			// TODO: Mark whether we should cache or not
			if (strlen(s) > 4) {
				addSoutCache(sout, s);
			}
		}
	});
}

spinString(spin : SpeedyIn) -> string {
	char = spinTake(spin, 1);
	if (char == "S") {
		"";
	} else if (char == "s") {
		len = spinInt(spin);
		s = spinTake(spin, len);
		if (strlen(s) > 4) {
			addSpinCache(spin, s);
		} else s;
	} else if (char == "o") {
		// cache
		spinCache(spin);
	} else {
		spin.onError("Expected string");
		"";
	}
}

soutDouble(sout : SpeedyOut, d : double) -> void {
	if (d == 0.0) {
		soutConstant(sout, "D");
	} else {
		h = d2s(d);
		soutConstant(sout, "d");
		soutInt(sout, strlen(h));
		soutConstant(sout, h);
	}
}

soutConstant(sout : SpeedyOut, s : string) -> void {
	sout.output := Cons(s, ^(sout.output));
}

soutInt(sout : SpeedyOut, i : int) -> void {
	if (i == 0) {
		soutConstant(sout, "0");
	} else {
		// OK, format as hex for now
		h = formatHex(i);
		len = strlen(h);
		soutConstant(sout, i2s(len) + h);
	}
}

spinInt(spin : SpeedyIn) -> int {
	char = spinTake(spin, 1);
	if (char == "0") 0
	else {
		h = spinTake(spin, s2i(char));
		parseHex(h);
	}
}


addSoutCache(sout : SpeedyOut, value : flow) -> void {
	n = ^(sout.nobject);
	sout.objects := setTree(^(sout.objects), value, n);
	sout.nobject := n + 1;
}

//
// Deserialization
//


deserializeSpeedy(structs : Tree<string, SpeedyStruct>, onError : (string) -> void, value : string) -> flow {
	if (startsWith(value, "speedy0")) {
		index = ref 7;
		spin0 = SpeedyIn(structs, [], \e -> {
			onError(i2s(^index) + ": " + e)
		}, value, ref [], index);
		nstructs = spinInt(spin0);
		structSigs = generate(0, nstructs, \i -> {
			spinStructSignature(spin0)
		});
		spin = SpeedyIn(spin0 with structSignatures = structSigs);
		spinValue(spin);
	} else {
		onError("Expected speedy0 prefix");
		value;
	}
}

SpeedyIn(
	// This is what we have in the compiled program
	structs : Tree<string, SpeedyStruct>,
	// This is the type index from the file
	structSignatures : [SpeedyStructDef],
	onError : (string) -> void,
	value : string,
	// The cache
	objects : ref [flow],
	// How far are we in the processing?
	i : ref int
);

spinCache(spin : SpeedyIn) -> flow {
	entry = spinInt(spin);
	^(spin.objects)[entry];
}

addSpinCache(spin : SpeedyIn, value : flow) -> flow {
	spin.objects := arrayPush(^(spin.objects), value);
	value;
}

spinTake(spin : SpeedyIn, n : int) -> string {
	i = ^(spin.i);
	spin.i := i + n;
	substring(spin.value, i, n);
}

spinPeek(spin : SpeedyIn) -> string {
	getCharAt(spin.value, ^(spin.i))
}

main() {
	structs = pairs2tree([
		Pair("JsonObject", SpeedyStruct(
			SpeedyStructDef("JsonObject", [], [
				SpeedyStructArg("members", SpeedyType("array", [
					SpeedyType("Pair", [SpeedyType("string", []), SpeedyType("Json", [])])
				]))
			]),
			JsonObject([])
		)),
		Pair("JsonArray", SpeedyStruct(
			SpeedyStructDef("JsonArray", [], [
				SpeedyStructArg("value", SpeedyType("array", [
					SpeedyType("Json", [])
				]))
			]),
			JsonObject([])
		)),
		Pair("JsonBool", SpeedyStruct(
			SpeedyStructDef("JsonBool", [], [
				SpeedyStructArg("v", SpeedyType("bool", []))
			]),
			JsonBool(false)
		)),
		Pair("JsonDouble", SpeedyStruct(
			SpeedyStructDef("JsonDouble", [], [
				SpeedyStructArg("v", SpeedyType("double", []))
			]),
			JsonDouble(0.0)
		)),
		Pair("JsonString", SpeedyStruct(
			SpeedyStructDef("JsonString", [], [
				SpeedyStructArg("v", SpeedyType("string", []))
			]),
			JsonString("")
		)),
		Pair("JsonNull", SpeedyStruct(
			SpeedyStructDef("JsonNull", [], []),
			JsonNull()
		)),
		Pair("Pair", SpeedyStruct(
			SpeedyStructDef("Pair", ["?", "??"], [
				SpeedyStructArg("first", SpeedyType("?", [])),
				SpeedyStructArg("second", SpeedyType("??", []))
			]),
			Pair(0, 0)
		))
	]);

	// OK, test this stuff

	origValue = JsonObject([
		Pair("field", JsonArray([
			JsonDouble(1.0),
			JsonBool(false),
			JsonBool(true),
			JsonString("Hello!"),
			JsonString("Hello!"),
			JsonString("Hello!"),
			JsonString("Hello!"),
			JsonNull(),
		]))
	]);

	serialized = serializeSpeedy(structs, origValue);
	println(serialized);
	value = deserializeSpeedy(structs, println, serialized);
	println(value);
	quit(0);
	{}
}
