import plow/dexp/desugar;
import plow/modules;
import ds/set;
import sys/concurrent;

export {
	// A structure to help do lookups in the modules tree
	DLookupFromImport(
		// A function to lookup a name in a module (not transitively)
		lookup : (DModule, string) -> Maybe<?>,
		// A function to check if this name is exported
		isExported : (DModule, string) -> bool,
		// An error reporter
		onError : (flowpath : string, value : ?, error : string) -> void,
		// A cache to speed up the matching
		cache : ref Tree<string, ?>,
		// During a lookup, we keep track of what modules have been visited
		visited : ref Set<string>,
	);
	
	lookupFromImport(modules : DModules, m : DLookupFromImport<?>, imports : [DImport], name : string) -> Maybe<?>;
}

lookupFromImport(modules : DModules, m : DLookupFromImport<?>, imports : [DImport], name : string) -> Maybe<?> {
	m.visited := makeSet();
	doImportLookup(modules, m, imports, name);
}

doImportLookup(modules : DModules, m : DLookupFromImport<?>, imports : [DImport], name : string) -> Maybe<?> {
	seen = lookupTree(^(m.cache), name);
	seen ?? {
		Some(seen)
	} : {
		mfind = fold(imports, None(), \acc, impor : DImport -> {
			if (acc == None()) {
				module : DModule = getCachedDModule(modules, impor.path);
				modfind = m.lookup(module, name);
				switch (modfind) {
					None(): {
						// OK, not found in our module, so we have to check the imports
						m.visited := insertSet(^(m.visited), impor.path);
						doImportLookup(modules, m, module.imports, name);
					}
					Some(f): {
						if (!m.isExported(module, name)) {
							m.onError(module.fullpath, f, name + " is not exported");
						};
						Some(f);
					}
				}
			} else acc;
		});
		mfind ?? {
			// OK, add to the cache
			m.cache := setTree(^(m.cache), name, mfind);
			Some(mfind);
		} : {
			None();
		}
	}
}
