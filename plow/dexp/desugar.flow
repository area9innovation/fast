import plow/dexp/dexp;
import plow/dexp/desugar_env;
import plow/pexp/pexp;
import plow/pexp/values;
import plow/dexp/unions;
import ds/set;

/*
Differences to PExp:
- It is not a complete Exp type, but has different unions for toplevel, exp, type
- "Temp" structures such as argtype, case, etc are not in exp
- Union match in switch is expanded
TODO:
- We have constructors resolved to not be calls
- The top level is indexed like a tree
- Introduce downcast in switches
- Expand ?? to switch
- Extract let-bindings from cases
- Collect string includes
- Extract structs and unions
- Extract top-level functions from globals
- Should we have an enum with builtins?
*/

export {
	// Desugar a module
	desugarPExp(dd : DDesugar, p : PExp) -> DModule;

	getDummyDModule() -> DModule;

	// Extract the imports only
	getDImports(p : PExp) -> [DImport];

}

getDImports(p : PExp) -> [DImport] {
	module = getPModule(p);
	filtermap(module.toplevels, \tl -> {
		switch (tl) {
			PImport(path, pos): Some(DImport(path, pos));
			default: None();
		}
	});
}

getDummyDModule() -> DModule {
	DModule("",[], [], DExport([], -1), makeTree(), makeTree(), makeTree(), [], -1);
}

desugarPExp(dd : DDesugar, pexp : PExp) -> DModule {
	module = getPModule(pexp);
	if (module.pos == -1) dd.onError(pexp.pos, "Expected module");

	imports = getDImports(pexp);
	forbids = filtermap(module.toplevels, \tl -> {
			switch (tl) {
				PForbid(path, pos): {
					if (path == "") dd.onError(pos, "Unknown forbid path");
					Some(DForbid(path, pos));
				}
				default: None();
			}
		});

	// Extract structs & unions in our module, so we can include those in the lookup
	structs = fold(module.toplevels, makeTree(), \acc, tl -> {
		extractDStruct(dd, acc, tl)
	});
	unions = fold(module.toplevels, makeTree(), \acc, tl -> {
		extractDUnion(dd, acc, tl)
	});

	// Make sure our lookup knows about local structs and unions
	dd2 = DDesugar(dd with 
		resolveStructName = \name -> {
			mst = lookupTree(structs, name);
			mst ?? Some(mst) : dd.resolveStructName(name);
		},
		resolveUnionName = \name -> {
			mst = lookupTree(unions, name);
			mst ?? Some(mst) : dd.resolveUnionName(name);
		},
	);

	dummyExport = DExport([], pexp.pos);
	exports = fold(module.toplevels, dummyExport, \acc, tl : PTopLevel -> {
		switch (tl) {
			PExport(tls, p): {
				if (acc != dummyExport) {
					dd.onError(p, "Only one export section is allowed");
				}
				DExport(
					map(tls, \t -> ptoplevel2DToplevel(dd2, t)),
					p
				);
			}
			default: acc;
		}
	});

	toplevels0 = fold(module.toplevels, Pair(makeTree(), makeList()), \acc, tl : PTopLevel -> {
		set = \name -> {
			mdef = lookupTree(acc.first, name);
			mdef ?? {
				// TODO: If the definitions are compatible, we should not complain, but
				// keep them separately
				dd.onError(tl.pos, "Redefinition of " + name);
				dd.onError(mdef.pos, "Previous definition is here");
			} : {}
			Pair(
				setTree(acc.first, name, ptoplevel2DToplevel(dd2, tl)),
				Cons(name, acc.second)
			)
		}
		switch (tl) {
			PGlobal(id, value, pos): set(id);
			PNative(id, isIo, type, name, pos): set(id);
			PUnion(typename, types, pos): set(typename.id);
			PStruct(id, structArgs, pos): set(id);
			PTypeDef(id, type, pos): set(id);
			default: acc;
		}
	});

	DModule(
		dd.flowpath,
		imports,
		forbids,
		exports,
		structs,
		unions,
		toplevels0.first,
		list2array(toplevels0.second),
		pexp.pos,
	);
}

ptoplevel2DToplevel(dd : DDesugar, tl : PTopLevel) -> DTopLevel {
	error = \ -> {
		dd.onError(tl.pos, "Expected global, native, function, union, struct or type def");
		DStruct("", [], tl.pos);
	}
	switch (tl) {
		PModule(toplevels, pos): error();
		PImport(path, pos): error();
		PForbid(path, pos): error();
		PExport(exports, pos): error();
		PGlobal(id, value, pos): DGlobal(id, pexp2dexp(dd, value), pos);
		PNative(id, isIo, type, name, pos): DNative(id, isIo, ptype2dtype(dd, type), name, pos);
		PUnion(typename, types, pos): DUnion(ptypename2dtypename(dd, typename), map(types, \t -> ptypename2dtypename(dd, t)), pos);
		PStruct(id, structArgs, pos): DStruct(id, map(structArgs, \sa -> pstructArg2dstructArg(dd, sa)), pos);
		PStructArg(id, ismutable, type, pos): error();
		PTypeDef(id, type, pos): DTypeDef(id, ptype2dtype(dd, type), pos);
	}
}

extractDStruct(dd : DDesugar, acc : Tree<string, DStruct>, tl : PTopLevel) -> Tree<string, DStruct> {
	switch (tl) {
		PStruct(id, structArgs, pos): {
			dstruct = DStruct(id, map(structArgs, \sa -> pstructArg2dstructArg(dd, sa)), pos);
			setTree(acc, id, dstruct);
		}
		PExport(exports, __): fold(exports, acc, \acc2, ex : PTopLevel -> extractDStruct(dd, acc2, ex));
		default: acc;
	}
}

extractDUnion(dd : DDesugar, acc : Tree<string, DUnion>, tl : PTopLevel) -> Tree<string, DUnion> {
	switch (tl) {
		PUnion(typename, types, pos): {
			dunion = DUnion(ptypename2dtypename(dd, typename), map(types, \t -> ptypename2dtypename(dd, t)), pos);
			setTree(acc, typename.id, dunion);
		}
		PExport(exports, __): fold(exports, acc, \acc2, ex : PTopLevel -> extractDUnion(dd, acc2, ex));
		default: acc;
	}
}

pexp2dexp(dd : DDesugar, pexp : PExp) -> DExp {
	error = \ -> {
		dd.onError(pexp.pos, "Expected expression, got " + toString(pexp));
		DVoid(pexp.pos);
	}
	rec = \ee -> pexp2dexp(dd, ee);
	switch (pexp) {
		PVoid(pos): DVoid(pos);
		PBool(v, pos): DBool(v, pos);
		PInt(v, pos): DInt(v, pos);
		PDouble(v, pos): DDouble(v, pos);
		PString(v, pos): DString(v, pos);
		PVar(var, pos): DVar(var, pos);
		PCallOp(op, args, pos): DCallOp(op, map(args, rec), pos);
		PStringInclude(path, pos): DStringInclude(path, pos);
		PLet(var, value, body, pos): DLet(var, rec(value), rec(body), pos);
		PIf(cond, then, else_, pos): DIf(rec(cond), rec(then), rec(else_), pos);
		PCall(fn, args, pos): {
			// Check if this is a struct constructor
			switch (fn) {
				PVar(id, __): {
					mst = dd.resolveStructName(id);
					mst ?? {
						DConstruct(mst.id, map(args, rec), pos);
					} : DCall(rec(fn), map(args, rec), pos);
				}
				default: DCall(rec(fn), map(args, rec), pos);
			}
		}
		PLambda(args, body, pos): DLambda(map(args, \a -> {
			DArgType(a.id, ptype2dtype(dd, a.type), a.pos)
		}), rec(body), pos);
		PRef(value, pos): DRef(rec(value), pos);
		PSetMutable(lhs, field, value, pos): DSetMutable(rec(lhs), field, rec(value), pos);
		PArray(exps, pos): DArray(map(exps, rec), pos);
		PSequence(exps, pos): {
			dexps = map(exps, rec);
			if (exps == []) DVoid(pos)
			else if (length(dexps) == 1) dexps[0]
			else DSequence(dexps, pos);
		}
		PSwitch(value, cases, pos): desugarPSwitch(dd, pexp);
		PCast(value, target, pos): DCast(rec(value), ptype2dtype(dd, target), pos);
		PTyped(value, type, pos): DTyped(rec(value), ptype2dtype(dd, type), pos);
		PWith(struct, value, fields, pos): desugarPWith(dd, pexp);
		PMaybe(value, match, otherwise, pos): desugarPMaybe(dd, pexp);

		PModule(toplevels, pos): error();
		PImport(path, pos): error();
		PForbid(path, pos): error();
		PExport(exports, pos): error();
		PGlobal(id, value, pos): error();
		PNative(id, isIo, type, name, pos): error();
		PUnion(typename, types, pos): error();
		PStruct(id, structArgs, pos): error();
		PStructArg(id, ismutable, type, pos): error();
		PTypeDef(id, type, pos): error();
		PTypePar(id, pos): error();
		PTypeName(id, typars, pos): error();
		PTypeFunction(args, returnType, pos): error();
		PArgType(id, type, pos): error();

		PList(l, pos): error();
		PFieldAssign(id, value, pos): error();
		PCase(id, args, body, pos): error();
	}
}

ptype2dtype(dd : DDesugar, p : PType) -> DType {
	switch (p) {
		PTypePar(id, pos): DTypePar(id, pos);
		PTypeName(id, typars, pos): ptypename2dtypename(dd, p);
		PTypeFunction(args, returnType, pos): DTypeFunction(map(args, \at -> ptype2dtype(dd, at)), ptype2dtype(dd, returnType), pos);
		PArgType(id, type, pos): ptype2dtype(dd, type); // We just drop the name
	}
}

ptypename2dtypename(dd : DDesugar, p : PTypeName) -> DTypeName {
	DTypeName(p.id, map(p.typars, \tp -> ptype2dtype(dd, tp)), p.pos);
}

pstructArg2dstructArg(dd : DDesugar, s : PStructArg) -> DStructArg {
	DStructArg(s.id, s.ismutable, ptype2dtype(dd, s.type), s.pos)
}

desugarPSwitch(dd : DDesugar, s : PSwitch) -> DSwitch {
	defaults = filter(s.cases, \c : PCase -> c.id == "default");
	def : Maybe<DExp> = if (length(defaults) == 1) Some(pexp2dexp(dd, defaults[0].body))
		else if (defaults == []) None()
		else {
			dd.onError(defaults[0].pos, "Only one default allowed in switch");
			None();
		};

	cases : [DCase] = filtermap(s.cases, \c : PCase -> {
		if (c.id == "default") None()
		else {
			if (c.args != []) {
				println("TODO: Let-bind these in case: " + toString(c.args));
			};
			Some(DCase(c.id, pexp2dexp(dd, c.body), c.pos))
		}
	});

	// Collect the struct names we have explicitly named
	structs : Set<string> = fold(cases, makeSet(), \acc, case -> {
		mstruct = dd.resolveStructName(case.id);
		mstruct ?? {
			if (containsSet(acc, case.id)) {
				dd.onError(case.pos, "Duplicate case " + case.id);
			}
			insertSet(acc, case.id)
		} : acc;
	});

	// Expand union cases
	unions = concatA(map(cases, \c : DCase -> {
		if (containsSet(structs, c.id)) {
			// Already a struct, keep it as is
			[c]
		} else {
			// A union - expand to the cases we do not already have
			casestructs = expandDTypename2structs(dd, c.id);
			newStructs = filter(casestructs, \ss : DStruct -> {
				!containsSet(structs, ss.id)
			});
			if (newStructs == []) {
				dd.onError(c.pos, "Union case " + c.id + " is superfluous");
			}

			map(newStructs, \str -> {
				DCase(str.id, c.body, c.pos)
			})
		}
	}));

	DSwitch(
		pexp2dexp(dd, s.value),
		unions, def, s.pos
	)
}

desugarPWith(dd : DDesugar, w : PWith) -> DWith {
	mstruct = dd.resolveStructName(w.struct);
	mstruct ?? {
		DWith(w.struct, pexp2dexp(dd, w.value), 
			map(w.fields, \f : PFieldAssign -> {
				// TODO: Check that this field exists in this struct
				DFieldAssign(f.id, pexp2dexp(dd, f.value), f.pos)
			}), w.pos)
	} : {
		dd.onError(w.pos, "Unknown struct for with: " + w.struct);
		DWith(w.struct, pexp2dexp(dd, w.value), [], w.pos)
	}
}

desugarPMaybe(dd : DDesugar, m : PMaybe) -> DExp {
	// PMaybe(value, match, otherwise, pos);
	println("TODO: Expand maybe");
	pexp2dexp(dd, m.otherwise);
}
	
