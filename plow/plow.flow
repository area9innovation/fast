import plow/pexp/parse;
import plow/dexp/desugar;
import fs/filesystem;

main() {
	file3 = "mini/tests/positions.flow";
	file = "mini/tests/fold.flow";
	file1 = "c:/flow9/lib/formats/unicode/unidecode.flow";
	file2 = "c:\\lyceum/components/rhapsode_server/rhapsode_server/api/isams/import_data.flow";
	file0 = "c:\\fast\\mini";

	if (!isDirectory(file)) {
		d = parseAndDesugar(file, println);
		println(d);
	} else {
		files = filter(readDirectoryRecursively(file), \f -> endsWith(f, ".flow"));
		t = timestamp();

		errors = ref 0;
		iter(files, \fil -> {
			// println(fil);
			if (^errors < 1000) {
				d = parseAndDesugar(fil, \error -> {
					errors := ^errors + 1;
					println(error)
				});
			}
		});	

		println(timestamp() - t);
	}
	quit(0);
}

makeOnError(file : string, onError : (string) -> void) -> (int, string) -> void {
	resolver = ref None();
	\pos, error -> {
		res = onlyOnce(resolver, \ -> {
			text = getFileContent(file);
			makeLineResolver(text);
		});
		linecol = findLine(res, pos); // maxi
		onError(
			file + ":" + i2s(linecol.lineno) + ":" + i2s(linecol.column) + ": " + error
			+ "\n" + linecol.line
			+ "\n" + lpad("^", " ", linecol.lineIndex - 1)
		);
	}
}

parseAndDesugar(file : string, onError : (string) -> void) -> DModule {
	code = getFileContent(file);
	p = parsePExp(code, \e -> onError(file + ":" + e));
	// prettyPos(code, "", p);

	dd = DDesugar(file, \n -> {
		onError(file + ": TODO: Find this struct " + n);
		None()
	}, \n -> {
		onError(file + ": TODO: Find this union " + n);
		None()
	}, makeOnError(file, onError));

	desugarPExp(dd, p);
}

prettyPos(input : string, i : string, p : PExp) -> void {
	rec = \e -> prettyPos(input, i + " ", e);
	pr = \s : string -> {
		line = if (p.pos == -1) "MISSING POS " + p.structname else substring(input, p.pos, 20);
		println(i + s + ": \"" + takeBefore(line, "\n", line) + "\"");
	}
	switch (p) {
		PVoid(pos): pr("void");
		PBool(v, pos): pr("bool");
		PInt(v, pos): pr("int");
		PDouble(v, pos): pr("double");
		PString(v, pos): pr("string");
		PLambda(args, body, pos): {
			pr("lambda");
			rec(body);
		}
		PModule(tl, pos): {
			pr("module");
			iter(tl, rec);
		}
		PImport(path, pos): pr("import " + path);
		PForbid(path, pos): pr("forbid " + path);
		PExport(exports, pos): {
			pr("export");
			iter(exports, rec);
		}
		PGlobal(id, value, pos): {
			pr("global " + id);
			rec(value);
		}
		PNative(id, isIo, type, name, pos): {
			pr("native def");
			rec(type);
		}
		PUnion(typename, types, pos): {
			pr("union");
			rec(typename);
			iter(types, rec);
		}
		PStruct(id, structArgs, pos): {
			pr("struct " + id);
			iter(structArgs, rec);
		}
		PStructArg(id, ismutable, type, pos): {
			pr("struct arg" + id);
			rec(type);
		}
		PTypeDef(id, type, pos): {
			pr("typedef " + id);
			rec(type);
		}
		PTypePar(id, pos): pr(id);
		PTypeName(id, typars, pos): {
			pr("typename " + id);
			iter(typars, rec);
		}
		PTypeFunction(args, returnType, pos): {
			pr("function type");
			iter(args, rec);
			rec(returnType);
		}
		PArgType(id, type, pos): {
			pr("arg " + id);
			rec(type);
		}
		PStringInclude(path, pos): {
			pr("String include " + path);
		}
		PVar(var, pos): {
			pr("var " + var);
		}
		PLet(var, value, body, pos): {
			pr("let " + var);
			rec(value);
			rec(body);
		}
		PIf(cond, then, else_, pos): {
			pr("if");
			rec(cond);
			rec(then);
			rec(else_);
		}
		PCall(fn, args, pos): {
			pr("call");
			rec(fn);
			iter(args, rec);
		}
		PCallOp(op, args, pos): {
			pr("op: " + op);
			iter(args, rec);
		}
		PRef(value, pos): {
			pr("ref");
			rec(value);
		}
		PSetMutable(lhs, field, value, pos): {
			pr("set mutable field" + field);
			rec(lhs);
			rec(value);
		}
		PArray(exps, pos): {
			pr("array");
			iter(exps, rec);
		}
		PSequence(exps, pos): {
			pr("sequence");
			iter(exps, rec);
		}
		PSwitch(value, cases, pos): {
			pr("switch");
			rec(value);
			iter(cases, rec);
		}
		PCase(id, args, body, pos): {
			pr("case " + id + "(" + strGlue(args, ", ") + ")");
			rec(body);
		}
		PCast(value, target, pos): {
			pr("cast");
			rec(value);
			rec(target);
		}
		PTyped(value, type, pos): {
			pr("typed");
			rec(value);
			rec(type);
		}
		PWith(struct, value, fields, pos): {
			pr("with " + struct);
			rec(value);
			iter(fields, rec);
		}
		PFieldAssign(id, value, pos): {
			pr("field " + id);
			rec(value);
		}
		PMaybe(value, match, otherwise, pos): {
			pr("maybe");
			rec(value);
			rec(match);
			rec(otherwise);
		}
		PList(l, pos): {
			pr("list");
			iterList(l, rec)
		}
	}
}
