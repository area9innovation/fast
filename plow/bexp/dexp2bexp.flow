import plow/dexp/dexp;
import plow/dexp/pretty;
import plow/types/typeenv;
import plow/types/builtin;
import plow/bexp/bexp;

export {
	dexp2bexp(env : BExpEnv, d : DExp) -> BExp;

	BExpEnv(
		onError : (int, string) -> void,
		tgraph : TypeGraph,
		eclassType : Tree<int, TType>,
	);

	resolveBType(env : BExpEnv, pos : int, eclass : int) -> BType;
}

resolveBType(env : BExpEnv, pos : int, eclass : int) -> BType {
	root = rootTTypeEClass(env.tgraph, eclass);
	mtype = lookupTree(env.eclassType, root);
	mtype ?? {
		if (false && unresolvedTType(mtype)) {
			env.onError(pos, "Partially unresolved type " + prettyTType(mtype));
		}
		ttype2btype(env, mtype)
	} : {
		env.onError(pos, "Unresolved type equivalence class " + i2s(root));
		BTypeName("Error!", []);
	}
}

dexp2bexp(env : BExpEnv, d : DExp) -> BExp {
	todo = \ -> {
		println("TODO: dexp2bexp for " + d.structname);
		// prettyDExp("", "", d);
		BString("ERROR!");
	}
	rec = \ee -> {
		dexp2bexp(env, ee);
	}
	type = \eclass : int -> resolveBType(env, d.pos, eclass);
	switch (d) {
		DVoid(pos): BVoid();
		DBool(v, pos): BBool(v);
		DInt(v, pos): BInt(v);
		DDouble(v, pos): BDouble(v);
		DString(v, pos): BString(v);
		DStringInclude(path, pos): {
			BString(getFileContent(path));
		}
		DVar(id, pos, eclass): {
			BVar(id, type(eclass));
		}
		DLet(id, value, body, pos, eclass): BLet(id, rec(value), rec(body), type(eclass));
		DIf(cond, then, else_, pos, eclass): BIf(rec(cond), rec(then), rec(else_), type(eclass));
		DCall(fn, args, pos, eclass): {
			BCall(rec(fn), map(args, rec), type(eclass))
		}
		DConstruct(structid, args, pos, eclass): {
			BConstruct(structid, map(args, rec), type(eclass))
		}
		DLambda(args, body, pos, eclass): {
			BLambda(map(args, \a -> a.id), rec(body), type(eclass));
		}
		DRef(value, pos, eclass): {
			typ = type(eclass);
			// The type of __ref is not right, but should not matter. It is really (typar_0_of(typ)) -> typ
			BCall(BVar("__ref", typ), [rec(value)], typ);
		}
		DField(value, field, pos, eclass): BField(rec(value), field, type(eclass));	
		DSetMutable(lhs, field, value, pos, eclass): {
			BSetMutable(rec(lhs), field, rec(value), type(eclass))
		}
		DArray(exps, pos, eclass): {
			typ = type(eclass);
			// The type of __array is not right, but should not matter. It is really (typar_0_of(typ)) -> typ
			BCall(BVar("__array", typ), map(exps, rec), typ);
		}
		DSequence(exps, pos, eclass): BSequence(map(exps, rec), type(eclass));
		DSwitch(value, stype, cases, defaultCase, pos, eclass): {
			swtype = type(value.eclass);
			BSwitch(
				BVar(value.id, swtype), swtype,
				map(cases, \case : DCase -> {
					BCase(case.id, rec(case.body))
				}),
				defaultCase ?? {
					Some(rec(defaultCase))
				} : None(),
				type(eclass)
			);
		}
		DCast(value, target, pos): {
			// We probably do not need this in the backends. It is purely a type checking thing
			rec(value);
		}
		DDowncast(oldid, newid, subtype, scope, pos, eclass): {
			// We probably do not need this in the backends. It is purely a type checking thing
			rec(scope);
		}
		DTyped(value, subtype, pos): rec(value);
		DWith(struct, value, fields, pos, eclass): todo();
	}
}

ttype2btype(env : BExpEnv, type : TType) -> BType {
	switch (type) {
		TTypeName(id, typars): BTypeName(id, map(typars, \tp -> ttype2btype(env, tp)));
		TTypeEClass(eclass): {
			BTypeName("ERROR TYVAR " + i2s(eclass), []);
		}
		TTypeFunction(args, returnType): {
			BTypeFunction(map(args, \a -> ttype2btype(env, a)), ttype2btype(env, returnType));
		}
		TTypeOverload(tt, overloads): {
			BTypeName("ERROR overload " + toString(tt), []);
		}
		TTypeSupertype(__, subtypes): {
			BTypeName("ERROR supertype", []);
		}
	}
}
