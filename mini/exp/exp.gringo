flow = '\uFEFF'? ws importExport* toplevelDeclaration*;

importExport = import
	| dynamicImport
	| export
	| forbid;

import = "import" s $path ws ';' ws $$".flow" $"changeFileExt" $"parsefile";
dynamicImport = "require" s $path ws ';' ws; // TODO: AST
export = "export" ws '{' ws toplevelDeclaration+ '}' ws; // TODO: AST
forbid = "forbid" s $path ws ';' ws; // TODO: AST
	path = bid ('/' bid)*;

toplevelDeclaration = 
	native
	| assign
	| union
	| function
	| structdecl
	| vardecl;

// TODO: AST
native = "native" s id ws ':' ws ("io" ws)? type '=' ws $name ws ';' ws;
	name = bid ('.' bid)*;

assign = id ws '=' ws exp ';'? ws $"define";

// TODO: AST for typars
union = id ws (typars $"drop")? ws "::=" ws typenames ';' ws $$"union" $"swap" $"typecall" $"define";

	// listof(typename, ",")
	typenames = $"nil" typename $"cons" ("," ws typename $"cons")* ("," ws)? | $"nil";

// For now, we ignore the types
// TODO: Extract the type and use a binop to declare the type of the body
function = 
	  id ws '(' ws funargs ')' ws (returnType $"drop")? ';' ws
	| id ws '(' ws funargs ')' ws returnType $"drop" brace_or_semi $"lambda" $"define"
	| id ws '(' ws funargs ')' ws brace_or_semi $"lambda" $"define"
	| id ws '(' ws funargs ')' ws exp ';'? ws $"lambda" $"define"
	;

	// listof(funarg, ",")
	funargs = $"nil" funarg $"cons" ("," ws funarg $"cons")* ("," ws)? | $"nil";

	// For now, we just drop the types
	funarg = id ws (':' ws type $"drop")?;
	returnType = "->" ws type;

	brace_or_semi = brace ';'? ws;

// TODO: AST and mutable
structdecl = id ws ':' ws '(' ws funargs ')' ws ';' ws;

vardecl = id ws ':' ws type '=' ws exp ';'? ws  $"swap" $$":" $"binop" $"define"
	// TODO: AST, and how to do it?
	| id ws ':' ws type ';'? ws;

exp = (
		"if" ws "(" $"nil" exp $"cons" ")" ws exp $"cons" "else" ws exp $"cons" $$"ife" $"swap" $"call"
		| "if" ws "(" $"nil" exp $"cons" ")" ws exp $"cons" $$"if" $"swap" $"call"
		| id ws "=" ws exp ";" ws exp $"let"
	 	| id ws ":" type "=" ws exp ";" $"swap" $$":" $"binop" ws exp $"let"
		// exp "." field ::= exp
	)
	|> exp "||" ws exp $$"||" $"binop"
	|> exp "&&" ws exp $$"&&" $"binop"
	|> (
		exp "==" ws exp $$"==" $"binop"
		| exp "!=" ws exp $$"!=" $"binop"
		| exp "<=" ws exp $$"<=" $"binop"
		| exp "<" ws exp $$"<" $"binop"
		| exp ">=" ws exp $$">=" $"binop"
		| exp ">" ws exp $$">" $"binop"
	)
	|> (exp "+" ws exp $$"+" $"binop"
		| exp "-" ws exp $$"-" $"binop"
	)
	|> (exp "*" ws exp $$"*" $"binop"
		| exp "/" ws exp $$"/" $"binop"
		| exp "%" ws exp $$"%" $"binop"
	)
	// maybe ?? exp : exp

	|> (
		'!' ws exp $$"not" $"unop"
		| '-' ws exp $$"neg" $"unop"
		| backslash lambdaargs ws "->" ws exp $"lambda"
		| exp "(" ws exps ")" ws $"call"
		| exp "." ws id ws $$"." $"binop"
		| exp "[" ws exp "]" ws $$"index" $"binop"
		// '(' ws call "with" s fields ')' ws;
	)

	|> exp ":" ws type $$":" $"binop"

	|> (
		"(" ws exp ")" ws 
		| "true" ws $"1" $"1" $"inttype" $$":" $"binop"
		| "false" ws $"0" $"1" $"inttype" $$":" $"binop"
		| id ws $"var"
		| $('0'-'9'+ "." '0'-'9'*) $"s2d"
		| $("." '0'-'9'+) $"s2d"
		| int ws $"s2i"
		| brace
		| string
		| "[" ws exps "]" $$"[" $"unop"
		| '^' ws exp $$"deref" $"unop"
	);

// TODO: Maybe this should be binops instead of an array?
brace = "{" ws expsemis "}" ws $$";" $"var" $"swap" $"call";

type = 	
		"bool" ws $"1" $"inttype"
		| "int" ws $"32" $"inttype"
		| "double" ws $$"double" $"nil" $"typecall"
		| "string" ws $$"string" $"nil" $"typecall"
		| "flow" ws $$"flow" $"nil" $"typecall"
		| "void" ws $$"void" $"nil" $"typecall"
		| "native" ws $$"native" $"nil" $"typecall"
		| "ref" ws type $"list1" $$"ref" $"swap" $"typecall"
		| typename
		| "[" ws type "]" ws $"list1" $$"array" $"swap" $"typecall"
		| $("?"+) $"nil" $"typecall"
		| "(" ws types ")" ws "->" type $"fntype"
	;

typename = id ws typars $"typecall"
		| id ws $"nil" $"typecall";

typars = "<" ws types ">" ws;

// listof(type, ",")
types = $"nil" type $"cons" ("," ws type $"cons")* ("," ws)?
	| $"nil";

lambdaargs = $"nil" (id ws $"cons")*;

// listof(exp, ";")
expsemis = $"nil" exp $"cons" (";" ws exp $"cons")* (";" ws)?
	| $"nil";

// listof(exp, ",")
exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)?
	| $"nil";

// TODO: AST
string = '"' "#inc" "lude" s path '"' ws
	| singlestring
	| $"nil" (singlestring $"cons")+ $"concatStrings"
	;

singlestring = '"' $(onechar_)* '"' ws;

onechar_ = backslash "u" hexdigit_ hexdigit_ hexdigit_ hexdigit_
	| backslash "X" hexdigit_ hexdigit_ hexdigit_ hexdigit_
	| backslash "x" hexdigit_ hexdigit_
	| backslash escapedchar_
	| !'"' !backslash char_;

hexdigit_ = '0'-'9'
	| 'a'-'f'
	| 'A'-'F';

escapedchar_ = backslash | '"' | "n" | "t" | "r";

char_ = '0x0000'-'0xffff';

id = $bid;

bid = ('a'-'z' | 'A'-'Z' | '_') ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')*;

int = $'0'-'9'+;

backslash = '\';

ws = s*;
s = " " | "	" | "
";
flow
