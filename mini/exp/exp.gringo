flow = '\uFEFF'? ws importExport* toplevelDeclaration*;

importExport = import
	| dynamicImport
	| export
	| forbid;

import = "import" s $path ws ';' ws $$".flow" $"changeFileExt" $"parsefile";
dynamicImport = "require" s $path ws ';' ws; // TODO: AST
export = "export" ws '{' ws toplevelDeclaration+ '}' ws; // TODO: AST
forbid = "forbid" s $path ws ';' ws; // TODO: AST

	path = bid path_more*;
		path_more = '/' bid;

toplevelDeclaration = 
	native
	| assign
	| union
	| function
	| structdecl
	| vardecl;

// TODO: AST
native = "native" s id ws ':' ws ("io" ws)? type '=' ws $name ws ';' ws;
	name = bid ('.' bid)*;

assign = id ws '=' ws exp ';'? ws $"define";

// TODO: AST for typars
union = id ws (typars $"drop")? ws "::=" ws typenames ';' ws $$"union" $"swap" $"typecall" $"define";

	// listof(typename, ",")
	typenames = $"nil" typename $"cons" ("," ws typename $"cons")* ("," ws)?
		| $"nil";

// For now, we ignore the types
// TODO: Extract the type and use a binop to declare the type of the body
function = id ws '(' ws funargs ')' ws (returnType $"drop")? ';' ws // TODO: AST for type?
	| id ws '(' ws funargs ')' ws returnType $"drop" brace_or_semi $"lambda" $"define"
	| id ws '(' ws funargs ')' ws exp ';'? ws $"lambda" $"define"
	;

	// listof(funarg, ",")
	funargs = $"nil" funarg $"cons" ("," ws funarg $"cons")* ("," ws)?
		| $"nil";

	// For now, we just drop the types
	funarg = id ws (':' ws type $"drop")?;
	returnType = "->" ws type;

	brace_or_semi = brace ';'? ws;

// TODO: AST and mutable
structdecl = id ws ':' ws '(' ws funargs? ')' ws ';' ws;

vardecl = id ws ':' ws type '=' ws exp ';'? ws  $"swap" $$":" $"binop" $"define"
	// TODO: AST
	| id ws ':' ws type ';'? ws;

exp = 
	brace

	|> (
		id ws "=" ws exp ";" ws exp $"let"
	 	| id ws ":" type "=" ws exp ";" $"swap" $$":" $"binop" ws exp $"let"
	)

	|> '\' lambdaargs ws "->" ws exp $"lambda"

	|> exp "(" ws exps ")" ws $"call"

	|> exp ":" ws type $$":" $"binop"

	|> (
		"(" ws exp ")" ws 
		| "true" ws $"1" $"1" $"inttype" $$":" $"binop"
		| "false" ws $"0" $"1" $"inttype" $$":" $"binop"
		| id ws $"var"
		| $('0'-'9'+ "." '0'-'9'*) $"s2d"
		| $("." '0'-'9'+) $"s2d"
		| int ws $"s2i"
	);

// TODO: Maybe this should be binops instead of an array?
brace = "{" ws expsemis "}" ws $$";" $"var" $"swap" $"call";

type = 	
		"bool" ws $"1" $"inttype"
		| "int" ws $"32" $"inttype"
		| "double" ws $$"double" $"nil" $"typecall"
		| "string" ws $$"string" $"nil" $"typecall"
		| "flow" ws $$"flow" $"nil" $"typecall"
		| "void" ws $$"void" $"nil" $"typecall"
		| "native" ws $$"native" $"nil" $"typecall"
		| "ref" ws type $"list1" $$"ref" $"swap" $"typecall"
		| typename
		| "[" ws type "]" ws $"list1" $$"array" $"swap" $"typecall"
		| $("?"+) $"nil" $"typecall"
		| "(" ws types ")" ws "->" type $"fntype"
	;

typename = id ws typars $"typecall"
		| id ws $"nil" $"typecall";

typars = "<" ws types ">" ws;

// listof(type, ",")
types = $"nil" type $"cons" ("," ws type $"cons")* ("," ws)?
	| $"nil";

lambdaargs = $"nil" (id ws $"cons")*;

// listof(exp, ";")
expsemis = $"nil" exp $"cons" (";" ws exp $"cons")* (";" ws)?
	| $"nil";

// listof(exp, ",")
exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)?
	| $"nil";

id = $bid;

bid = ('a'-'z' | 'A'-'Z' | '_') ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')*;

int = $'0'-'9'+;

ws = s*;
s = " " | "	" | "
";
flow
