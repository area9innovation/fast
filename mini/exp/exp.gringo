flow = '\uFEFF'? ws importExport* toplevelDeclaration*;

importExport = import
	| dynamicImport
	| export
	| forbid;

// TODO: We should set some marker that a new file is started, instead of immediately adding the parse
import = "import" s $path ws ';' ws $$".flow" $"changeFileExt" $"parsefile";

dynamicImport = "require" s $path ws ';' ws; // TODO: AST

// TODO: AST. We could set some marker that the following are exported.
export = "export" ws '{' ws toplevelDeclaration+ '}' ws; 
forbid = "forbid" s $path ws ';' ws; // TODO: AST
	path = bid ('/' bid)*;

toplevelDeclaration = 
	native
	| assign
	| union
	| functionOrStruct
	| vardecl;

// TODO: AST
native = "native" s id ws ':' ws ("io" ws)? type '=' ws $name ws ';' ws;
	name = bid ('.' bid)*;

assign = id ws '=' ws exp ';'? ws $"define";

// TODO: AST for typars
union = id ws (typars $"drop")? ws "::=" ws typenames ';' ws $$"union" $"swap" $"typecall" $"define";

	// listof(typename, ",")
	typenames = $"nil" typename $"cons" ("," ws typename $"cons")* ("," ws)? | $"nil";

// For now, we ignore the types
// TODO: Extract the type and use a binop to declare the type of the body
functionOrStruct = 
	// Forward declaration - we drop for now
	  id ws '(' ws funargs ')' ws returnType $"drop" ';' ws $"drop" $"drop"
	//  id ws '(' ws funargs ')' ws returnType $"drop" ';' ws $"nil" $$";" $"var" $"call" $"lambda" $"define"	// We leave the body nil
	| id ws '(' ws structargs ')' ws ';' ws $$"__struct" $"swap" $"typecall" $"define" // This is a struct!
	| id ws '(' ws funargs ')' ws returnType $"drop" brace $"lambda" $"define"
	| id ws '(' ws funargs ')' ws brace $"lambda" $"define"
	| id ws '(' ws funargs ')' ws exp ';'? ws $"lambda" $"define"

	// Forward type declarations
	| id ws ':' ws '(' ws funargs ')' ws returnType $"drop" $"drop" $"drop" ';' ws // We ignore the forward declaration for now
	| id ws ':' ws '(' ws types ')' ws returnType $"drop" $"drop" $"drop" ';' ws // We ignore the forward declaration for now
	// Struct
	| id ws ':' ws '(' ws structargs ')' ws ';' ws $$"__struct"  $"swap" $"typecall"  $"define"
	;

	// listof(funarg, ",")
	funargs = $"nil" funarg $"cons" ("," ws funarg $"cons")* ("," ws)? | $"nil";

	// For now, we just drop the types
	funarg = id ws (':' ws type $"drop")?;

	// TODO: mutable
	// listof(funarg, ",")
	structargs = $"nil" structarg $"cons" ("," ws structarg $"cons")* ("," ws)? | $"nil";
	structarg = id ws ':' ws type $$":" $"binop";

	returnType = ws "->" ws type;

vardecl = id ws ':' ws type '=' ws exp ';'? ws  $"swap" $$":" $"binop" $"define"
	// TODO: AST, and how to do it?
	| id ws ':' ws type ';'? ws;

exp = (
		"if" ws "(" $"nil" exp $"cons" ")" ws exp $"cons" "else" ws exp $"cons" $$"__ifte" $"var" $"swap" $"call"
		| "if" ws "(" $"nil" exp $"cons" ")" ws exp $"cons" $$"__ift" $"var" $"swap" $"call"
		| id ws "=" ws exp ";" ws exp $"let"
	 	| id ws ":" type "=" ws exp ";" $"swap" $$":" $"binop" ws exp $"let"
		// exp "." field ::= exp
	)
	|> exp ":=" ws exp $$":=" $"binop"
	|> exp "|>" ws exp $$"|>" $"binop"
	|> exp "||" ws exp $$"||" $"binop"
	|> exp "&&" ws exp $$"&&" $"binop"
	|> (
		exp "==" ws exp $$"==" $"binop"
		| exp "!=" ws exp $$"!=" $"binop"
		| exp "<=" ws exp $$"<=" $"binop"
		| exp "<" ws exp $$"<" $"binop"
		| exp ">=" ws exp $$">=" $"binop"
		| exp ">" ws exp $$">" $"binop"
	)
	|> (exp "+" ws exp $$"+" $"binop"
		| exp "-" ws exp $$"-" $"binop"
	)
	|> (exp "*" ws exp $$"*" $"binop"
		| exp "/" ws exp $$"/" $"binop"
		| exp "%" ws exp $$"%" $"binop"
	)
	// maybe ?? exp : exp

	|> (
		'!' ws exp $$"__not" $"unop"
		| '-' ws exp $$"__neg" $"unop"
		| backslash lambdaargs ws "->" ws exp $"lambda"
		| exp "(" ws exps ")" ws $"call"
		| exp "." ws id ws $$"." $"binop"
		| exp "[" ws exp "]" ws $$"__index" $"binop"
		// '(' ws call "with" s fields ')' ws;
	)

	|> exp ":" ws type $$":" $"binop"

	|> (
		"(" ws exp ")" ws 
		| "true" ws $"1" $"1" $"inttype" $$":" $"binop"
		| "false" ws $"0" $"1" $"inttype" $$":" $"binop"
		| "ref" ws exp $$"__ref" $"unop"
		| switch
		| id ws $"var"
		| $('0'-'9'+ "." '0'-'9'*) $"s2d"
		| $("." '0'-'9'+) $"s2d"
		| int ws $"s2i"
		| brace
		| string
		| "[" ws exps "]" $$"[" $"unop"
		| '^' ws exp $$"__deref" $"unop"
	);

// TODO: Maybe this should be binops instead of an array?
brace = "{" ws expsemis "}" ws $$";" $"var" $"swap" $"call";

	// listof(exp, ";")
	expsemis = $"nil" exp $"cons" (";" ws exp $"cons")* (";" ws)? | $"nil";

switch = "switch" ws '(' ws exp ')' ws '{' ws $"nil" (defaultOrNamedCase  $"cons")* '}' ws $$"__switch" $"binop";

defaultOrNamedCase = "default" ws ':' ws exp (';' ws)? $$"__default" $"unop"
	| id ws '(' ws names ')' $$"__pattern" $"binop" ws ':' ws exp (';' ws)? $$"__case" $"binop";

// listof(id, ",")
names = $"nil" id $"cons" ws (',' ws id $"cons")* | $"nil";

type = 	
		"bool" ws $"1" $"inttype"
		| "int" ws $"32" $"inttype"
		| "double" ws $$"double" $"nil" $"typecall"
		| "string" ws $$"string" $"nil" $"typecall"
		| "flow" ws $$"flow" $"nil" $"typecall"
		| "void" ws $$"void" $"nil" $"typecall"
		| "native" ws $$"native" $"nil" $"typecall"
		| "ref" ws type $"list1" $$"ref" $"swap" $"typecall"
		| "(" ws namedargs ")" ws "->" ws type $"fntype"
		| "(" ws types ")" ws "->" ws type $"fntype"
		| typename
		| "[" ws type "]" ws $"list1" $$"array" $"swap" $"typecall"
		| $("?"+) ws $"nil" $"typecall"
	;

typename = id ws typars $"typecall"
		| id ws $"nil" $"typecall";

typars = "<" ws types ">" ws;

// listof(type, ",")
types = $"nil" type $"cons" ("," ws type $"cons")* ("," ws)? | $"nil";

	// listof(namedargs, ",")
	namedargs = $"nil" namedarg $"cons" ("," ws namedarg $"cons")* ("," ws)? | $"nil";

	// For now, we just drop the id
	namedarg = id $"drop" ws ':' ws type;

// listof(id)
lambdaargs = $"nil" id $"cons" ("," ws id $"cons")* ("," ws)? | $"nil";

// listof(exp, ",")
exps = $"nil" exp $"cons" ("," ws exp $"cons")* ("," ws)? | $"nil";

// TODO: AST
string = '"' "#inc" "lude" s path '"' ws
	| singlestring
	| $"nil" (singlestring $"cons")+ $"concatStrings"
	;

singlestring = '"' $(onechar_)* '"' ws;

onechar_ = backslash "u" hexdigit_ hexdigit_ hexdigit_ hexdigit_
	| backslash "X" hexdigit_ hexdigit_ hexdigit_ hexdigit_
	| backslash "x" hexdigit_ hexdigit_
	| backslash escapedchar_
	| !'"' !backslash anychar;

hexdigit_ = '0'-'9'
	| 'a'-'f'
	| 'A'-'F';

escapedchar_ = backslash | '"' | "n" | "t" | "r";

anychar = '0x0000'-'0xffff';

id = $bid;

bid = ('a'-'z' | 'A'-'Z' | '_') ('a'-'z' | 'A'-'Z' | '0'-'9' | '_')*;

int = $'0'-'9'+;

backslash = '\';

ws = s*;

// We do not have \n and \t and such, so these are here verbatim
s = " " | "	" | "
" | "//" (!"
" anychar)* "
" | "/*" (!"*/" anychar)* "*/";
flow
