import material/material2tropic;
import material/material_snackbar;

import mini/backend/ast2bprogram;

import mini/commands/init;
import mini/commands/compiler;
import mini/exp/pretty;
import mini/types/pretty;

viewMiniDb(m : MiniDb) -> Material {
	MLines(
		concatA([
			foldTree(m.macros, [MText("Forth definitions:", [MSubtitle1()])], \name, def, acc -> {
				arrayPush(acc, MText("  " + name, []))
			}),
			foldTree(m.natives, [], \name, def, acc -> {
				arrayPush(acc, MText("  " + name, []))
			}),
			[MFixedY(8.0)],
			foldList(m.forth.stack, [MText("Stack:", [MSubtitle1()])], \acc, st -> {
				arrayPush(acc, MText("  " + miniPretty(st), []))
			}),
			[MFixedY(8.0)],
			foldTree(m.program.declarations, [MText("Ids:", [MSubtitle1()])], \st, val, acc -> {
				deps = lookupMultimap(m.program.dependencies, st);
				mtype = lookupTree(m.program.types, st);
				typeString = mtype ?? {
					" : " + mtype2string(mtype)
				} : "";
				text = st  + typeString + " =\n\t" + miniPretty(val) + " Â« " + strGlue(set2array(deps), ", ");
				arrayPush(acc, MText(text, []))
			}),
		])
	);
}

makeEvalLine(db : DynamicBehaviour<MiniDb>, def : string, focus : bool) -> Material {
	line = make(def);
	lineFocus = make(true);

	MBaselineCols([
		MTextInput(line, [], [
			MEatKeyDown(\ke -> ke.utf!="enter"), TTextInputFocus(lineFocus)
		]),
		MTextButton("EVALUATE", \ -> {
			theline = getValue(line);
			if (theline != "") {
				commands = if (startsWith(theline, "def ")) [theline] else strSplit(theline, " ");
				next(db, miniEvalForths("", getValue(db), commands));
			}
			next(db, miniCompile(getValue(db)));
			next(lineFocus, true);
		}, [], [MShortcut("enter")]),
	])
}

main() {
	manager = makeMaterialManager([]);

	db = make(makeMiniDb(["."], \e -> {
		showMSnackbar(manager, e, []);
	}));

	file = make("mini/tests/test.mini");

	mrender(manager, true, 
		MLines([
			MText("The Mini Compile Server", [MTitle()]),
			MBaselineCols([
				MTextInput(file, [], []),
				MTextButton("COMPILE", \ -> {
					thefile = getValue(file);
					if (thefile != "") {
						next(db, pushMiniCommand(getValue(db), MiniProcessFile(thefile, "evallines")));
					}
					next(db, miniCompile(getValue(db)));
				}, [], []),
			]),
			makeEvalLine(db, "prepexp", true),
			makeEvalLine(db, "\"mini/tests/test.exp\" parsefile", false),
			makeEvalLine(db, "\"a()->int{1}\" parseexp", false),
			MBaselineCols([
				MTextButton("RESET", \ -> {
					next(db, makeMiniDb(getValue(db).includes, getValue(db).onError));
				}, [], []),
				MTextButton("CLEAR STACK", \ -> {
					tdb = getValue(db);
					next(db, MiniDb(tdb with forth = MiniForth(tdb.forth with stack = makeList())));
				}, [], []),
				MTextButton("COMPILE", \ -> {
					program = miniAst2BProgram(getValue(db).program);
					println(program);
				}, [], [])
			]),
			MFixedY(8.0),
			MSelect(db, viewMiniDb),
		])
	);
}
