import mini/types/restype;
import mini/types/debug;
import mini/types/type;

export {
	// Convert from the restype to the MiniType. Requires a full map of all resolved tyvars
	simplifyResType(tyvars : Tree<int, ResType>, r : ResType) -> MiniType;
}

simplifyResType(tyvars : Tree<int, ResType>, r : ResType) -> MiniType {
	todo = \ -> {
		// println("Can not convert " + resType2string(r));
		MiniTypeCall("flow", []);
	}
	switch (r) {
		ResUnion(types): {
			stypes = mapSet(types, \t -> simplifyResType(tyvars, t));
			mpop = popMinSet(stypes);
			mpop ?? {
				if (isEmptySet(mpop.rest)) {
					mpop.value;
				} else {
					todo();
				}
			} : {
				MiniTypeCall("⊥", []);
			}
		}
		ResIntersection(types): {
			stypes = mapSet(types, \t -> simplifyResType(tyvars, t));
			mpop : Maybe<PopSetResult<MiniType>> = popMinSet(stypes);
			mpop ?? {
				if (isEmptySet(mpop.rest)) {
					mpop.value;
				} else {
					todo();
				}
			} : {
				MiniTypeCall("⊤", []);
			}
		}
		ResRecursiveType(id, type): simplifyResType(tyvars, type);
		ResFunctionType(args, rhs): MiniTypeFunction(map(args, \a -> simplifyResType(tyvars, a)), simplifyResType(tyvars, rhs));
		ResTypeRecord(fields): todo();
		ResTypeVar(id): {
			mrestype = lookupTree(tyvars, id);
			switch (mrestype) {
				None(): todo();
				Some(rt): {
					// TODO: We could probably cache the results
					switch (rt) {
						ResTypeVar(tv): {
							// What are you going to do?
							MiniTypeVar(id);
						}
						default: simplifyResType(tyvars, rt);
					}
				}
			}
		}
		ResIntType(bits): MiniTypeInt(bits);
		ResTypeCall(id, typars): MiniTypeCall(id, map(typars, \t -> simplifyResType(tyvars, t)));
		ResTypePar(id): MiniTypeCall(id, []);
	}
}
