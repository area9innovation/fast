import mini/types/restype;
import mini/types/debug;
import mini/types/type;

export {
	// Simplifies the res types to mini types
	simplifyResTypes(env : MiniTypeEnv, resTypes : Tree<int, ResType>) -> void;
}

simplifyResTypes(env : MiniTypeEnv, resTypes : Tree<int, ResType>) -> void {
	acc = SimplifyAcc(env, env.tyvars, makeSet(), resTypes);

	traverseInOrder(resTypes, \tv, restype -> {
		resolved = simplifyResType(acc, ResTypeVar(tv));
		if (false) {
			println("a"  + i2s(tv) + " = " + miniType2string(resolved) + " from " + debugBounds(env, tv) + "   giving restype: " + resType2string(restype));
		};
	});
}

SimplifyAcc(
	env : MiniTypeEnv,
	tyvars : ref Tree<int, MiniType>,
	recursive : Set<int>,
	resTypes : Tree<int, ResType>
);

simplifyResType(acc : SimplifyAcc, r : ResType) -> MiniType {
	todo = \ -> {
		println("Can not convert " + resType2string(r));
		MiniTypeCall("flow", []);
	};
	switch (r) {
		ResUnion(types): {
			stypes = mapSet(types, \t -> simplifyResType(acc, t));
			evalResSet(acc.env, stypes, \l, ri -> unionTypes(acc, l, ri), MiniTypeCall("⊥", []));
		}
		ResIntersection(types): {
			stypes = mapSet(types, \t -> simplifyResType(acc, t));
			evalResSet(acc.env, stypes, \l, ri -> intersectTypes(acc, l, ri), MiniTypeCall("⊤", []));
		}
		ResRecursiveType(id, type): {
			nacc = SimplifyAcc(acc with recursive = insertSet(acc.recursive, id));
			simplifyResType(nacc, type);
		}
		ResFunctionType(args, rhs): MiniTypeFunction(map(args, \a -> simplifyResType(acc, a)), simplifyResType(acc, rhs));
		ResTypeRecord(fields): todo();
		ResTypeVar(id): {
			mtype = lookupTree(^(acc.tyvars), id);
			switch (mtype) {
				None(): {
					mrestype = lookupTree(acc.resTypes, id);
					switch (mrestype) {
						None(): {
							if (containsSet(acc.recursive, id)) {
								MiniTypeVar(id);
							} else {
								todo();
							}
						}
						Some(rt): {
							if (containsSet(acc.recursive, id)) {
								MiniTypeVar(id);
							} else {
								nacc = SimplifyAcc(acc with recursive = insertSet(acc.recursive, id));
								rtype = simplifyResType(nacc, rt);
								acc.tyvars := setTree(^(acc.tyvars), id, rtype);
								rtype;
							}
						}
					}
				}
				Some(t): t;
			}
		}
		ResIntType(bits): MiniTypeInt(bits);
		ResTypeCall(id, typars): MiniTypeCall(id, map(typars, \t -> simplifyResType(acc, t)));
		ResTypePar(id): MiniTypePar(id);
	}
}

evalResSet(env : MiniTypeEnv, types : Set<MiniType>, combine : (MiniType, MiniType) -> Maybe<MiniType>, def : MiniType) -> MiniType {
	mtype = foldSet(types, None(), \acc : Maybe<MiniType>, type -> {
		switch (acc) {
			None(): Some(type);
			Some(l): combine(l, type);
		}
	});
	mtype ?? {
		mtype
	} : {
		def
	}
}

unionTypes(acc : SimplifyAcc, left : MiniType, right : MiniType) -> Maybe<MiniType> {
	// println("Can we join these? " + miniType2string(left) + " and " + miniType2string(right));
	None();
}

// autofold: structural pairs
intersectTypes(acc : SimplifyAcc, left : MiniType, right : MiniType) -> Maybe<MiniType> {
	todo = \ -> {
		// println("Can we intersect these? " + miniType2string(left) + " and " + miniType2string(right));
		None();
	}
	if (left == right) Some(left)
	else {
		rightFn = \ -> {
			switch (right) {
				MiniTypeVar(id): if (containsSet(acc.recursive, id)) Some(left) else None();
				default: todo();
			}
		}
		switch (left) {
			MiniTypeInt(lbits): rightFn();
			MiniTypeFunction(largs, lreturnType): {
				switch (right) {
					MiniTypeFunction(rargs, rreturnType): {
						if (length(largs) == length(rargs)) {
							iargs = filtermapi(largs, \i, larg -> {
								intersectTypes(acc, larg, rargs[i])
							});
							irt = intersectTypes(acc, lreturnType, rreturnType);
							irt ?? {
								if (length(iargs) == length(largs)) {
									Some(MiniTypeFunction(iargs, irt));
								} else None();
							} : None();
						} else None();
					}
					default: rightFn();
				}
			}
			MiniTypeCall(lid, ltypars): {
				rightFn();
			}
			MiniTypeVar(lid): {
				if (containsSet(acc.recursive, lid)) {
					Some(right);
				} else rightFn();
			}
			MiniTypePar(id): {
				rightFn();
			}
			MiniTypeRecord(fields): {
				rightFn();
			}
		}
	}
}
