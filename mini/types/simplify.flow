import mini/types/restype;
import mini/types/debug;
import mini/types/type2;

export {
	// Convert from the restype to the MiniType2. Requires a full map of all resolved tyvars
	simplifyResType(tyvars : Tree<int, ResType>, r : ResType) -> MiniType2;
}

simplifyResType(tyvars : Tree<int, ResType>, r : ResType) -> MiniType2 {
	todo = \ -> {
		println("Can not convert " + resType2string(r));
		MiniType2Call("flow", []);
	}
	switch (r) {
		ResUnion(types): {
			stypes = mapSet(types, \t -> simplifyResType(tyvars, t));
			mpop = popMinSet(stypes);
			mpop ?? {
				if (isEmptySet(mpop.rest)) {
					mpop.value;
				} else {
					todo();
				}
			} : {
				MiniType2Call("⊥", []);
			}
		}
		ResIntersection(types): {
			stypes = mapSet(types, \t -> simplifyResType(tyvars, t));
			mpop : Maybe<PopSetResult<MiniType2>> = popMinSet(stypes);
			mpop ?? {
				if (isEmptySet(mpop.rest)) {
					mpop.value;
				} else {
					todo();
				}
			} : {
				MiniType2Call("⊤", []);
			}
		}
		ResRecursiveType(id, type): simplifyResType(tyvars, type);
		ResFunctionType(args, rhs): MiniType2Function(map(args, \a -> simplifyResType(tyvars, a)), simplifyResType(tyvars, rhs));
		ResTypeRecord(fields): todo();
		ResTypeVar(id): {
			mrestype = lookupTree(tyvars, id);
			switch (mrestype) {
				None(): todo();
				Some(rt): {
					// TODO: We could probably cache the results
					switch (rt) {
						ResTypeVar(tv): {
							// What are you going to do?
							MiniType2Var(id);
						}
						default: simplifyResType(tyvars, rt);
					}
				}
			}
		}
		ResIntType(bits): MiniType2Int(bits);
		ResTypeCall(id, typars): MiniType2Call(id, map(typars, \t -> simplifyResType(tyvars, t)));
		ResTypePar(id): MiniType2Call(id, []);
	}
}
