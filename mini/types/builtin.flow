import ds/tree;
import mini/types/type2;

export {
	// Some common types
	miniTypeVoid : MiniType2;
	miniTypeBool : MiniType2;
	miniTypeInt : MiniType2;
	miniTypeDouble : MiniType2;
	miniTypeString : MiniType2;

	getBuiltinMiniTypes() -> Tree<string, MiniType2>;
}

miniTypeVoid : MiniType2 = MiniType2Int(0);
miniTypeBool : MiniType2 = MiniType2Call("bool", []);
miniTypeInt : MiniType2 = MiniType2Int(32);
miniTypeDouble : MiniType2 = MiniType2Call("double", []);
miniTypeString : MiniType2 = MiniType2Call("string", []);

getBuiltinMiniTypes() -> Tree<string, MiniType2> {

	v = miniTypeVoid;
	b = miniTypeBool;
	i = MiniType2Int(32);
	s = miniTypeString;

	at = \t -> MiniType2Call("array", [t]);
	reftype = \t -> MiniType2Call("ref", [t]);

	ta = MiniType2Par("?");
	tb = MiniType2Par("??");
	tc = MiniType2Par("???");
	td = MiniType2Par("????");

	pairs2tree([
		Pair("__ifte", MiniType2Function([b, ta, ta], ta)),
		Pair("__ift", MiniType2Function([b, v, v], v)),

		Pair(";", MiniType2Function([ta, tb], tb)),

		Pair("||", MiniType2Function([b, b], b)),
		Pair("&&", MiniType2Function([b, b], b)),

		Pair("==", MiniType2Function([ta, ta], b)),
		Pair("!=", MiniType2Function([ta, ta], b)),
		Pair("<=", MiniType2Function([ta, ta], b)),
		Pair("<", MiniType2Function([ta, ta], b)),
		Pair(">=", MiniType2Function([ta, ta], b)),
		Pair(">", MiniType2Function([ta, ta], b)),

		Pair("+", MiniType2Function([ta, ta], ta)),
		Pair("-", MiniType2Function([ta, ta], ta)),

		Pair("*", MiniType2Function([ta, ta], ta)),
		Pair("/", MiniType2Function([ta, ta], ta)),
		Pair("%", MiniType2Function([ta, ta], ta)),

		Pair("!", MiniType2Function([b], b)),
		Pair("__neg", MiniType2Function([ta], ta)),

		// : is special and should probably be grabbed by the type inference?
		Pair(":", MiniType2Function([ta, ta], ta)),

		// Array constructs
		Pair("__emptyarray", MiniType2Function([], at(ta))),
		Pair("[", MiniType2Function([ta], at(ta))),
		Pair(",", MiniType2Function([ta, ta], ta)),

		Pair("__index", MiniType2Function([at(ta), i], ta)),

	//__switch __case __pattern  __default  __with  __mutassign   __fieldassign

		Pair("__cast", MiniType2Function([ta, ta, tb], tb)),

		// References
		Pair("__ref", MiniType2Function([ta], reftype(ta))),
		Pair("__deref", MiniType2Function([reftype(ta)], ta)),
		Pair(":=", MiniType2Function([ta, tb], v)),

		Pair("__void", MiniType2Function([], v)),

		Pair("__native", MiniType2Function([i, ta, s], ta)),

		// Structs & unions:
		Pair("__construct0", MiniType2Function([s], ta)),
		Pair("__construct1", MiniType2Function([s, ta], tb)),
		Pair("__construct2", MiniType2Function([s, ta, tb], tc)),

		Pair(".", MiniType2Function([ta, s], tb)),
		// Used by union to find the value to dispatch from
		Pair("__structname", MiniType2Function([ta], tb)),

		// Temporary:
		Pair("__type0", MiniType2Function([s], ta)),
		Pair("__type1", MiniType2Function([s, ta], tb)),

		Pair("__union0", MiniType2Function([ta], tb)),
		Pair("__union1", MiniType2Function([ta, tb], tc)),
		Pair("__union2", MiniType2Function([ta, tb, tc], td)),

		Pair("__typename0", MiniType2Function([s], ta)),	// TODO: It is not names, but functions we get here
		Pair("__typename1", MiniType2Function([s, ta], tb)),
		Pair("__typename2", MiniType2Function([s, ta, tb], tc)),
	])
}

