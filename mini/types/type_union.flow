import mini/types/typeenv;
import mini/types/debug;
import mini/types/subtype;
import mini/types/subtypegraph;

export {
	/*
	Adds a new type to an intersection. Will check that this is legal,
	and unify any type vars as far as possible.
	Example:
	1. [] + {first:α51}   == [{first:α51}]
	2. [{first:α51}] + {second:α54} = [{first:α51, second:α54}]
	3. [{first:α51, second:α54}] + Pair<?, ??> = [Pair<?, ??>]  
		and unification of α51 with ? and α54 with ??
	*/
	unionMiniTypes(env : MiniTypeEnv, 
		unify : (env : MiniTypeEnv, lhsp : MiniTypePos, rhsp : MiniTypePos, reason : string) -> void,
		types : Set<MiniType>, typep : MiniTypePos) -> Set<MiniType>;
}

unionMiniTypes(env : MiniTypeEnv, 
		unify : (env : MiniTypeEnv, lhsp : MiniTypePos, rhsp : MiniTypePos, reason : string) -> void,
		types : Set<MiniType>, typep : MiniTypePos) -> Set<MiniType> {

	type = typep.type;
	if (isEmptySet(types)) makeSet1(type)
	else {
		error = \ -> {
			existing = "[" + superglue(set2array(types), miniType2string, ", ") + "]";
			env.onError(typep.id, typep.pos, "Can not union " + miniType2string(type) + " and " + existing);
			types;
		}

		todo = \ -> {
			existing = "[" + superglue(set2array(types), miniType2string, ", ") + "]";
			println("TODO: union " + miniType2string(type) + " and " + existing);
			insertSet(types, type);
		}

		hasFlow = containsSet(types, MiniTypeCall("flow", []));

		switch (type) {
			MiniTypeInt(bits): {
				todo();
			}
			MiniTypeFunction(args, returnType): {
				// OK, we require at most one function there already
				if (sizeSet(types) != 1) {
					error();
				} else {
					efn = set2array(types)[0];
					switch (efn) {
						MiniTypeFunction(eargs, ereturnType): {
							// OK, unify these fns
							unify(env, MiniTypePos(typep.id, typep.pos, efn), typep, "union");
							// And we just keep the result
							types;
						}
						default: error();
					}
				}
			}
			MiniTypeCall(id, typars): {
				unionMiniTypeCall(env, unify, typep, types, type);
			}
			MiniTypeVar(id): error();
			MiniTypePar(id): insertSet(types, type);
			MiniTypeRecord(fields): todo();
		}
	}
}

// Union a type call with existing types
unionMiniTypeCall(env : MiniTypeEnv, 
	unify : (env : MiniTypeEnv, lhsp : MiniTypePos, rhsp : MiniTypePos, reason : string) -> void,
	typep : MiniTypePos, types : Set<MiniType>, call : MiniTypeCall) -> Set<MiniType> {

	foldSet(types, makeSet(), \acc, etype -> {
		error = \ -> {
			env.onError(typep.id, typep.pos, "Can not union " + miniType2string(call) + " with " + miniType2string(etype));
			acc;
		}
		todo = \ -> { 
			println("TODO: Implement union " + miniType2string(call) + " with " + miniType2string(etype));
			acc;
		}
		switch (etype) {
			MiniTypeInt(bits): error();
			MiniTypeFunction(args, returnType): error();
			MiniTypeCall(id, typars): {
				unionMiniTypeCalls(env, unify, typep, acc, call, etype);
			}
			MiniTypeVar(id): error();
			MiniTypePar(id): error();
			MiniTypeRecord(fields): todo();
		}
	});
}

// A type call with a type call, and add the result to the acc
unionMiniTypeCalls(env : MiniTypeEnv, 
	unify : (env : MiniTypeEnv, lhsp : MiniTypePos, rhsp : MiniTypePos, reason : string) -> void,
	typep : MiniTypePos, acc : Set<MiniType>, left : MiniTypeCall, right : MiniTypeCall) -> Set<MiniType> {

	if (left.id == right.id) {
		// Just unify the parameters
		// TODO: Should this be done both ways?
		constrainMiniTypeCalls(env, typep.id, typep.pos, unify, left, right, "union typecalls");
		insertSet(acc, left);
	} else if (left.id == "") {
		// OK, we have an unknown struct vs a named struct or union.
		// Now we know the name
		unionMiniTypeCalls(env, unify, typep, acc, MiniTypeCall(left with id = right.id), right);
	} else if (right.id == "") {
		// OK, we have an unknown struct vs a named struct.
		// Now we know the name
		unionMiniTypeCalls(env, unify, typep, acc, left, MiniTypeCall(right with id = left.id));
	} else {
		// OK, check that one is a part of the other one
		runion = findMiniStructInUnion(env.ast, left.id, right.id, right.typars);
		runion ?? {
			// OK, right is the union
			println("TODO: Unify the found " + miniType2string(runion) + " from union " + miniType2string(right) + " with struct " + miniType2string(left));
			insertSet(acc, right);
		} : {
			lunion = findMiniStructInUnion(env.ast, right.id, left.id, left.typars);
			switch (lunion) {
				None(): {
					// Neither is the union.
					// See if there is some unique union that works
					lunions = findMiniSuperTypes(env.ast.subtypeGraph, left.id);
					runions = findMiniSuperTypes(env.ast.subtypeGraph, right.id);
					shared = intersectSets(lunions, runions);
					if (sizeSet(shared) == 1) {
						// OK, we found a unique union
						unionName = set2array(shared)[0];
						println("TODO: Figure out how to lift type pars from " + miniType2string(left) + " and " + miniType2string(right) + " to union " + unionName);
						insertSet(acc, left);
					} else {
						println("TODO: Find union for typecall " + miniType2string(left) + " and typecall " + miniType2string(right));
						println(set2array(shared));
						insertSet(acc, left);
					}
				}
				Some(lun): {
					println("TODO: Unify the found " + miniType2string(lun) + " from union " + miniType2string(left) + " with struct " + miniType2string(right));
					insertSet(acc, right);
				}
			}
		}
	}
}
