import mini/types/typeenv;
import mini/types/restype;
import mini/types/unify_restype;
import mini/types/debug;
import ds/tuples;
import ds/treeutils;

export {
	// Construct a map of how each tyvar is coalescated to a ResType
	coalesceMiniTypeVars(env : MiniTypeEnv) -> Tree<int, ResType>;
}

PolarVariable(id : int, polar : bool);

CoalesceAcc(
	env : MiniTypeEnv,
	recursive : ref Tree<PolarVariable, ResTypeVar>,
	inProcess : Set<PolarVariable>
);

coalesceMiniTypeVars(env : MiniTypeEnv) -> Tree<int, ResType> {
	// OK, the question is whether we should build a dependency graph of the tyvars and do it in
	// topological order?
	cenv = CoalesceAcc(env, ref makeTree(), makeSet());

	resenv = ResTypeEnv(ref makeTree(), \tv -> {
		restype1 = goCoalesce(cenv, MiniTypeVar(tv), true);
		restype2 = goCoalesce(cenv, MiniTypeVar(tv), false);
		Pair(restype1, restype2)
	}, env.onError);

	foldRange(1, ^(env.tyvarId) - 1, makeTree(), \acc, tv -> {
		restype1 = goCoalesce(cenv, MiniTypeVar(tv), true);
		restype2 = goCoalesce(cenv, MiniTypeVar(tv), false);

		restype = unifyResTypes(resenv, makeSet1(tv), restype1, restype2);
		resenv.types := setTree(^(resenv.types), tv, restype);

		setTree(acc, tv, restype);
	});
}

goCoalesce(env : CoalesceAcc, type : MiniType, polar : bool) -> ResType {
	switch (type) {
		MiniTypeInt(bits): ResIntType(bits);
		MiniTypeFunction(args, returnType): {
			ResFunctionType(
				map(args, \a -> {
					goCoalesce(env, a, !polar)
				}),
				goCoalesce(env, returnType, polar)
			)
		}
		MiniTypeCall(id, typars): {
			ResTypeCall(id, map(typars, \tp -> {
				goCoalesce(env, tp, polar)
			}));
		}
		MiniTypeVar(id): {
			vspol = PolarVariable(id, polar);
			if (containsSet(env.inProcess, vspol)) {
				mtyvar = lookupTree(^(env.recursive), vspol);
				mtyvar ?? {
					mtyvar
				} : {
					// First time we see this, so we make a new tyvar for it
					tyvar = makeResTypeVar(env.env);
					env.recursive := setTree(^(env.recursive), vspol, tyvar);
					tyvar;
				}
			} else {
				bounds = lookupMultimap(^(if (polar) env.env.tyvarLowerBounds else env.env.tyvarUpperBounds), id);
				nenv = CoalesceAcc(env with inProcess = insertSet(env.inProcess, vspol));
				boundTypes = mapSet(bounds, \b -> {
					goCoalesce(nenv, b, polar)
				});

				mbounds = popMinSet(boundTypes);
				res = mbounds ?? {
					if (isEmptySet(mbounds.rest)) {
						mbounds.value
					} else if (polar) {
						ResUnion(boundTypes)
					} else {
						ResIntersection(boundTypes);
					}
				} : {
					ResTypeVar(id);
				};

				// If this exist in the recursive map, return a recursive type
				mrecid = lookupTree(^(env.recursive), vspol);
				mrecid ?? {
					// println("Recursive " + i2s(mrecid.id));
					// res;
					ResRecursiveType(mrecid.id, res)
				} : res;
			}
		}
		MiniTypePar(id): ResTypePar(id);
		MiniTypeRecord(fields): {
			ResTypeRecord(map(fields, \f : MiniTypeField -> {
				Pair(f.name, goCoalesce(env, f.type, polar))
			}))
		}
	}
}

makeResTypeVar(env : MiniTypeEnv) -> ResTypeVar {
	id = ^(env.tyvarId);
	env.tyvarId := id + 1;
	ResTypeVar(id);
}
