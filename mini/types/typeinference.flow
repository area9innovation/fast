import mini/types/typeenv;
import mini/types/pretty;
import mini/types/pretty;
import mini/types/tyvarinfo;
import mini/types/type_ast;
import mini/types/subtype;
import mini/types/polymorphism;
import mini/types/debug;
import mini/util/position;
import ds/treeutils;

export {
	makeMiniTypeEnv(ast : MiniAst) -> MiniTypeEnv;

	// Do type inference on this declaration. If it is recursive, send in a bool
	typeInferenceMiniDeclaration(env : MiniTypeEnv, id : string, recursive : bool, ex : MiniExp) -> MiniTypeEnv;
}

makeMiniTypeEnv(ast : MiniAst) -> MiniTypeEnv {
	MiniTypeEnv(
		ast,
		makeTree(),
		ref makeTree(),
		ref makeTree(),
		ref 1,
		ref makeTree(),
		ref makeSet(),
		ref makeTree(),
		ref makeTree(),
		\name, pos, e -> ast.onError(ast, name, pos, e)
	);
}

typeInferenceMiniDeclaration(env0 : MiniTypeEnv, id : string, recursive : bool, ex : MiniExp) -> MiniTypeEnv {
	pos = getMiniPos(ex);
	inferredType = if (recursive) {
		// OK, we have to add a local variable of this name and constrain it
		type = makeMiniTypeVar(env0);
		nenv = setMiniLocalType(env0, id, type);
		rt = typeInferenceMini(nenv, id, ex);

		// OK, we constrain the type
		constrainMiniType(nenv, id, pos, rt, type);
		rt;
	} else {
		typeInferenceMini(env0, id, ex);
	};

	// Check if we have a forward declaration, 
	mforward = lookupTree(env0.ast.types, id);
	mforward ?? {
		// When we do, then constraint it, but keep it as the type of this id
		constrainMiniType(env0, id, pos, inferredType, mforward) ;

		if (false) {
			// If this is polymorphic, we could probably resolve it immediately?
			typars = extractMiniTypePars(makeSet(), mforward);
			if (!isEmptySet(typars)) {
				println(id);
				println(typars);
			}
		};

		env0
	} : {
		// No forward, so set the type
		setMiniTypeDeclaration(env0, id, inferredType);
	};
}

setMiniTypeDeclaration(env : MiniTypeEnv, id : string, type : MiniType) -> MiniTypeEnv {
	// See if we already have a forward declaration. 
	// If so, that should serve as a constraint.
	mtype = lookupTree(env.ast.types, id);
	mtype ?? {
		// TODO: Find position
		constrainMiniType(env, id, -1, type, mtype);
	} : {};

	MiniTypeEnv(
		env with ast = MiniAst(env.ast with types = setTree(env.ast.types, id, type))
	)
}

/*
We follow the algorithm from here:
https://dl.acm.org/doi/abs/10.1145/3409006

There is an implementation here:
https://github.com/LPTK/simple-sub
*/
typeInferenceMini(env : MiniTypeEnv, id : string, ex : MiniExp) -> MiniType {
	switch (ex) {
		MiniInt(value, __, tv): {
			setMiniTypeVar(env, ex, MiniTypeInt(32));
		}
		MiniDouble(value, __): MiniTypeCall("double", []);
		MiniString(value, __): MiniTypeCall("string", []);
		MiniVar(name, __, __): {
			mlocal = lookupTree(env.localTypes, name);

			type = mlocal ?? mlocal : {
				mglobal = lookupTree(env.ast.types, name);
				switch (mglobal) {
					None(): {
						// TODO: Error
						env.onError("", -1, "Type inference: Does not know var " + name);
						makeMiniTypeVar(env);
					}
					Some(t): t;
				}
			};

			// OK, we should instantiate this polymorphism
			itype = instantiateTypePars2TypeVars(env, type);

			setMiniTypeVar(env, ex, itype);
		}
		MiniLet(name, value, body, __, tv): {
			vtype = typeInferenceMini(env, id, value);
			nenv = setMiniLocalType(env, name, vtype);
			setMiniTypeVar(nenv, ex, typeInferenceMini(nenv, id, body));
		}
		MiniLambda(args, body, __, __): {
			argTypes = map(args, \arg -> makeMiniTypeVar(env));
			nenv = foldi(args, env, \i, acc, arg -> {
				setMiniLocalType(acc, arg, argTypes[i])
			});
			retType = typeInferenceMini(nenv, id, body);
			fnType = MiniTypeFunction(argTypes, retType);
			setMiniTypeVar(nenv, ex, fnType);
		}
		MiniCall(fn, args, pos, __): {
			def = \ -> {
				resType = makeMiniTypeVar(env);
				fnType = typeInferenceMini(env, id, fn);
				callType = MiniTypeFunction(
					map(args, \a -> typeInferenceMini(env, id, a)),
					resType
				);
				constrainMiniType(env, id, pos, fnType, callType);
				setMiniTypeVar(env, ex, resType);
			};
			switch (fn) {
				MiniVar(fname, __, __): {
					/*
					 *
					 * Here we handle special functions that have special typing rules
					 *
					 */
					if (fname == "__type" || fname == "__fntype"|| fname == "__uniontype" || fname == "__recordtype") {
						type = convertMiniExp2Type(ex);

						// OK, we have to fix the type of the construct so the AST is still completely types
						// even if the type is non-sense
						set = \e -> {setMiniTypeVar(env, e, miniTypeVoid); {} };
						set(fn);
						iter(args, set);
						// Set the real type;
						setMiniTypeVar(env, ex, type);
					} else if (fname == ":") {
						// This is special.
						argType = typeInferenceMini(env, id, args[0]);
						type = convertMiniExp2Type(args[1]);
						switch (args[0]) {
							MiniInt(__, __, __): {
								// This is fine nomatter what, since it is the official way to declare other int types
							}
							default: {
								// For the rest, check the type
								constrainMiniType(env, id, pos, argType, type);
							}
						};
						setMiniTypeVar(env, ex, type);
					} else if (fname == "__downcast") {
						// This is downcast "id : type in body"
						name = getMiniVar(args[0]);
						type = convertMiniExp2Type(args[1]);
						body = args[2];
					
						nenv = setMiniLocalType(env, name, type);
						setMiniTypeVar(nenv, ex, typeInferenceMini(nenv, id, body));
					} else if (fname == ".") {
						argType = typeInferenceMini(env, id, args[0]);
						field = getMiniString(args[1]);

						fieldType = makeMiniTypeVar(env);
						rec = MiniTypeRecord([MiniTypeField(field, false, fieldType)]);

						constrainMiniType(env, id, pos, argType, rec);

						fieldType;
					} else {
						// TODO: Downcast could be handled here?
						def();
					}
				}
				default: def();
			}
		}
	}
}

constrainMiniType(env : MiniTypeEnv, id : string, pos : int, lhs : MiniType, rhs : MiniType) -> void {
	if (containsSet(^(env.constraintCache), Pair(lhs, rhs))
		|| lhs == MiniTypeCall("auto", [])
		|| rhs == MiniTypeCall("auto", [])) {
		// OK, already handled
	} else {
		env.constraintCache := insertSet(^(env.constraintCache), Pair(lhs, rhs));
		
		// println("Constrain " + debugMiniType(env, lhs) + " <: " + debugMiniType(env, rhs));

		error = \ -> {
			env.onError(id, pos, "Type violation " + miniType2string(lhs) + " < " + miniType2string(rhs));
		};
		right = \ -> {
			switch (rhs) {
				MiniTypeVar(rid): {
					addMiniLowerBound(env, rid, lhs);
					constrainUpperBounds(env, rid, lhs);
				}
				MiniTypeCall(rid, rtypars): {
					if (rid == "flow"  && rtypars == []) {
						// This is fine
					} else error();
				}
				default: error();
			}
		}

		switch (lhs) {
			MiniTypeInt(lbits): {
				switch (rhs) {
					MiniTypeInt(rbits): if (lbits != rbits) error();
					default: right();
				}
			}
			MiniTypeFunction(largs, lreturnType): {
				switch (rhs) {
					MiniTypeFunction(rargs, rreturnType): {
						// (Function(l0, r0), Function(l1, r1)) => constrain(l1, l0); constrain(r0, r1)
						if (length(largs) != length(rargs)) {
							error();
						} else {
							iteri(largs, \i, larg -> {
								constrainMiniType(env, id, pos, rargs[i], larg);
							});
							constrainMiniType(env, id, pos, lreturnType, rreturnType);
						}
					}
					default: right();
				}
			}
			MiniTypeCall(lid, ltypars): {
				switch (rhs) {
					MiniTypeCall(rid, rtypars): {
						constrainMiniTypeCalls(env, id, pos, constrainMiniType, lhs, rhs);
					}
					MiniTypeRecord(rfields): {
						mrecord = typeCall2MiniRecord(env.ast, lhs);
						mrecord ?? {
							constrainMiniType(env, id, pos, mrecord, rhs);
						} : {
							error();
						}
					}
					default: right();
				}
			}
			MiniTypeVar(lid): {
				def = \ -> {
					addMiniUpperBound(env, lid, rhs);
					constrainLowerBounds(env, lid, rhs);
				};

				switch (rhs) {
					MiniTypeVar(rid): if (lid != rid) {
						def();
					};
					default: def();
				}
			}
			MiniTypePar(lid): {
				switch (rhs) {
					MiniTypePar(rid): {
						if (lid != rid) {
							error();
						}
					}
					default: right();
				}
			}
			MiniTypeRecord(lfields): {
				switch (rhs) {
					MiniTypeRecord(rfields): {
						iteri(rfields, \i, fs1 : MiniTypeField -> {
							lfield = find(lfields, \lf : MiniTypeField -> lf.name == fs1.name);
							lfield ?? {
								if (lfield.isMutable && !fs1.isMutable) {
									env.onError(id, pos, "Field " + fs1.name + " should be mutable in " + miniType2string(rhs));
								} 
								constrainMiniType(env, id, pos, lfield.type, fs1.type);
							} : {
								env.onError(id, pos, "Expected field " + fs1.name + " in " + miniType2string(lhs));
							}
						});
						/*
						(Record(fs0), Record(fs1)) =>
							fs1.foreach { 
								case (n1, t1) =>
									fs0.find(_._1 == n1) match {
										None => err("missing field: " + n1 + " in " + lhs);
										Some((_, t0)) => constrain(t0, t1) 
									}
							}
						*/
					}
					default: right();
				}
			}
		}
	}
}

setMiniLocalType(env : MiniTypeEnv, id : string, type : MiniType) -> MiniTypeEnv {
// 	println(id + " = " + toString(type));
	MiniTypeEnv(env with localTypes = setTree(env.localTypes, id, type));
}

setMiniTypeVar(env : MiniTypeEnv, ex : MiniExp, type : MiniType) -> MiniType {
	def = \tv -> {
		id = if (tv == 0) {
			ttv = makeMiniTypeVar(env);
			switch (ex) {
				MiniInt(value, __, tyvar): ex.tyvar ::= ttv.id;
				MiniVar(name, __, tyvar): ex.tyvar ::= ttv.id;
				MiniLet(name, value, body, __, tyvar): ex.tyvar ::= ttv.id;
				MiniLambda(args, body, __, tyvar): ex.tyvar ::= ttv.id;
				MiniCall(fn, args, __, tyvar): ex.tyvar ::= ttv.id;

				MiniDouble(value, __): {};
				MiniString(value, __): {};
			};
			ttv.id;
		} else tv;
		addMiniLowerBound(env, id, type);
		addMiniUpperBound(env, id, type);
		type;
	};
	switch (ex) {
		MiniInt(value, __, tyvar): def(tyvar);
		MiniVar(name, __, tyvar): def(tyvar);
		MiniLet(name, value, body, __, tyvar): def(tyvar);
		MiniLambda(args, body, __, tyvar): def(tyvar);
		MiniCall(fn, args, __, tyvar): def(tyvar);

		MiniDouble(value, __): type;
		MiniString(value, __): type;
	}
}

addMiniLowerBound(env : MiniTypeEnv, tyvar : int, type : MiniType) -> void {
	env.tyvarLowerBounds := insertMultimap(^(env.tyvarLowerBounds), tyvar, type);
}

addMiniUpperBound(env : MiniTypeEnv, tyvar : int, type : MiniType) -> void {
	env.tyvarUpperBounds := insertMultimap(^(env.tyvarUpperBounds), tyvar, type);
}

constrainLowerBounds(env : MiniTypeEnv, tyvar : int, type : MiniType) -> void {
	types = lookupMultimap(^(env.tyvarLowerBounds), tyvar);
	id = findMiniTyvarInfo(env, tyvar);
	pos = findMiniTyvarPos(env, tyvar);
	iterSet(types, \ltype -> {
		constrainMiniType(env, id, pos, ltype, type)
	})
}

constrainUpperBounds(env : MiniTypeEnv, tyvar : int, type : MiniType) -> void {
	types = lookupMultimap(^(env.tyvarUpperBounds), tyvar);
	id = findMiniTyvarInfo(env, tyvar);
	pos = findMiniTyvarPos(env, tyvar);
	iterSet(types, \utype -> {
		constrainMiniType(env, id, pos, type, utype)
	})
}
