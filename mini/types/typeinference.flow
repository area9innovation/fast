import mini/types/typeenv;
import mini/types/pretty;
import mini/types/polymorphism;
import ds/treeutils;

export {
	makeMiniTypeEnv(ast : MiniAst) -> MiniTypeEnv;

	// Do type inference on this declaration. If it is recursive, send in a bool
	typeInferenceMiniDeclaration(env : MiniTypeEnv, id : string, recursive : bool, ex : MiniExp) -> MiniTypeEnv;
}

makeMiniTypeEnv(ast : MiniAst) -> MiniTypeEnv {
	MiniTypeEnv(
		ast,
		makeTree(),
		ref makeTree(),
		ref makeTree(),
		ref 1,
		ref makeTree(),
		ref MiniTypeParMap(makeTree(), makeTree()),
		ref makeSet()
	);
}

typeInferenceMiniDeclaration(env : MiniTypeEnv, id : string, recursive : bool, ex : MiniExp) -> MiniTypeEnv {
	// Reset polymorphism for this id
	initTyparMap(env);

	// TODO: Traverse the body and extract polymorphism and instantiate it from the forward declarations
	mforward = lookupTree(env.ast.types, id);


	if (recursive) {
		// OK, we have to add a local variable of this name and constrain it
		type = makeMiniType2Var(env);
		nenv = setMiniLocalType2(env, id, type);
		rt = typeInferenceMini(nenv, ex);

		// OK, we constrain the type
		constrainMiniType(nenv, rt, type);

		// Back-substitute polymorphism
		ptype = typeVars2TypePars(nenv, rt);

		setMiniType2Declaration(nenv, id, ptype);
	} else {
		rt = typeInferenceMini(env, ex);

		// Back-substitute polymorphism
		ptype = typeVars2TypePars(env, rt);

		setMiniType2Declaration(env, id, ptype);
	};
}

setMiniType2Declaration(env : MiniTypeEnv, id : string, type : MiniType2) -> MiniTypeEnv {
	// See if we already have a forward declaration. 
	// If so, that should serve as a constraint.
	mtype = lookupTree(env.ast.types, id);
	mtype ?? {
		constrainMiniType(env, type, mtype);
	} : {}

	MiniTypeEnv(
		env with ast = MiniAst(env.ast with types = setTree(env.ast.types, id, type))
	)
}

/*
We follow the algorithm from here:
https://dl.acm.org/doi/abs/10.1145/3409006

There is an implementation here:
https://github.com/LPTK/simple-sub
*/
typeInferenceMini(env : MiniTypeEnv, ex : MiniExp) -> MiniType2 {
	switch (ex) {
		MiniInt(value, __): setMiniType2Var(env, ex, MiniType2Int(32));
		MiniDouble(value): MiniType2Call("double", []);
		MiniString(value): MiniType2Call("string", []);
		MiniVar(name, __): {
			mlocal = lookupTree(env.localTypes, name);

			type = mlocal ?? mlocal : {
				mglobal = lookupTree(env.ast.types, name);
				switch (mglobal) {
					None(): {
						println("Does not know var " + name);
						makeMiniType2Var(env);
					}
					Some(t): t;
				}
			};

			// OK, we should instantiate this polymorphism
			itype = localTypePars2TypeVars(env, type);

			setMiniType2Var(env, ex, itype);
		}
		MiniLet(name, value, body, tv): {
			vtype = typeInferenceMini(env, value);
			nenv = setMiniLocalType2(env, name, vtype);
			setMiniType2Var(nenv, ex, typeInferenceMini(nenv, body));
		}
		MiniLambda(args, body, __): {
			argTypes = map(args, \arg -> makeMiniType2Var(env));
			nenv = foldi(args, env, \i, acc, arg -> {
				setMiniLocalType2(acc, arg, argTypes[i])
			});
			retType = typeInferenceMini(nenv, body);
			fnType = MiniType2Function(argTypes, retType);
			setMiniType2Var(nenv, ex, fnType);
		}
		MiniCall(fn, args, __): {
			// TODO: If this is __type with ??, we should instantiate it according to the typarmap
			resType = makeMiniType2Var(env);
			fnType = typeInferenceMini(env, fn);
			callType = MiniType2Function(
				map(args, \a -> typeInferenceMini(env, a)),
				resType
			);
			constrainMiniType(env, fnType, callType);
			setMiniType2Var(env, ex, resType);
		}
	}
}

constrainMiniType(env : MiniTypeEnv, lhs : MiniType2, rhs : MiniType2) -> void {
	if (containsSet(^(env.constraintCache), Pair(lhs, rhs))) {
		// OK, already handled
	} else {
		env.constraintCache := insertSet(^(env.constraintCache), Pair(lhs, rhs));
		
		// println("Constrain " + mtype2string(lhs) + " <: " + mtype2string(rhs));

		error = \ -> {
			println("Cannot constrain " + mtype2string(lhs) + " <: " + mtype2string(rhs));
		}

		rightTyVar = \rid -> {
			addMiniLowerBound(env, rid, lhs);
			constrainUpperBounds(env, rid, lhs);
		}

		todo = \ -> {
			println("TODO: Implement constrain " + mtype2string(lhs) + " <: " + mtype2string(rhs));
		}

		switch (lhs) {
			MiniType2Int(lbits): {
				switch (rhs) {
					MiniType2Int(rbits): if (lbits != rbits) error();
					MiniType2Var(rid): rightTyVar(rid);
					default: error();
				}
			}
			MiniType2Function(largs, lreturnType): {
				switch (rhs) {
					MiniType2Function(rargs, rreturnType): {
						// (Function(l0, r0), Function(l1, r1)) => constrain(l1, l0); constrain(r0, r1)
						if (length(largs) != length(rargs)) {
							error();
						} else {
							iteri(largs, \i, larg -> {
								constrainMiniType(env, rargs[i], larg);
							});
							constrainMiniType(env, lreturnType, rreturnType);
						}
					}
					MiniType2Var(rid): rightTyVar(rid);
					default: error();
				}
			}

			MiniType2Call(lid, ltypars): {
				switch (rhs) {
					MiniType2Call(rid, rtypars): {
						if (lid != rid || length(ltypars) != length(rtypars)) {
							error();
						} else {
							iteri(ltypars, \i, larg -> {
								constrainMiniType(env, rtypars[i], larg);
							});
						}
					}
					MiniType2Var(rid): rightTyVar(rid);
					default: error();
				}
			}
			MiniType2Var(lid): {
				def = \ -> {
					addMiniUpperBound(env, lid, rhs);
					constrainLowerBounds(env, lid, rhs);
				}

				switch (rhs) {
					MiniType2Var(rid): if (lid != rid) {
//						rightTyVar(rid);
						def();
					};
					default: def();
				}
			}
			MiniType2Par(lid): {
				switch (rhs) {
					MiniType2Par(rid): {
						if (lid != rid) {
							error();
						}
					}
					MiniType2Var(rid): rightTyVar(rid);
					default: error();
				}
			}
			MiniType2Record(fields): {
				/*
				(Record(fs0), Record(fs1)) =>
					fs1.foreach { 
						case (n1, t1) =>
							fs0.find(_._1 == n1) match {
								None => err("missing field: " + n1 + " in " + lhs);
								Some((_, t0)) => constrain(t0, t1) 
							}
					}
				*/
				todo();
			}
		}
	}
}

setMiniLocalType2(env : MiniTypeEnv, id : string, type : MiniType2) -> MiniTypeEnv {
// 	println(id + " = " + toString(type));
	MiniTypeEnv(env with localTypes = setTree(env.localTypes, id, type));
}

setMiniType2Var(env : MiniTypeEnv, ex : MiniExp, type : MiniType2) -> MiniType2 {
	def = \tv -> {
		id = if (tv == 0) {
			ttv = makeMiniType2Var(env);
			switch (ex) {
				MiniInt(value, tyvar): ex.tyvar ::= ttv.id;
				MiniVar(name, tyvar): ex.tyvar ::= ttv.id;
				MiniLet(name, value, body, tyvar): ex.tyvar ::= ttv.id;
				MiniLambda(args, body, tyvar): ex.tyvar ::= ttv.id;
				MiniCall(fn, args, tyvar): ex.tyvar ::= ttv.id;

				MiniDouble(value): {};
				MiniString(value): {};
			};
			ttv.id;
		} else tv;
		addMiniLowerBound(env, id, type);
		addMiniUpperBound(env, id, type);
		type;
	}
	switch (ex) {
		MiniInt(value, tyvar): def(tyvar);
		MiniVar(name, tyvar): def(tyvar);
		MiniLet(name, value, body, tyvar): def(tyvar);
		MiniLambda(args, body, tyvar): def(tyvar);
		MiniCall(fn, args, tyvar): def(tyvar);

		MiniDouble(value): type;
		MiniString(value): type;
	}
}

addMiniLowerBound(env : MiniTypeEnv, tyvar : int, type : MiniType2) -> void {
	env.tyvarLowerBounds := insertMultimap(^(env.tyvarLowerBounds), tyvar, type);
}

addMiniUpperBound(env : MiniTypeEnv, tyvar : int, type : MiniType2) -> void {
	env.tyvarUpperBounds := insertMultimap(^(env.tyvarUpperBounds), tyvar, type);
}

constrainLowerBounds(env : MiniTypeEnv, tyvar : int, type : MiniType2) -> void {
	types = lookupMultimap(^(env.tyvarLowerBounds), tyvar);
	iterSet(types, \ltype -> {
		constrainMiniType(env, ltype, type)
	})
}

constrainUpperBounds(env : MiniTypeEnv, tyvar : int, type : MiniType2) -> void {
	types = lookupMultimap(^(env.tyvarUpperBounds), tyvar);
	iterSet(types, \utype -> {
		constrainMiniType(env, type, utype)
	})
}
