import mini/types/typeinference;
import mini/exp/topological;
import mini/exp/pretty_typed;
import mini/backends/ast2bprogram;
import mini/backends/flow;
import mini/types/debug;

export {
	// Run a type inference and check on these ids
	// and return the resulting environment
	// This also updates the typed backend representation
	typecheckMiniTypes(ast : MiniAst, ids : Set<string>) -> MiniAst;
}

typecheckMiniTypes(ast : MiniAst, ids : Set<string>) -> MiniAst {
	// Find a topological order of these ids
	order = topologicalMiniOrder(ast.idDependents, ids);

	if (false) {
		println("Typing in this order:");
		println(order);
	}
	
	tenv = makeMiniTypeEnv(ast);
	// Do type inference and constraining of all ids
	tenv2 = fold(order, tenv, \acc, id -> {
		mfn = lookupTree(ast.declarations, id);
		mfn ?? {
			recursive = containsSet(lookupMultimap(ast.idDependents.dependencies, id), id);
			// OK, find the type of this
			typeInferenceMiniDeclaration(acc, id, recursive, mfn);
		} : {
			println("Unknown name " + id);
			acc;
		}
	});

	println("\nBefore resolution:");
	debugMiniTypeEnv(tenv2);
	println("\nDeclarations before:");
	iter(order, \id -> {
		mfn = lookupTree(ast.declarations, id);
		mfn ?? {
			println(id + " = " + miniPrettyTyped(tenv2, mfn));
		} : {}
	});

	// Next, set the type in the overall environment from the local environment
	println("\nResolving locals:");
	foldTree(tenv2.localTypes, ast, \local, type, acc -> {

		res = resolveMiniType(tenv2, type);
		println(local + " : " + debugMiniType(tenv2, res));
		acc;
	});

	println("\nAfter resolution:");
	// OK, now lower these ids to the backend representation
	nast = fold(order, tenv2.ast, \acc, id -> {
		mfn = lookupTree(acc.declarations, id);
		mfn ?? {
			bdecl = miniExp2BDeclaration(tenv2, id, mfn);
			println(id + " = " + miniPrettyTyped(tenv2, mfn));
			println(bdeclaration2flow(bdecl));
			MiniAst(acc with typedDeclarations = setTree(acc.typedDeclarations, id, bdecl));
		} : {
			acc;
		}
	});

	debugMiniTypeEnv(tenv2);

	nast;
}
