import mini/types/typeinference;
import mini/types/coalescing;
import mini/types/simplify;
import mini/exp/topological;
import mini/exp/pretty_typed;
import mini/backends/bprogram_lower;
import mini/backends/flow;
import mini/semantics/unfold;
import mini/semantics/simplify;
import mini/types/debug;

export {
	// Run a type inference and check on these ids
	// and return the resulting environment
	// This also updates the typed backend AST representation
	typecheckMiniTypes(ast : MiniAst, ids : Set<string>) -> MiniAst;
}

/*
Type checking runs like this on a batch of ids:
- Determine a suitable topological order to type infer from the leaves of dependencies
- Recursively infer MiniType types of each AST node in these ids, 
  collecting lower/upper-bound constraints on tyvars as MiniType
- Coalesce these MiniType bounds into ResTypes for each tyvar, and then convert these
  back into MiniType as the final types
- Then lower the AST to the typed backend representation

TODO:
- Figure out how to simplify unions of type vars, as seen in recursion as an example.
*/

typecheckMiniTypes(ast : MiniAst, ids : Set<string>) -> MiniAst {
	// Find a topological order of these ids
	order = topologicalMiniOrder(ast.idDependents, ids);

	if (false) {
		println("Typing in this order:");
		println(order);
	};
	
	tenv = makeMiniTypeEnv(ast);
	// Do type inference and constraining of all ids
	tenv2 = fold(order, tenv, \acc, id -> {
		mfn = lookupTree(ast.declarations, id);
		mfn ?? {
			recursive = containsSet(lookupMultimap(ast.idDependents.dependencies, id), id);
			// OK, find the type of this
			typeInferenceMiniDeclaration(acc, id, recursive, mfn);
		} : {
			println("Unknown name when type checking " + id);
			acc;
		}
	});

	if (false) {
		println("\nBefore resolution:");
		debugMiniTypeEnv(tenv2);

		println("\nDeclarations before:");
		iter(order, \id -> {
			mfn = lookupTree(ast.declarations, id);
			mfn ?? {
				println(id + " = " + miniPrettyTyped(tenv2, mfn));
			} : {}
		});
	};

	// OK, resolve the constraints
	resTypes = coalesceMiniTypeVars(tenv2);
//	println("Resolutions");
	traverseInOrder(resTypes, \tv, restype -> {
		resolved = simplifyResType(resTypes, restype);
		tenv2.tyvars := setTree(^(tenv2.tyvars), tv, resolved);
//		println("a"  + i2s(tv) + " = " + mtype2string(resolved));
	});

	// Here, we can run backend-independent optimizations
	// Maybe we should have a BExp based representation before we do a bstatement
	// one, since that will be easier to optimize.

	// "a : type = e; a"   -> "e : type"

//	println("\nAfter resolution:");
	// OK, now lower these ids to the backend representation
	nast = fold(order, tenv2.ast, \acc, id -> {
		mfn = lookupTree(acc.declarations, id);
		mfn ?? {
			bdecl = miniExp2BExp(tenv2, mfn);

			// This is the pipeline of optimizations:
			un = unfoldBExp(bdecl);
			// TODO: Keep track of what ids are pure
			pureIds = makeSet();

			opt = simplifyBExp(pureIds, un);

			MiniAst(acc with typedDeclarations = setTree(acc.typedDeclarations, id, opt));
		} : {
			acc;
		}
	});

	nast;
}
