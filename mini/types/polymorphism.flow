import mini/types/type;
import mini/types/typeenv;

export {
	// Construct type vars consistently for the typars in this type
	instantiateTypePars2TypeVars(env : MiniTypeEnv, e : MiniType) -> MiniType;

	makeMiniTypeVar(env : MiniTypeEnv) -> MiniTypeVar;

	extractMiniTypePars(acc : Set<MiniTypePar>, e : MiniType) -> Set<MiniTypePar>;

	// Any implicit type parameters are expanded here
	resolveImplicitTypePars(env : MiniAst, e : MiniType) -> MiniType;
}

instantiateTypePars2TypeVars(env : MiniTypeEnv, e : MiniType) -> MiniType {
	typePars2TypeVars(env, ref makeTree(), e);
}

// Map from type par to type var id
typePars2TypeVars(env : MiniTypeEnv, typarMap : ref Tree<string, int>, e : MiniType) -> MiniType {
	switch (e) {
		MiniTypeInt(bits): e;
		MiniTypeFunction(args, returnType): {
			MiniTypeFunction(map(args, \a -> typePars2TypeVars(env, typarMap, a)), typePars2TypeVars(env, typarMap, returnType));
		}
		MiniTypeCall(id, typars): {
			MiniTypeCall(id, map(typars, \a -> typePars2TypeVars(env, typarMap, a)));
		}
		MiniTypeVar(id): {
			mtype = lookupTree(^(env.tyvars), id);
			mtype ?? {
				typePars2TypeVars(env, typarMap, mtype);
			} : e;		}
		MiniTypePar(id): {
			mtyvarid = lookupTree(^typarMap, id);
			mtyvarid ?? { MiniTypeVar(mtyvarid) } : {
				tv = makeMiniTypeVar(env);
				typarMap := setTree(^typarMap, id, tv.id);
				tv;
			}
		}
		MiniTypeRecord(fields): {
			MiniTypeRecord(map(fields, \f -> {
				MiniTypeField(f.name, f.isMutable, typePars2TypeVars(env, typarMap, f.type))
			}))
		}
	}
}


makeMiniTypeVar(env : MiniTypeEnv) -> MiniTypeVar {
	id = ^(env.tyvarId);
	env.tyvarId := id + 1;
	MiniTypeVar(id);
}


extractMiniTypePars(acc : Set<MiniTypePar>, e : MiniType) -> Set<MiniTypePar> {
	switch (e) {
		MiniTypeInt(bits): acc;
		MiniTypeVar(id): acc;
		MiniTypePar(id): insertSet(acc, e);
		MiniTypeFunction(args, returnType): fold(args, extractMiniTypePars(acc, returnType), extractMiniTypePars);
		MiniTypeCall(id, typars): fold(typars, acc, extractMiniTypePars);
		MiniTypeRecord(fields): {
			fold(fields, acc, \acc2, field -> {
				extractMiniTypePars(acc2, field.type)
			})
		}
	}	
}

resolveImplicitTypePars(env : MiniAst, t : MiniType) -> MiniType {
	rec = \tt -> resolveImplicitTypePars(env, tt);
	switch (t) {
		MiniTypeInt(bits): t;
		MiniTypeFunction(args, returnType): MiniTypeFunction(map(args, rec), rec(returnType));
		MiniTypeCall(id, typars): {
			mstruct = lookupTree(env.structs, id);
			fix = \tps -> {
				if (length(typars) > length(tps)) {
					println("Too many type parameters for " + id);
				}
				mapi(tps, \i, tp0 -> {
					tp = elementAt(typars, i, {
						// TODO: When we make implicit typepars, we should probably convert them to "auto"
	/*					switch (tp0) {
							MiniTypePar(__): {
								MiniTypeCall("auto", []);
							}
							default: tp0;
						}*/
						tp0;
					});

					resolveImplicitTypePars(env, tp);
				});
			}

			mstruct ?? {
				MiniTypeCall(id, fix(map(mstruct.fields, \a -> a.type)));
			} : {
				munion = lookupTree(env.unions, id);
				switch (munion) {
					None(): {
						println("Unknown typename " + id);
						t;
					}
					Some(union): {
						MiniTypeCall(id, fix(union.typars));
					}
				}
			}
		}
		MiniTypeVar(id): t;
		MiniTypePar(id): t;
		MiniTypeRecord(fields): MiniTypeRecord(map(fields, \f -> MiniTypeField(f with type = rec(f.type))));
	}
}
