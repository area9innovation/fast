import mini/types/typeenv;
import mini/types/pretty;

export {
	// Given these two type calls, constrain them against each other
	// Notice this is also used array<?>, ref<?> and such.
	constrainMiniTypeCalls(env : MiniTypeEnv, lhs : MiniTypeCall, rhs : MiniTypeCall) -> void;
}


constrainMiniTypeCalls(env : MiniTypeEnv, lhs : MiniTypeCall, rhs : MiniTypeCall) -> void {
	if (isMiniTypeNameIncluded(env.ast, lhs.id, rhs.id)) {
		// TODO: Figure out how the type-pars align with each other
		if (lhs.typars != [] || rhs.typars != []) {
			println("TODO: Constrain typars of " + miniType2string(lhs) + " vs " + miniType2string(rhs));
		}
	} else {
		env.onError("Type " + lhs.id + " is not part of type " + rhs.id);
	}
}

// Check if this left name is inside the typename on the right
isMiniTypeNameIncluded(env : MiniAst, left : string, right : string) -> bool {
	if (left == "auto" || right == "auto") {
		true
	} else {
		munion = lookupTree(env.unions, right);
		switch (munion) {
			None(): {
				left == right;
			}
			Some(uniondef): {
				fold(uniondef.typenames, false, \acc, type -> {
					acc || isMiniTypeNameIncluded(env, left, getMiniTypeName(type))
				});
			}
		}
	}
}

getMiniTypeName(m : MiniType) -> string {
	switch (m) {
		MiniTypeCall(id, __): id;
		default: "";
	}
}
