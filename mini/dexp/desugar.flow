import mini/dexp/dexp;
import mini/pexp/pexp;
import mini/pexp/values;

export {
	// Desugar a module
	desugarPExp(dd : DDesugar, p : PExp) -> DModule;
		DDesugar(
			flowpath : string,
			resolveName : (string) -> DTopLevel,
			onError : (int, string) -> void,
		);
}

desugarPExp(dd : DDesugar, pexp : PExp) -> DModule {
	module = getPModule(pexp);
	if (module.pos == -1) dd.onError(pexp.pos, "Expected module");

	imports = filtermap(module.toplevels, \tl -> {
			switch (tl) {
				PImport(path, pos): {
					// TODO: Should we check that this path exists?
					if (path == "") dd.onError(pos, "Unknown import path");
					Some(DImport(path, pos));
				}
				PForbid(path, pos): {
					Some(DForbid(path, pos));
				}
				default: None();
			}
		});

	dummyExport = DExport([], pexp.pos);
	exports = fold(module.toplevels, dummyExport, \acc, tl : PTopLevel -> {
		switch (tl) {
			PExport(tls, p): {
				if (acc != dummyExport) {
					dd.onError(p, "Only one export section is allowed");
				}
				DExport(
					map(tls, \t -> convertPExp2DToplevel(dd, t)),
					p
				);
			}
			default: acc;
		}
	});
	toplevels0 = fold(module.toplevels, Pair(makeTree(), makeList()), \acc, tl : PTopLevel -> {
		set = \name, tt -> {
			mdef = lookupTree(acc.first, name);
			mdef ?? {
				// TODO: If the definitions are compatible, we should not complain, but
				// keep them separately
				dd.onError(tl.pos, "Redefinition of " + name);
				dd.onError(mdef.pos, "Previous definition is here");
			} : {}
			Pair(
				setTree(acc.first, name, tt),
				Cons(name, acc.second)
			)
		}
		switch (tl) {
			PGlobal(id, value, pos): set(id, convertPExp2DToplevel(dd, tl));
			PNative(id, isIo, type, name, pos): set(id, convertPExp2DToplevel(dd, tl));
			PUnion(typename, types, pos): set(typename.id, convertPExp2DToplevel(dd, tl));
			PStruct(id, structArgs, pos): set(id, convertPExp2DToplevel(dd, tl));
			PTypeDef(id, type, pos): set(id, convertPExp2DToplevel(dd, tl));
			default: acc;
		}
	});

	DModule(
		dd.flowpath,
		imports,
		exports,
		toplevels0.first,
		list2array(toplevels0.second),
		pexp.pos,
	);
}

convertPExp2DToplevel(dd : DDesugar, tl : PTopLevel) -> DTopLevel {
	error = \ -> {
		dd.onError(tl.pos, "Expected global, native, function, union, struct or type def");
		DStruct("", [], tl.pos);
	}
	switch (tl) {
		PModule(toplevels, pos): error();
		PImport(path, pos): error();
		PForbid(path, pos): error();
		PExport(exports, pos): error();
		PGlobal(id, value, pos): DGlobal(id, pexp2dexp(dd, value), pos);
		PNative(id, isIo, type, name, pos): DNative(id, isIo, ptype2dtype(dd, type), name, pos);
		PUnion(typename, types, pos): DUnion(ptypename2dtypename(dd, typename), map(types, \t -> ptypename2dtypename(dd, t)), pos);
		PStruct(id, structArgs, pos): DStruct(id, map(structArgs, \sa -> pstructArg2dstructArg(dd, sa)), pos);
		PStructArg(id, ismutable, type, pos): error();
		PTypeDef(id, type, pos): DTypeDef(id, ptype2dtype(dd, type), pos);
	}
}

pexp2dexp(dd : DDesugar, pexp : PExp) -> DExp {
	error = \ -> {
		dd.onError(pexp.pos, "Expected expression");
		DVoid(pexp.pos);
	}
	switch (pexp) {
		PVoid(pos): DVoid(pos);
		PBool(v, pos): DBool(v, pos);
		PInt(v, pos): DInt(v, pos);
		PDouble(v, pos): DDouble(v, pos);
		PString(v, pos): DString(v, pos);
		PVar(var, pos): DVar(var, pos);

		default: {
			println("TODO: Desugar " + toString(pexp));
			DVoid(pexp.pos);
		}

		PModule(toplevels, pos): error();
		PImport(path, pos): error();
		PForbid(path, pos): error();
		PExport(exports, pos): error();
		PGlobal(id, value, pos): error();
		PNative(id, isIo, type, name, pos): error();
		PUnion(typename, types, pos): error();
		PStruct(id, structArgs, pos): error();
		PStructArg(id, ismutable, type, pos): error();
		PTypeDef(id, type, pos): error();
		PTypePar(id, pos): error();
		PTypeName(id, typars, pos): error();
		PTypeFunction(args, returnType, pos): error();
		PArgType(id, type, pos): error();

		PList(l, pos): error();
		PFieldAssign(id, value, pos): error();
	}
}

ptype2dtype(dd : DDesugar, p : PType) -> DType {
	switch (p) {
		PTypePar(id, pos): DTypePar(id, pos);
		PTypeName(id, typars, pos): ptypename2dtypename(dd, p);
		PTypeFunction(args, returnType, pos): DTypeFunction(map(args, \at -> ptype2dtype(dd, at)), ptype2dtype(dd, returnType), pos);
		PArgType(id, type, pos): ptype2dtype(dd, type); // We just drop the name
	}
}

ptypename2dtypename(dd : DDesugar, p : PTypeName) -> DTypeName {
	DTypeName(p.id, map(p.typars, \tp -> ptype2dtype(dd, tp)), p.pos);
}

pstructArg2dstructArg(dd : DDesugar, s : PStructArg) -> DStructArg {
	DStructArg(s.id, s.ismutable, ptype2dtype(dd, s.type), s.pos)
}
