import mini/exp/ast;
import mini/exp/pretty;
import mini/interpreter/natives;
import mini/interpreter/env;

export {
	makeMiniInterpreter(ast : MiniAst) -> MiniInterpreter;

	// This inlines calls and let-bindings
	interpretMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp;
}

makeMiniInterpreter(ast : MiniAst) -> MiniInterpreter {
	MiniInterpreter(ast);
}

interpretMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp {
	switch (e) {
		MiniValue(): e;
		MiniVar(name, __, tyvar): {
			lookupTreeDef(env.env.declarations, name, e);
		}
		MiniLet(name, value, body, __, tyvar): {
			evalue = interpretMiniExp(env, value);
			nenv = setMiniInterpreterVar(env, name, evalue);
			interpretMiniExp(nenv, body);
		}
		MiniLambda(args, body, __, tyvar): {
			// TODO: Grab closure?
			e;
		}
		MiniCall(fn, args, pos, tyvar): {
			efn = interpretMiniExp(env, fn);
			def = \ -> {
				eargs = map(args, \a -> interpretMiniExp(env, a));
				interpretMiniCall(env, efn, eargs, pos, tyvar)
			}
			switch (efn) {
				MiniVar(name, __, __): {
					if (name == "__ifte") {
						cond = interpretMiniExp(env, args[0]);
						if (isMiniInt(cond)) {
							condval = getMiniInt(cond);
							if (condval != 0) {
								interpretMiniExp(env, args[1]);
							} else {
								interpretMiniExp(env, args[2]);
							}
						} else {
							MiniCall(efn, [cond, args[1], args[2]], pos, tyvar);
						}
					} else if (name == "__ift") {
						cond = interpretMiniExp(env, args[0]);
						if (isMiniInt(cond)) {
							condval = getMiniInt(cond);
							if (condval != 0) {
								interpretMiniExp(env, args[1]);
							} else {
								MiniCall(MiniVar("__void", pos, tyvar), [], pos, tyvar);
							}
						} else {
							MiniCall(efn, [cond, args[1]], pos, tyvar);
						}
					} else {
						def();
					}
				}
				default: def();
			}
			// Don't eval args to if
		}
	}
}

interpretMiniCall(env : MiniInterpreter, fn : MiniExp, args : [MiniExp], pos : int, tyvar : int) -> MiniExp {
	switch (fn) {
		MiniLambda(largs, body, __, __): {
			nenv = foldi(largs, env, \i, acc, arg -> {
				setMiniInterpreterVar(acc, arg, args[i])
			});
			interpretMiniExp(nenv, body)
		}
		MiniVar(name, __, __): {
			evalMiniStaticCall(env, fn, args, pos, tyvar)
		}
		default: MiniCall(fn, args, pos, tyvar);
	}
}

setMiniInterpreterVar(env : MiniInterpreter, name : string, value : MiniExp) -> MiniInterpreter {
	nast = MiniAst(env.env with declarations = setTree(env.env.declarations, name, value));
	MiniInterpreter(env with env = nast);
}
