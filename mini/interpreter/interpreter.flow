import mini/exp/ast;
import mini/exp/pretty;
import mini/interpreter/natives;
import mini/interpreter/env;

export {
	makeMiniInterpreter(ast : MiniAst) -> MiniInterpreter;

	// This inlines calls and let-bindings
	interpretMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp;
}

makeMiniInterpreter(ast : MiniAst) -> MiniInterpreter {
	MiniInterpreter(ast, ref 0, ref makeTree());
}

interpretMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp {
	switch (e) {
		MiniValue(): e;
		MiniVar(name, __, tyvar): {
			lookupTreeDef(env.env.declarations, name, e);
		}
		MiniLet(name, value, body, __, tyvar): {
			evalue = interpretMiniExp(env, value);
			nenv = setMiniInterpreterVar(env, name, evalue);
			interpretMiniExp(nenv, body);
		}
		MiniLambda(args, body, __, tyvar): {
			// TODO: Grab closure?
			e;
		}
		MiniCall(fn, args, pos, tyvar): {
			normal = \ -> {
				efn = interpretMiniExp(env, fn);
				def = \ -> {
					eargs = map(args, \a -> interpretMiniExp(env, a));
					interpretMiniCall(env, efn, eargs, pos, tyvar)
				}
				switch (efn) {
					MiniVar(name, __, __): {
						// Do the functions which include control flow
						if (name == "__ifte") {
							cond = interpretMiniExp(env, args[0]);
							if (isMiniInt(cond)) {
								condval = getMiniInt(cond);
								if (condval != 0) {
									interpretMiniExp(env, args[1]);
								} else {
									interpretMiniExp(env, args[2]);
								}
							} else {
								MiniCall(efn, [cond, args[1], args[2]], pos, tyvar);
							}
						} else if (name == "__ift") {
							cond = interpretMiniExp(env, args[0]);
							if (isMiniInt(cond)) {
								condval = getMiniInt(cond);
								if (condval != 0) {
									interpretMiniExp(env, args[1]);
								} else {
									MiniCall(MiniVar("__void", pos, tyvar), [], pos, tyvar);
								}
							} else {
								MiniCall(efn, [cond, args[1]], pos, tyvar);
							}
						} else if (name == "&&") {
							left = interpretMiniExp(env, args[0]);
							if (isMiniInt(left)) {
								leftv = getMiniInt(left);
								if (leftv == 0) {
									// False
									left;
								} else {
									interpretMiniExp(env, args[1]);
								}
							} else {
								right = interpretMiniExp(env, args[1]);
								MiniCall(efn, [left, right], pos, tyvar);
							}
						} else if (name == "||") {
							left = interpretMiniExp(env, args[0]);
							if (isMiniInt(left)) {
								leftv = getMiniInt(left);
								if (leftv != 0) {
									// True
									left;
								} else {
									interpretMiniExp(env, args[1]);
								}
							} else {
								right = interpretMiniExp(env, args[1]);
								MiniCall(efn, [left, right], pos, tyvar);
							}
						} else if (name == "__switch") {
							value = interpretMiniExp(env, args[0]);
							if (isMiniString(value)) {
								interpretSwitch(env, getMiniString(value), args[0], args[1], pos, tyvar);
							} else {
								MiniCall(MiniVar("__switch", pos, tyvar), [value, args[1]], pos, tyvar);
							}
						} else if (isNativeInterpreted(name)) {
							eargs = map(args, \a -> interpretMiniExp(env, a));
							evalMiniStaticCall(env, efn, eargs, pos, tyvar);
						} else {
							def();
						}
					}
					MiniCall(nfn, nargs, __,__): {
						switch (nfn) {
							MiniVar(nat, __, __): {
								if (nat == "__native") {
									println("TODO: Implement native " + getMiniString(nargs[2]) + " in interpreter/natives.flow");
									def();
								} else if (nat == ":") {
									cfn = interpretMiniExp(env, nargs[0]);

									eargs = map(args, \a -> interpretMiniExp(env, a));
									interpretMiniCall(env, cfn, eargs, pos, tyvar)
								} else {
									def();
								}
							}
							default: def();
						}
					}
					default: {
						def();
					}
				}
			};

			// Check if we have a built-in native
			switch (fn) {
				MiniVar(name, __, __): {
					if (isNativeInterpreted(name)) {
						eargs = map(args, \a -> interpretMiniExp(env, a));
						evalMiniStaticCall(env, fn, eargs, pos, tyvar);
					} else normal();
				}
				default: normal();
			};
		}
	}
}

interpretMiniCall(env : MiniInterpreter, fn : MiniExp, args : [MiniExp], pos : int, tyvar : int) -> MiniExp {
	switch (fn) {
		MiniLambda(largs, body, __, __): {
			nenv = foldi(largs, env, \i, acc, arg -> {
				setMiniInterpreterVar(acc, arg, args[i])
			});
			interpretMiniExp(nenv, body)
		}
		MiniVar(name, __, __): {
			evalMiniStaticCall(env, fn, args, pos, tyvar)
		}
		default: MiniCall(fn, args, pos, tyvar);
	}
}

setMiniInterpreterVar(env : MiniInterpreter, name : string, value : MiniExp) -> MiniInterpreter {
	nast = MiniAst(env.env with declarations = setTree(env.env.declarations, name, value));
	MiniInterpreter(env with env = nast);
}


interpretSwitch(env : MiniInterpreter, case : string, value : MiniExp, cases : MiniExp, pos : int, tyvar : int) -> MiniExp {
	def =  \ -> {
		MiniCall(MiniVar("__switch", pos, tyvar), [MiniString(case, pos), cases], pos, tyvar);
	};

	case1 = getMiniStaticCall(cases);
	if (case1 == "__or") {
		mcasebody = find(getMiniCallArgs(cases), \cc -> {
			cargs = getMiniCallArgs(cc);
			casename = getMiniVar(cargs[0]);
			casename == case;
		});
		mcasebody ?? {
			cargs = getMiniCallArgs(mcasebody);
			vars = getMiniArray(cargs[1]);

			// What is the name of the underlying value?
			underlying = getMiniCallArgs(value)[0];
			// This is wasteful, but since it is a variable, should not be too bad:
			underlyingValue = interpretMiniExp(env, underlying);
			structArgs = getMiniCallArgs(underlyingValue);

			nenv = foldi(vars, env, \i, acc, var -> {
				setMiniInterpreterVar(acc, getMiniString(var), structArgs[i]);
			});
			interpretMiniExp(nenv, cargs[2]);
		} : {
			def();
		}
	} else {
		println("TODO: Find case " + case + " amongst");
		println(cases);
		println(case1);
		def();
	}
}
