import mini/interpreter/interpreter;
import mini/exp/value;
import mini/exp/compare;
import mini/types/type_ast;
import mini/types/util;
import mini/types/implicit_polymorphism;

export {
	// This does a few desugaring things:
	// - Expand switch and cases to the correct form with variable bindings
	// - "m ?? t : e" is expanded
	// - Make implicit type parameters explicit. Maybe -> Maybe<?>. TODO: Should this be Maybe<auto> instead?
	partialMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp;
}

partialMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp {
	switch (e) {
		MiniValue(): e;
		MiniVar(name, tyvar): e;
		MiniLet(name, value, body, tyvar): {
			MiniLet(name, partialMiniExp(env, value), partialMiniExp(env, body), tyvar);
		}
		MiniLambda(args, body, tyvar): {
			MiniLambda(args, partialMiniExp(env, body), tyvar);
		}
		MiniCall(ofn, oargs, tyvar): {
			fn = partialMiniExp(env, ofn);
			args = map(oargs, \a -> partialMiniExp(env, a));
			def = \ -> {
				MiniCall(fn, args, tyvar);
			};
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ctcase") {
						processMiniCase(env, args);
					} else if (fname == "__switch") {
						processMiniSwitch(env, args);
					} else if (fname == "__ctmaybe") {
						processMiniMaybe(env, args);
					} else if (fname == "__compiletime") {
						interpretMiniExp(env, e);
					} else if (fname == "__type") {
						interpretMiniType(env, def());
					} else {
						// if fname is a type, we could evaluate it now if we had some way of representing the result
						def();
					}
				}
				default: def();
			}
		}
	}
}

// This expands switch cases correctly
// __ctcase(id, __cons("a", "b"), body)
processMiniCase(env : MiniInterpreter, args : [MiniExp]) -> MiniExp {
	struct : string = getMiniVar(args[0]);
	vars : [string] = map(getMiniArray(args[1]), getMiniString);
	body = partialMiniExp(env, args[2]);

	mstructdef = lookupTree(env.env.structs, struct);
	mstructdef ?? {
		/*
		We turn "Some(v): body;" into the equivalent of this:
		__case(Some, 
			// Downcast
			__switchvar = __switchvar : __type("Some");
			// Index
			v = __switchvar."value";
			v;
		)
		*/
		bodyLet = foldi(vars, body, \i, acc, var -> {
						if (var != "__") {
							MiniLet(var, MiniCall(MiniVar(".", 0), [
								MiniVar("__switchvar", 0), 
								MiniString(mstructdef.fields[i].name, -1)
							], 0), acc, 0)
						} else acc
					});

		MiniCall(MiniVar("__case", 0), 
			[
				MiniCall(
					MiniVar("__caseid", 0),
					[
						MiniVar(struct, 0),
					], 0
				),
				// This implies a downcast in the body of __switchvar
				MiniCall(MiniVar("__downcast", 0), [
					MiniVar("__switchvar", 0),
					miniType2Exp(MiniTypeCall(struct, [])),
					bodyLet,
				], 0),
			], 
			0
		);
	} : {
		// We assume this is a union, which will be expanded by processMiniSwitch
		MiniCall(MiniVar("__case", 0),
			[
				MiniCall(
					MiniVar("__caseid", 0),
					[
						MiniVar(struct, 0),
					], 0
				),
				body
			], 0
		)
	}
}

processMiniSwitch(env : MiniInterpreter, args : [MiniExp]) -> MiniExp {
	// The cases
	cases : [MiniExp] = extractMiniCases([], args[1]);

	// Find and expand all unions
	expanded = concatA(map(cases, \c -> {
		switch (c) {
			MiniCall(fn, fargs, __): {
				switch (fn) {
					MiniVar(name, __): {
						if (name == "__defaultcase") [c]
						else {
							switch (fargs[0]) {
								MiniCall(fn2, args2, __): {
									cname = getMiniVar(args2[0]);
									udef = lookupTree(env.env.unions, cname);
									switch (udef) {
										None(): [c];
										Some(def): {
											map(def.typenames, \tn -> {
												sname = getMiniTypeName(tn);
												sbody = fargs[1];
												MiniCall(MiniVar("__case", 0), [MiniCall(MiniVar("__caseid", 0), [MiniVar(sname, 0)], 0), sbody], 0)
											});
										}
									}
								}
								default: [c];
							}
						}
					}
					default: [c];
				}
			}
			default: [c];
		}
	}));

	nargs = if (expanded != []) {
		[
			args[0],
			fold(tail(expanded), expanded[0], \acc, c -> {
				MiniCall(MiniVar("__or", 0), [acc, c], 0)
			})
		]
	} else {
		args;
	};

	MiniCall(MiniVar("__switch", 0), nargs, 0)
}

extractMiniCases(acc : [MiniExp], e : MiniExp) -> [MiniExp] {
	switch (e) {
		MiniCall(fn, args,__): {
			switch (fn) {
				MiniVar(name, __): {
					if (name == "__or") {
						nacc = extractMiniCases(acc, args[0]);
						extractMiniCases(nacc, args[1]);
					} else {
						arrayPush(acc, e);
					}
				}
				default: {
					println("Expected case in switch");
					acc;
				}
			}
		}
		default: {
			println("Expected case in switch");
			acc;
		}
	}
}

processMiniMaybe(env : MiniInterpreter, args : [MiniExp]) -> MiniExp {
	/*
	We expand "a ?? b : c" like this:

	__switchvar = %a%;
	__switch(
		__switchvalue(__switchvar), 
		__or(
			__case(
				__caseid(Some), 
				__downcast(
					__switchvar, 
					__type("Some"), 
					(
						__maybevalue = .(__switchvar, "value");
						replace(%b%, %a%, __maybevalue) 
					)
				)
			), 
			__case(
				__caseid(None), 
				__downcast(
					__switchvar, 
					__type("None"), 
					%c%
				)
			)
		)
	)
	*/

	MiniLet("__switchvar", args[0], 
		MiniCall(MiniVar("__switch", 0), [
			MiniCall(MiniVar("__switchvalue", 0), [
				MiniVar("__switchvar", 0)
			], 0),
			MiniCall(MiniVar("__or", 0), [
				MiniCall(MiniVar("__case", 0), [
					MiniCall(MiniVar("__caseid", 0), [
						MiniVar("Some", 0)
					], 0),
					MiniCall(MiniVar("__downcast", 0), [
						MiniVar("__switchvar", 0),
						MiniCall(MiniVar("__type", 0), [MiniString("Some", -1)], 0),
						MiniLet(
							"__maybeval",
							MiniCall(MiniVar(".", 0), [MiniVar("__switchvar", 0), MiniString("value", -1)], 0),
							// Replace "args[0]" with MiniVar("__maybeval")
							replaceMiniExp(args[1], args[0], MiniVar("__maybeval", 0)),
							0
						)
					], 0),

				], 0),
				MiniCall(MiniVar("__case", 0), [
					MiniCall(MiniVar("__caseid", 0), [
						MiniVar("None", 0)
					], 0),
					MiniCall(MiniVar("__downcast", 0), [
						MiniVar("__switchvar", 0),
						MiniCall(MiniVar("__type", 0), [MiniString("None", -1)], 0),
						args[2]
					], 0),
				], 0)
			], 0)
		], 0), 0
	);
}

replaceMiniExp(e : MiniExp, finde : MiniExp, replacee : MiniExp) -> MiniExp {
	if (isSameMiniExp(e, finde)) replacee
	else {
		rec = \v -> replaceMiniExp(v, finde, replacee);
		switch (e) {
			MiniInt(value, tyvar): e;
			MiniDouble(value, __): e;
			MiniString(value, __): e;
			MiniVar(name, tyvar): e;
			MiniLet(name, value, body, tyvar): {
				MiniLet(name, rec(value), rec(body), tyvar)
			}
			MiniLambda(args, body, tyvar): {
				MiniLambda(args, rec(body), tyvar);
			}
			MiniCall(fn, args, tyvar): {
				MiniCall(rec(fn), map(args, rec), tyvar)
			}
		}
	}
}

// Here, we should ensure that typenames have the correct number of typars
interpretMiniType(e : MiniInterpreter, calltype : MiniExp) -> MiniExp {
	type = convertMiniExp2Type(calltype);
	explicitTypars = resolveImplicitTypePars(e.env, type);
	if (explicitTypars != type) {
		miniType2Exp(explicitTypars);
	} else {
		calltype;
	}
}
