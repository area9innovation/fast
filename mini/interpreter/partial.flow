import mini/interpreter/interpreter;
import mini/exp/value;
import mini/types/type_ast;

export {
	partialMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp;
}

partialMiniExp(env : MiniInterpreter, e : MiniExp) -> MiniExp {
	switch (e) {
		MiniValue(): e;
		MiniVar(name, tyvar): e;
		MiniLet(name, value, body, tyvar): {
			MiniLet(name, partialMiniExp(env, value), partialMiniExp(env, body), tyvar);
		}
		MiniLambda(args, body, tyvar): {
			MiniLambda(args, partialMiniExp(env, body), tyvar);
		}
		MiniCall(ofn, oargs, tyvar): {
			fn = partialMiniExp(env, ofn);
			args = map(oargs, \a -> partialMiniExp(env, a));
			def = \ -> {
				MiniCall(fn, args, tyvar);
			};
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ctcase") {
						processMiniCase(env, args);
					} else if (fname == "__ctmaybe") {
						processMiniMaybe(env, args);
					} else if (fname == "__compiletime") {
						interpretMiniExp(env, e);
					} else {
						// if fname is a type, we could evaluate it now if we had some way of representing the result
						def();
					}
				}
				default: def();
			}
		}
	}
}

// This expands switch cases correctly
// __ctcase(id, __cons("a", "b"), body)
processMiniCase(env : MiniInterpreter, args : [MiniExp]) -> MiniExp {
	struct : string = getMiniVar(args[0]);
	vars : [string] = map(getMiniArray(args[1]), getMiniString);
	body = partialMiniExp(env, args[2]);

	mstructdef = lookupTree(env.env.structs, struct);
	mstructdef ?? {
		/*
		We turn "Some(v): body;" into the equivalent of this:
		__case(Some, 
			// Downcast
			__switchvar = __switchvar : __type("Some");
			// Index
			v = __switchvar."value";
			v;
		)
		*/
		bodyLet = foldi(vars, body, \i, acc, var -> {
						if (var != "__") {
							MiniLet(var, MiniCall(MiniVar(".", 0), [MiniVar("__switchvar", 0), MiniString(mstructdef.fields[i].name)], 0), acc, 0)
						} else acc
					});

		MiniCall(MiniVar("__case", 0), 
			[
				MiniCall(
					MiniVar("__caseid", 0),
					[
						MiniVar(struct, 0),
					], 0
				),
				// This implies a downcast in the body of __switchvar
				MiniCall(MiniVar("__casebody", 0), [
					MiniVar("__switchvar", 0),
					miniType2Exp(MiniTypeCall(struct, [])),
					bodyLet,
				], 0),
			], 
			0
		);
	} : {
		muniondef = lookupTree(env.env.unions, struct);
		switch (muniondef) {
			None(): {
				// OK, we have a problem if we import none, and that means it is
				// not known at this point.
				println("Unknown case in switch " + struct);
				body;
			}
			Some(uniondef): {
				println("TODO: Implement expansion of union case in switch: " + struct);
				body;
			}
		}
	}
}

processMiniMaybe(env : MiniInterpreter, args : [MiniExp]) -> MiniExp {
	/*
	We expand "a ?? b : c" like this:

	__switchvar = %a%;
	__switch(
		__switchvalue(__switchvar), 
		__or(
			__case(
				__caseid(Some), 
				__casebody(
					__switchvar, 
					__type("Some"), 
					(
						__maybevalue = .(__switchvar, "value");
						replace(%b%, %a%, __maybevalue) 
					)
				)
			), 
			__case(
				__caseid(None), 
				__casebody(
					__switchvar, 
					__type("None"), 
					%c%
				)
			)
		)
	)
	*/

	MiniLet("__switchvar", args[0], 
		MiniCall(MiniVar("__switch", 0), [
			MiniCall(MiniVar("__switchvalue", 0), [
				MiniVar("__switchvar", 0)
			], 0),
			MiniCall(MiniVar("__or", 0), [
				MiniCall(MiniVar("__case", 0), [
					MiniCall(MiniVar("__caseid", 0), [
						MiniVar("Some", 0)
					], 0),
					MiniCall(MiniVar("__casebody", 0), [
						MiniVar("__switchvar", 0),
						MiniCall(MiniVar("__type", 0), [MiniString("Some")], 0),
						MiniLet(
							"__maybeval",
							MiniCall(MiniVar(".", 0), [MiniVar("__switchvar", 0), MiniString("value")], 0),
							// Replace "args[0]" with MiniVar("__maybeval")
							replaceMiniExp(args[1], args[0], MiniVar("__maybeval", 0)),
							0
						)
					], 0),

				], 0),
				MiniCall(MiniVar("__case", 0), [
					MiniCall(MiniVar("__caseid", 0), [
						MiniVar("None", 0)
					], 0),
					MiniCall(MiniVar("__casebody", 0), [
						MiniVar("__switchvar", 0),
						MiniCall(MiniVar("__type", 0), [MiniString("None")], 0),
						args[2]
					], 0),
				], 0)
			], 0)
		], 0), 0
	);
}

replaceMiniExp(e : MiniExp, finde : MiniExp, replacee : MiniExp) -> MiniExp {
	if (e == finde) replacee
	else {
		rec = \v -> replaceMiniExp(v, finde, replacee);
		switch (e) {
			MiniInt(value, tyvar): e;
			MiniDouble(value): e;
			MiniString(value): e;
			MiniVar(name, tyvar): e;
			MiniLet(name, value, body, tyvar): {
				MiniLet(name, rec(value), rec(body), tyvar)
			}
			MiniLambda(args, body, tyvar): {
				MiniLambda(args, rec(body), tyvar);
			}
			MiniCall(fn, args, tyvar): {
				MiniCall(rec(fn), map(args, rec), tyvar)
			}
		}
	}
}
