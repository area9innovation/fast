import mini/exp/ast;
import mini/backends/bprogram;
import mini/exp/topological;
import mini/exp/pretty;

export {
	miniAst2BProgram(ast : MiniAst) -> BProgram;
}

miniAst2BProgram(ast : MiniAst) -> BProgram {
	// Here we effectively do DCE:
	// TODO: Also include all top-level vars with side-effects
	ids0 : Set<string> = getMiniDependencies(ast.idDependents, "main", true);
	ids = if (isEmptySet(ids0)) {
		println("Could not find main. Keep everything");
		buildSet(getTreeKeys(ast.declarations)) 
	} else ids0;

	order = topologicalMiniOrder(ast.idDependents, ids);

	BProgram(
		map(order, \id -> {
			mdecl = lookupTree(ast.declarations, id);
			mdecl ?? {
				miniExp2BDeclaration(id, mdecl)
			} : BComment("// ERROR: Unknown id " + id)
		})
	);
}

miniExp2BDeclaration(declid : string, e : MiniExp) -> BDeclaration {
	error = \ -> {
		BComment("// Can not convert " + miniPretty(e) + " for " + declid);
	}
	switch (e) {
		MiniValue(): BGlobalVar(declid, miniValue2BValue(e));
		MiniVar(name, tv): error();
		MiniLet(name, value, body, tv): error();
		MiniLambda(args, body, tv): {
			bbody = miniExp2BReturn(body);
			BFunction(declid, map(args, \a -> BFunArg(a)), bbody);
		}
		MiniCall(fn, args, tv): error();
		MiniTypeInt(bits): error();
		MiniTypeFunction(args, returnType): error();
		MiniTypeCall(id, typars): error();
	}
}

miniValue2BValue(v : MiniValue) -> BValue {
	switch (v) {
		MiniInt(value, tv): BInt(value);
		MiniDouble(value): BDouble(value);
		MiniString(value): BString(value);
	}
}

miniExp2BReturn(e : MiniExp) -> BStatement {
	switch (e) {
		MiniValue(): BReturn(miniValue2BValue(e));
		MiniVar(name, tv): BReturn(miniExp2BExp(e));
		MiniLambda(args, body, tv): BReturn(miniExp2BExp(e));
		MiniCall(fn, args, tv): {
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ifte") {
						BIfStatement(miniExp2BExp(args[0]), miniExp2BReturn(args[1]), miniExp2BReturn(args[2]));
					} else if (fname == "__ift") {
						BIfStatement(miniExp2BExp(args[0]), miniExp2BReturn(args[1]), BReturnVoid());
					} else if (fname == ";") {
						n = length(args);
						if (n == 0) {
							BReturnVoid();
						} else if (n == 1) {
							miniExp2BReturn(args[0]);
						} else {
							BSequenceStatement(map(args, miniExp2BReturn));
						}
					} else {
						BReturn(miniExp2BExp(e))
					}
				}
				default: BReturn(miniExp2BExp(e))
			}
		}
		default: BComment("// Can not convert " + miniPretty(e) + " to statement yet");
	}
}

miniExp2BExp(e : MiniExp) -> BExp {
	error = \ -> {
		BComment("// Can not convert " + miniPretty(e) + " to exp");
	}
	switch (e) {
		MiniValue(): miniValue2BValue(e);
		MiniVar(name, tyvar): BVar(name);
		MiniLet(name, value, body, tyvar): BLet(name, miniExp2BExp(value), miniExp2BExp(body));
		MiniLambda(args, body, tyvar): {
			bbody = miniExp2BExp(body);
			BLambda(map(args, \a -> BFunArg(a)), bbody);
		}
		MiniCall(fn, args, tyvar): {
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ifte") {
						BIf(miniExp2BExp(args[0]), miniExp2BExp(args[1]), miniExp2BExp(args[2]));
					} else if (fname == "__ift") {
						BIf(miniExp2BExp(args[0]), miniExp2BExp(args[1]), BSequence([]));
					} else if (fname == ";") {
						n = length(args);
						if (n == 1) {
							miniExp2BExp(args[0]);
						} else {
							BSequence(map(args, miniExp2BExp));
						}
					} else {
						BCall(miniExp2BExp(fn), map(args, miniExp2BExp));
					}
				}
				default: BCall(miniExp2BExp(fn), map(args, miniExp2BExp));
			}
		}
		MiniTypeInt(bits): error();
		MiniTypeFunction(args, returnType): error();
		MiniTypeCall(id, typars): error();
	}
}
