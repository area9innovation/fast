import ds/tree;
import mini/backends/bprogram;
import text/blueprint;
import mini/backends/backend;
import mini/types/pretty;
import mini/types/builtin;

export {
	// Produce code for this call operator, respecting precedence
	produceBackendCall(backend : Backend, call : BCall, rec : (backend : Backend, BExp) -> string) -> string;
}

produceBackendCall(backend : Backend, call : BCall, rec : (backend : Backend, BExp) -> string) -> string {
	produceCodeWithPrec(backend, call, rec).first;
}

produceCodeWithPrec(backend : Backend, e : BExp, rec : (backend : Backend, BExp) -> string) -> Pair<string, int> {
	switch (e) {
		BCall(fn, args, type): {
			def = \ -> Pair(rec(backend, fn) + "(" + superglue(args, \a -> rec(backend, a), ", ") + ")", 1000);
			switch (fn) {
				BVar(name, __): {
					// OK, we have a named call. Look for a code gen proc for this that matches the type
					gens = getTreeArrayValue(backend.generators, name);
					match = filter(gens, \g -> g.type == fn.type || g.type == miniTypeVoid);
					if (length(match) == 1) {
						// We have a hit
						gen = match[0];
						evalBackExp(backend, args, rec, gen.product);
					} else if (gens != []) {
						backend.onError(0 /*call.pos*/, "Can not generate " + name + " for type " + mtype2string(fn.type));
						def();
					} else def();
				}
				default: def();
			}
		}
		default: Pair(rec(backend, e), 1000);
	}
}

evalBackExp(backend : Backend, args : [BExp], rec : (backend : Backend, BExp) -> string, e : BackExp) -> Pair<string, int> {
	switch (e) {
		BackText(text): Pair(text, 1000);
		BackBinOp(name, precedence, arg0, arg1): {
			left = evalBackExp(backend, args, rec, arg0);
			right = evalBackExp(backend, args, rec, arg1);

			wrap = \pair -> if (pair.second < precedence) "(" + pair.first + ")" else pair.first;

			Pair(wrap(left) + " " + name + " " + wrap(right), precedence);
		}
		BackArg(n): {
			arg = elementAt(args, n, BInt(0, miniTypeVoid));
			produceCodeWithPrec(backend, arg, rec)
		}
	}
}
