import ds/tree;
import mini/backends/bprogram;
import text/blueprint;
import mini/backends/backend;

export {
	// Produce code for this binary operator, with the given precedence
	produceBackendCall(backend : Backend, call : BCall, rec : (backend : Backend, BExp) -> string) -> string;
}

binOps = pairs2tree([
	Pair("||", 10),

	Pair("&&", 20),

	Pair("==", 30),
	Pair("!=", 30),

	Pair("<=", 30),
	Pair("<", 30),
	Pair(">=", 30),
	Pair(">", 30),

	Pair("+", 40),
	Pair("-", 40),

	Pair("*", 50),
	Pair("/", 50),
	Pair("%", 50),
]);

produceBackendCall(backend : Backend, call : BCall, rec : (backend : Backend, BExp) -> string) -> string {
	prec = getBPrecedence(call);
	def = \ -> {
		rec(backend, call.fn) + "(" + superglue(call.args, \a -> rec(backend, a), ", ") + ")"
	}
	if (prec != 1000) {
		op = getBBinOp(call);
		leftPrec = getBPrecedence(call.args[0]);
		rightPrec = getBPrecedence(call.args[1]);
		left = rec(backend, call.args[0]);
		right = rec(backend, call.args[1]);
		wrap = \p, t -> if (p < prec) "(" + t + ")" else t;
		wrap(leftPrec, left) + " " + op + " " + wrap(rightPrec, right);
	} else {
		// OK, unknown or non-binary, so use normal call
		def();
	}
}

getBBinOp(b : BExp) -> string {
	switch (b) {
		BCall(fn, args, __): {
			if (length(args) == 2) {
				switch (fn) {
					BVar(v, __): v;
					default: "";
				}
			} else "";
		}
		default: "";
	}
}

getBPrecedence(b : BExp) -> int {
	op = getBBinOp(b);
	lookupTreeDef(binOps, op, 1000);
}
