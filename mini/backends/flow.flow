import mini/backends/bprogram;
import mini/backends/operators;
import text/blueprint;

export {
	bprogram2flow(b : BProgram) -> string;

	bdeclaration2flow(b : BDeclaration) -> string;
}

bprogram2flow(b : BProgram) -> string {
	superglue(b.declarations, bdeclaration2flow, "\n");
}

bdeclaration2flow(b : BDeclaration) -> string {
	switch (b) {
		BFunction(name, args, body, type): {
			blueprint("
				%name%(%args%) {
					%body%
				} // %type%", [
				"name", name,
				"args", superglue(args, \fa -> fa.name, ", "),
				"body", bstatement2flow(body),
				"type", mtype2flow(type)
			]);
		}
		BGlobalVar(name, body, __): name + " = " + bexp2flow(body) + ";";
		BComment(comment): comment;
	}
}

bstatement2flow(b : BStatement) -> string {
	switch (b) {
		BIfStatement(cond, then, else_): {
			blueprint("
				if (%cond%) {
					%then%
				} else {
					%else%
				}", [
				"cond", bexp2flow(cond),
				"then", bstatement2flow(then),
				"else", bstatement2flow(else_),
			])
		}
		BLetStatement(name, value, body): {
			blueprint("
				%name% = %value%;
				%body%", [
					"name", name,
					"value", bexp2flow(value),
					"body", bstatement2flow(body),
			])
		}
		BReturnVoid(): "{}";
		BReturn(val): bexp2flow(val);
		BSequenceStatement(statements): {
			"{" + superglue(statements, bstatement2flow, ";\n") + "}";
		}
		BComment(comment): comment;
	}
}

bexp2flow(b : BExp) -> string {
	switch (b) {
		BValue(): bvalue2flow(b);
		BVar(name, type): name + " /* " + mtype2flow(type) + " */";
		BLet(name, value, body, type): {
			blueprint("
				%name% : %type% = %value%;
				%body%", [
					"name", name,
					"type", mtype2flow(type),
					"value", bexp2flow(value),
					"body", bexp2flow(body),
			])
		}
		BLambda(args, body, type): "\\" + superglue(args, \fa -> fa.name, ", ") + " /* " + mtype2flow(type) + " */ -> " + bexp2flow(body);
		BCall(fn, args, type): produceCallOrBinOp(b, bexp2flow) + " /* " + mtype2flow(type) + "*/";
		BIf(cond, then, else_, type): "if (" + bexp2flow(cond) + ") {" + bexp2flow(then) + "} else {" + bexp2flow(else_) + "}" + " /* " + mtype2flow(type) + "*/";
		BSequence(statements, type): {
			"{" + superglue(statements, bexp2flow, "; ") + "}" + " /* " + mtype2flow(type) + "*/";
		}
		BComment(comment): comment + "\n";
	}
}

bvalue2flow(b : BValue) -> string {
	switch (b) {
		BInt(value, type): if (type == MiniType2Int(1)) b2s(i2b(value)) else i2s(value);
		BDouble(value): d2s(value);
		BString(value): toString(value);
	}
}

mtype2flow(f : MiniType2) -> string {
	switch (f) {
		MiniType2Int(bits): if (bits == 0) "void" else if (bits == 1) "bool" else "int";
		MiniType2Function(args, returnType): "(" + superglue(args, mtype2flow, ", ") + ")->" + mtype2flow(returnType);
		MiniType2Call(id, typars): {
			if (id == "__ref") "ref " + mtype2flow(typars[0]) 
			else id + if (typars != []) "<" + superglue(typars, mtype2flow, ", ") + ">" else "";
		}
		MiniType2Var(id): "Î±" + i2s(id);
		MiniType2Par(id):  id;
		MiniType2Record(fields): "{" + superglue(fields, \fl -> fl.name + ":" + mtype2flow(fl.type), ", ") + "}";
	}
}
