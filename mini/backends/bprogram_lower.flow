import mini/exp/ast;
import mini/backends/bprogram;
import mini/backends/unfold;
import mini/backends/extract_globals;
import mini/exp/topological;
import mini/exp/pretty;
import mini/types/typeenv;
import mini/types/resolve;
import mini/types/builtin;

import ds/arrayutils;

export {
	miniAst2BProgram(ast : MiniAst) -> BProgram;

	// This lowers a declaration to typed, statement-based BDeclaration
	miniExp2BDeclaration(env : MiniTypeEnv, declid : string, e : MiniExp) -> BDeclaration;

	// TODO. We could use these instead, so we can do optimizations on BExp:

	// This lowers our program to BExp with types
	miniExp2BExp(env : MiniTypeEnv, e : MiniExp) -> BExp;

	// And then lower to statement-based
	bexp2BDeclaration(declid : string, b : BExp) -> BDeclaration;
}

miniAst2BProgram(ast : MiniAst) -> BProgram {
	// Here we effectively do DCE:
	// TODO: Also include all top-level vars with side-effects
	ids0 : Set<string> = getMiniDependencies(ast.idDependents, "main", true);
	ids = if (isEmptySet(ids0)) {
		println("Could not find main. Keep everything");
		buildSet(getTreeKeys(ast.declarations)) 
	} else ids0;

	order = topologicalMiniOrder(ast.idDependents, ids);

	// TODO: The extractBExpGlobals call can be done here for JS
	bexp = BExpProgram(
		filtermap(order, \id -> {
			mdecl = lookupTree(ast.typedDeclarations, id);
			mdecl ?? {
				Some(BGlobalVar(id, mdecl, bexpType(mdecl)))
			} : None(); // We will let backends complain: Some(BComment("// ERROR: Unknown id " + id))
		})
	);

	opt = extractBExpGlobals(bexp);

	BProgram(
		map(opt.declarations, \gv : BGlobalVar -> {
			bexp2BDeclaration(gv.name, gv.body)
		})
	);
}

bexp2BDeclaration(declid : string, b : BExp) -> BDeclaration {
	var = \ -> {
		BGlobalVar(declid, b, bexpType(b));
	}
	switch (b) {
		BValue(): var();
		BVar(__, __): var();
		BLet(__, __, __, __): var();
		BLambda(args, body, type): {
			hasTailcall = ref false;
			bbody = bexp2BStatement(declid, map(args, \a -> a.name), hasTailcall, true, body);
			BFunction(
				declid, args, bbody,
				^hasTailcall,
				type
			);
		}
		BCall(fn, args, type): {
			switch (fn) {
				BVar(name, __): {
					if (name == "__native") {
						bisIo = args[0];
						bnativeName = args[2];
						nativeName = switch (bnativeName) {
							BString(s): s;
							default: "";
						};
						ntype = bexpType(args[1]);
						fallback = if (length(args) > 3) {
							Some(bexp2BDeclaration(declid, args[3]))
						} else None();
						BNative(declid, bisIo == BInt(1, miniTypeInt),
							ntype,
							nativeName,
							fallback
						);
					} else var();
				}
				default: var();
			}
		}
		BIf(cond, then, else_, type): var();
		BSequence(exps, type): var();
		BComment(comment): var();
	}
}

bexp2BStatement(decl : string, fnargs : [string], hasTailcall : ref bool, tailcall : bool, tb : BExp) -> BStatement {
	b = unfoldBExp(tb);
	switch (b : BExp) {
		BValue(): BReturn(b);
		BVar(name, type): BReturn(b);
		BLet(name, value, body, type): {
			BLetStatement(name, value, bexp2BStatement(decl, fnargs, hasTailcall, tailcall, body));
		}
		BLambda(args, body, type): BReturn(b);
		BCall(fn, args, type): {
			if (tailcall) {
				switch (fn) {
					BVar(fname, __): if (fname == decl) {
						// Tail call
						// Filter out trivial arguments
						newArgs = foldi2(fnargs, [], [], \i, accnames, accvals, fnarg -> {
							val = args[i];
							def = \ -> {
								Pair(arrayPush(accnames, fnarg), arrayPush(accvals, val));
							}
							switch (val) {
								BVar(aname, __): {
									if (aname == fnarg) {
										// OK, no need for it
										Pair(accnames, accvals)
									} else {
										def();
									}
								}
								default: def();
							}
						});
						hasTailcall := true;
						BTailCall(decl, newArgs.first, newArgs.second);
					} else BReturn(b);
					default: BReturn(b);
				}
			} else BReturn(b);
		}
		BIf(cond, then, else_, type): {
			BIfStatement(cond, 
				bexp2BStatement(decl, fnargs, hasTailcall, tailcall, then), 
				bexp2BStatement(decl, fnargs, hasTailcall, tailcall, else_)
			);
		}
		BSequence(exps, type): {
			if (exps == []) BReturnVoid()
			else BSequenceStatement(mapi(exps, \i, e -> {
				bexp2BStatement(decl, fnargs, hasTailcall, tailcall && i == length(exps) - 1, e)
			}));
		} 
		BComment(comment): b;
	}
}

miniExp2BDeclaration(env : MiniTypeEnv, declid : string, e : MiniExp) -> BDeclaration {
	bexp2BDeclaration(declid, miniExp2BExp(env, e));
}

miniExp2BExp(env : MiniTypeEnv, e : MiniExp) -> BExp {
	error = \ -> {
		BComment("// Can not convert " + miniPretty(e) + " to exp");
	}
	switch (e) {
		MiniValue(): miniValue2BValue(env, e);
		MiniVar(name, tv): BVar(name, resolveMiniTypeVar(env, tv));
		MiniLet(name, value, body, tv): BLet(name, miniExp2BExp(env, value), miniExp2BExp(env, body), resolveMiniTypeVar(env, tv));
		MiniLambda(args, body, tv): {
			bbody = miniExp2BExp(env, body);
			BLambda(map(args, \a -> BFunArg(a)), bbody, resolveMiniTypeVar(env, tv));
		}
		MiniCall(fn, args, tv): {
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ifte") {
						BIf(miniExp2BExp(env, args[0]), miniExp2BExp(env, args[1]), miniExp2BExp(env, args[2]), resolveMiniTypeVar(env, tv));
					} else if (fname == "__ift") {
						BIf(miniExp2BExp(env, args[0]), miniExp2BExp(env, args[1]), BSequence([], resolveMiniTypeVar(env, tv)), resolveMiniTypeVar(env, tv));
					} else if (fname == ";") {
						n = length(args);
						if (n == 1) {
							miniExp2BExp(env, args[0]);
						} else {
							BSequence(map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
						}
					} else {
						BCall(miniExp2BExp(env, fn), map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
					}
				}
				default: BCall(miniExp2BExp(env, fn), map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
			}
		}
	}
}

miniValue2BValue(env : MiniTypeEnv, v : MiniValue) -> BValue {
	switch (v) {
		MiniInt(value, tv): BInt(value, resolveMiniTypeVar(env, tv));
		MiniDouble(value): BDouble(value);
		MiniString(value): BString(value);
	}
}

bexpType(b : BExp) -> MiniType {
	switch (b) {
		BInt(value, type): type;
		BDouble(value): miniTypeDouble;
		BString(value): miniTypeString;
		BVar(name, type): type;
		BLet(name, value, body, type): type;
		BLambda(args, body, type): type;
		BCall(fn, args, type): type;
		BIf(cond, then, else_, type): type;
		BSequence(exps, type): type;
		BComment(comment): miniTypeVoid;
	}
}
