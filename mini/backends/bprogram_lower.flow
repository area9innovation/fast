import mini/exp/ast;
import mini/backends/bprogram;
import mini/exp/topological;
import mini/exp/pretty;
import mini/types/typeenv;
import mini/types/resolve;
import mini/types/builtin;

export {
	// TODO: This should not need the environment, since this should only do the ordering
	miniAst2BProgram(env : MiniTypeEnv, ast : MiniAst) -> BProgram;

	miniExp2BDeclaration(env : MiniTypeEnv, declid : string, e : MiniExp) -> BDeclaration;
}

miniAst2BProgram(env : MiniTypeEnv, ast : MiniAst) -> BProgram {
	// Here we effectively do DCE:
	// TODO: Also include all top-level vars with side-effects
	ids0 : Set<string> = getMiniDependencies(ast.idDependents, "main", true);
	ids = if (isEmptySet(ids0)) {
		println("Could not find main. Keep everything");
		buildSet(getTreeKeys(ast.declarations)) 
	} else ids0;

	order = topologicalMiniOrder(ast.idDependents, ids);

	BProgram(
		filtermap(order, \id -> {
			mdecl = lookupTree(ast.typedDeclarations, id);
			mdecl ?? {
				Some(mdecl)
			} : None(); // We will let backends complain: Some(BComment("// ERROR: Unknown id " + id))
		})
	);
}

miniExp2BDeclaration(env : MiniTypeEnv, declid : string, e : MiniExp) -> BDeclaration {
	error = \ -> {
		BComment("// Can not convert " + miniPretty(e) + " for " + declid);
	}
	var = \tv -> {
		BGlobalVar(declid, miniExp2BExp(env, e), resolveMiniTypeVar(env, tv));
	}
	switch (e) {
		MiniInt(value, tv): var(tv);
		MiniDouble(value): BGlobalVar(declid, miniExp2BExp(env, e), MiniTypeCall("double", []));
		MiniString(value): BGlobalVar(declid, miniExp2BExp(env, e), MiniTypeCall("string", []));
		MiniVar(name, tv): var(tv);
		MiniLet(name, value, body, tv): var(tv);
		MiniLambda(args, body, tv): {
			bbody = miniExp2BReturn(env, body);

			// TODO: figure out if we have tail call or not
			tailCall = false;

			BFunction(
				declid, map(args, \a -> BFunArg(a)), bbody,
				tailCall,
				resolveMiniTypeVar(env, tv)
			);
		}
		MiniCall(fn, args, tv): {
			switch (fn) {
				MiniVar(name, __): {
					if (name == "__native") {
						bisIo = miniExp2BExp(env, args[0]);
						bnativeName = miniExp2BExp(env, args[2]);
						nativeName = switch (bnativeName) {
							BString(s): s;
							default: "";
						};
						type = miniExp2MiniType(args[1]);
						BNative(declid, bisIo == BInt(1, MiniTypeInt(32)),
							type,
							nativeName	
						);
					} else var(tv);
					// TODO: If it is __type, we should convert it
				}
				default: var(tv);
			}
		}
	}
}

miniValue2BValue(env : MiniTypeEnv, v : MiniValue) -> BValue {
	switch (v) {
		MiniInt(value, tv): BInt(value, resolveMiniTypeVar(env, tv));
		MiniDouble(value): BDouble(value);
		MiniString(value): BString(value);
	}
}

miniExp2BReturn(env : MiniTypeEnv, e : MiniExp) -> BStatement {
	switch (e) {
		MiniValue(): BReturn(miniValue2BValue(env, e));
		MiniVar(name, tv): BReturn(miniExp2BExp(env, e));
		MiniLambda(args, body, tv): BReturn(miniExp2BExp(env, e));
		MiniCall(fn, args, tv): {
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ifte") {
						BIfStatement(miniExp2BExp(env, args[0]), miniExp2BReturn(env, args[1]), miniExp2BReturn(env, args[2]));
					} else if (fname == "__ift") {
						BIfStatement(miniExp2BExp(env, args[0]), miniExp2BReturn(env, args[1]), BReturnVoid());
					} else if (fname == ";") {
						seq = flattenSequence(map(args, \a -> miniExp2BReturn(env, a)));
						BSequenceStatement(seq);
					} else {
						BReturn(miniExp2BExp(env, e))
					}
				}
				default: BReturn(miniExp2BExp(env, e))
			}
		}
		MiniLet(name, value, body, tyvar): {
			BLetStatement(name, miniExp2BExp(env, value), miniExp2BReturn(env, body));
		}
	}
}

flattenSequence(seq : [BStatement]) -> [BStatement] {
	fold(seq, [], \acc, s -> {
		switch (s) {
			BSequenceStatement(ss): concat(acc, flattenSequence(ss));
			default: arrayPush(acc, s);
		}
	})
}

miniExp2BExp(env : MiniTypeEnv, e : MiniExp) -> BExp {
	error = \ -> {
		BComment("// Can not convert " + miniPretty(e) + " to exp");
	}
	switch (e) {
		MiniValue(): miniValue2BValue(env, e);
		MiniVar(name, tv): BVar(name, resolveMiniTypeVar(env, tv));
		MiniLet(name, value, body, tv): BLet(name, miniExp2BExp(env, value), miniExp2BExp(env, body), resolveMiniTypeVar(env, tv));
		MiniLambda(args, body, tv): {
			bbody = miniExp2BExp(env, body);
			BLambda(map(args, \a -> BFunArg(a)), bbody, resolveMiniTypeVar(env, tv));
		}
		MiniCall(fn, args, tv): {
			switch (fn) {
				MiniVar(fname, __): {
					if (fname == "__ifte") {
						BIf(miniExp2BExp(env, args[0]), miniExp2BExp(env, args[1]), miniExp2BExp(env, args[2]), resolveMiniTypeVar(env, tv));
					} else if (fname == "__ift") {
						BIf(miniExp2BExp(env, args[0]), miniExp2BExp(env, args[1]), BSequence([], resolveMiniTypeVar(env, tv)), resolveMiniTypeVar(env, tv));
					} else if (fname == ";") {
						n = length(args);
						if (n == 1) {
							miniExp2BExp(env, args[0]);
						} else {
							BSequence(map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
						}
					} else if (fname == "__cast") {
						// Some specific conversions are converted to native calls
						cargs = map(args, \a -> miniExp2BExp(env, a));

						// TODO: Move this to Forth?

						from = bexpType(cargs[0]);
						to = bexpType(cargs[1]);
						if (from == miniTypeInt && to == miniTypeString) {
							// i2s
							// TODO: We have to add a dependency!
							BCall(BVar("__i2s", from), [cargs[0]], to)
						} else if (from == miniTypeInt && to == miniTypeDouble) {
							// i2d
							// TODO: We have to add a dependency!
							BCall(BVar("__i2d", from), [cargs[0]], to)
						} else if (from == miniTypeDouble && to == miniTypeString) {
							// d2s
							// TODO: We have to add a dependency!
							BCall(BVar("__d2s", from), [cargs[0]], to)
						} else if (from == miniTypeDouble && to == miniTypeInt) {
							// d2i
							// TODO: We have to add a dependency!
							BCall(BVar("__d2i", from), [cargs[0]], to)
						} else {
							BCall(miniExp2BExp(env, fn), cargs, resolveMiniTypeVar(env, tv));
						}
					} else {
						BCall(miniExp2BExp(env, fn), map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
					}
				}
				default: BCall(miniExp2BExp(env, fn), map(args, \a -> miniExp2BExp(env, a)), resolveMiniTypeVar(env, tv));
			}
		}
	}
}

miniExp2MiniType(e : MiniExp) -> MiniType {
	switch (e) {
		MiniInt(value, tyvar): MiniTypeVar(tyvar);
		MiniDouble(value): miniTypeDouble;
		MiniString(value): miniTypeString;
		MiniVar(name, tyvar): MiniTypeVar(tyvar);
		MiniLet(name, value, body, tyvar): MiniTypeVar(tyvar);
		MiniLambda(args, body, tyvar): MiniTypeVar(tyvar);
		MiniCall(fn, args, tyvar): MiniTypeVar(tyvar);
	}
}

bexpType(b : BExp) -> MiniType {
	switch (b) {
		BInt(value, type): type;
		BDouble(value): miniTypeDouble;
		BString(value): miniTypeString;
		BVar(name, type): type;
		BLet(name, value, body, type): type;
		BLambda(args, body, type): type;
		BCall(fn, args, type): type;
		BIf(cond, then, else_, type): type;
		BSequence(exps, type): type;
		BComment(comment): miniTypeVoid;
	}
}
