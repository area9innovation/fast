import mini/backends/bprogram;
import mini/backends/back_eval;
import mini/types/builtin;
import text/blueprint;

export {
	bprogram2js(b : BProgram) -> string;
}

bprogram2js(b : BProgram) -> string {
	backend = jsBackend();
	body = superglue(b.declarations, \d : BDeclaration -> bdeclaration2js(backend, d), "\n");

	getBackendRequirements(backend)
	+ body
	+ "\nmain()";
}

bdeclaration2js(backend : Backend, b : BDeclaration) -> string {
	switch (b) {
		BFunction(name, args, body, __): {
			blueprint("
				function %name%(%args%) {
					%body%
				}", [
				"name", name,
				"args", superglue(args, \fa -> fa.name, ", "),
				"body", bstatement2js(backend, body, true)
			]);
		}
		BGlobalVar(name, body, __): "var " + name + " = " + bexp2js(backend, body) + ";";
		BNative(name, isIo, type, nativeName): {
			generated = produceBackendNative(backend, nativeName);
			"var " + name + " = " + (if (generated == "") {
				backend.onError(0, "native " + nativeName + " not implemented");
				nativeName
			} else generated) + ";"
		}
		BStruct(name, type): {
			blueprint("
				class %name% {
					%type%
				}", ["name", name, "type", mtype2string(type)]
			)
		}
		BComment(comment): comment;
	}
}

bstatement2js(backend : Backend, b : BStatement, withReturn : bool) -> string {
	switch (b) {
		BIfStatement(cond, then, else_): {
			blueprint("
				if (%cond%) {
					%then%
				} else {
					%else%
				}", [
				"cond", bexp2js(backend, cond),
				"then", bstatement2js(backend, then, withReturn),
				"else", bstatement2js(backend, else_, withReturn),
			])
		}
		BLetStatement(name, value, body): {
			blueprint("
				var %name% = %value%;
				%body%", [
					"name", name,
					"value", bexp2js(backend, value),
					"body", bstatement2js(backend, body, withReturn),
			])
		}
		BReturnVoid(): if (withReturn) "return;" else "";
		BReturn(val): (if (withReturn) "return " else "") + bexp2js(backend, val) + ";";
		BSequenceStatement(statements): {
			"{" + supergluei(statements, \i, stat -> {
				bstatement2js(backend, stat, withReturn && i == length(statements) - 1)
			}, "\n") + "}";
		}
		BComment(comment): comment;
	}
}

bexp2js(backend : Backend, b : BExp) -> string {
	switch (b) {
		BValue(): bvalue2js(b);
		BVar(name, __): name;
		BLet(name, value, body, __): {
			blueprint("
				function() {
				var %name% = %value%;
				%body%
				}()", [
					"name", name,
					"value", bexp2js(backend, value),
					"body", bstatement2js(backend, BReturn(body), true),
			])
		}
		BLambda(args, body, __): "function(" 
			+ superglue(args, \fa -> fa.name, ", ") + ") {" 
			+ bstatement2js(backend, BReturn(body), true)
			+ "}"
		;
		BCall(fn, args, restype): {
			produceBackendCall(backend, b, bexp2js);
		}
		BIf(cond, then, else_, __): "(" + bexp2js(backend, cond) + " ? " + bexp2js(backend, then) + " : " + bexp2js(backend, else_) + ")";
		BSequence(statements, __): {
			"(" + superglue(statements, \s -> bexp2js(backend, s), ", ") + ")";
		}
		BComment(comment): comment + "\n";
	}
}

bvalue2js(b : BValue) -> string {
	switch (b) {
		BInt(value, type): if (type == MiniType2Int(1)) b2s(i2b(value)) else i2s(value);
		BDouble(value): d2s(value);
		BString(value): toString(value);
	}
}

jsBackend() -> Backend {
	comparison = \name, target, prec -> {
		[
			BackGen(name, MiniType2Function([miniTypeBool, miniTypeBool], miniTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, MiniType2Function([miniTypeInt, miniTypeInt], miniTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, MiniType2Function([miniTypeDouble, miniTypeDouble], miniTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			BackGen(name, MiniType2Function([miniTypeString, miniTypeString], miniTypeBool), BackBinOp(target, prec, BackArg(0), BackArg(1))),
			// TODO: We need something fancy for other types here
		]
	}

	makeBackend("js", [
			// Keywords
			"abstract", "arguments",  "await",        "boolean",
			"break",    "byte",       "case",         "catch",
			"char",     "class",      "const",        "continue",
			"debugger", "default",    "delete",       "do",
			"double",   "else",       "enum",         "eval",
			"export",   "extends",    "false",        "final",
			"finally",  "float",      "for",          "function",
			"goto",     "if",         "implements",   "import",
			"in",       "instanceof", "int",          "interface",
			"let",      "long",       "native",       "new",
			"null",     "package",    "private",      "protected",
			"public",   "return",     "short",        "static",
			"super",    "switch",     "synchronized", "this",
			"throw",    "throws",     "transient",    "true",
			"try",      "typeof",     "var",          "void",
			"volatile", "while",      "with",         "yield",
			"R_" // Used by runtime for references
		], 

		//
		// Inlined operators
		//
		concatA([

		// In JS, there is ? here for if

		[
			BackGen("||", miniTypeBool, BackBinOp("||", 10, BackArg(0), BackArg(1))),
			BackGen("&&", miniTypeBool, BackBinOp("&&", 20, BackArg(0), BackArg(1))),
		],

		//	BackBinOp("|", 25, BackArg(0), BackArg(1)),
		//	BackBinOp("^", 26, BackArg(0), BackArg(1)),
		// 	BackBinOp("^", 27, BackArg(0), BackArg(1)),

		comparison("==", "===", 30),
		comparison("!=", "!==", 30),

		comparison("<=", "<=", 35),
		comparison("<", "<", 35),
		comparison(">=", ">=", 35),
		comparison(">", ">", 35),

		// In JS, we have bitshifts here <<, >>, >>>

		[
			BackGen("+", miniTypeInt, BackBinOp("|", 25, BackBinOp("+", 40, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("+", miniTypeDouble, BackBinOp("+", 40, BackArg(0), BackArg(1))),
			BackGen("+", miniTypeString, BackBinOp("+", 40, BackArg(0), BackArg(1))),

			BackGen("-", miniTypeInt, BackBinOp("|", 25, BackBinOp("-", 40, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("-", miniTypeDouble, BackBinOp("-", 40, BackArg(0), BackArg(1))),

			BackGen("*", miniTypeInt, 
				BackRequire(
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
					BackText("if (!Math.imul) Math.imul = function(opA, opB) {var result = (opA & 0x003fffff) * opB;if (opA & 0xffc00000) result += (opA & 0xffc00000) * opB |0;return result |0;};"),
					BackCall("Math.imul", [BackArg(0), BackArg(1)])
				)
			),
			BackGen("*", miniTypeDouble, BackBinOp("*", 50, BackArg(0), BackArg(1))),

			BackGen("/", miniTypeInt, BackBinOp("|", 25, BackBinOp("/", 50, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("/", miniTypeDouble, BackBinOp("/", 50, BackArg(0), BackArg(1))),

			BackGen("%", miniTypeInt, BackBinOp("|", 25, BackBinOp("%", 50, BackArg(0), BackArg(1)), BackText("0"))),
			BackGen("%", miniTypeDouble, BackBinOp("%", 50, BackArg(0), BackArg(1))),

	// In JS, there is ** for exponentiation here

			BackGen("__neg", miniTypeInt, BackBinOp("|", 25, BackPreOp("-", 60, BackArg(0)), BackText("0"))),
			BackGen("__neg", miniTypeDouble, BackPreOp("-", 60, BackArg(0))),

			BackGen("!", miniTypeVoid, BackPreOp("!", 60, BackArg(0))),


			// Cast and type is ignored
			BackGen("__cast", miniTypeVoid, BackArg(0)),
			BackGen(":", miniTypeVoid, BackArg(0)),

			BackGen("__ref", miniTypeVoid, 
				BackRequire(
					// Alternative: class R_ {constructor(v) { this.__v = v; } }
					BackText("function R_(v){this.v=v}"),
					BackCall("new R_", [BackArg(0)])
				)
			),
			BackGen("__deref", miniTypeVoid, BackPostOp(".v", 60, BackArg(0))),
			BackGen(":=", miniTypeVoid, BackBinOp(".v=", 70, BackArg(0), BackArg(1))),

			BackGen("__emptyarray", miniTypeVoid, BackText("[]")),
			BackGen("[", miniTypeVoid, BackConcat([BackText("["), BackArg(0), BackText("]")])),
			BackGen(",", miniTypeVoid, BackBinOp(",", 80, BackArg(0), BackArg(1))),
			BackGen("__index", miniTypeVoid, BackConcat([BackBinOp("[", 80, BackArg(0), BackArg(1)), BackText("]")])),

			BackGen(".", miniTypeVoid, BackBinOp(".", 60, BackArg(0), BackUnquote(BackArg(1)))),

			BackGen("__construct0", miniTypeVoid, BackConcat([BackText("{_id:"), BackArg(0), BackText("}")])),
			BackGen("__construct1", miniTypeVoid, BackConcat([BackText("{_id:"), BackArg(0), 
					BackText(","), BackArg(1), BackText(":"), BackUnquote(BackArg(1)), 
				BackText("}")])),
			BackGen("__construct2", miniTypeVoid, BackConcat([BackText("{_id:"), BackArg(0), 
					BackText(","), BackArg(1), BackText(":"), BackUnquote(BackArg(1)), 
					BackText(","), BackArg(2), BackText(":"), BackUnquote(BackArg(2)), 
				BackText("}")])),
			BackGen("__construct3", miniTypeVoid, BackConcat([BackText("{_id:"), BackArg(0), 
					BackText(","), BackArg(1), BackText(":"), BackUnquote(BackArg(1)), 
					BackText(","), BackArg(2), BackText(":"), BackUnquote(BackArg(2)), 
					BackText(","), BackArg(3), BackText(":"), BackUnquote(BackArg(3)), 
				BackText("}")])),

			// Used in th union
			BackGen("__structname", miniTypeVoid, BackBinOp(".", 60, BackArg(0), BackText("_id"))),

			// Inlined natives
			BackGen("Native.println", miniTypeVoid, BackText("console.log")),
			BackGen("Native.fold", miniTypeVoid, BackText("function(values,init,fn){for(var i=0;i<values.length;i++){init=fn(init,values[i]);}return init;}")),
			BackGen("Native.isSameStructType", miniTypeVoid, BackText("function(a,b){return Object.prototype.hasOwnProperty.call(a,'_id')&&Object.prototype.hasOwnProperty.call(b,'_id')&&a._id==b._id}")),

			BackGen("Native.quit", miniTypeVoid, 
				BackIfDef("browser",
					BackText("function(c) {window.open('','_top').close();}"),
					BackText("function(c) {}")
				)
			),
		]
		]),
	);
}
