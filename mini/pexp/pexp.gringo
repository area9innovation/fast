flow = '\uFEFF'? ws toplevels;

toplevels = $"list" toplevel $"cons" (toplevel $"cons")* optsemi;

toplevel = import | export | forbid | native | union | global | functionOrStruct;
	semi = #";" ws;
	optsemi = (";" ws)?;

import = "import" s $path ws semi $"import";
export = "export" ws "{" ws toplevels "}" ws $"export"; 
forbid = "forbid" s $path ws semi $"forbid";
	path = bid ('/' bid)*;


native = "native" s id ':' ws $"list" ("io" ws $$"io" $"cons")? type '=' ws $nativename ws semi $"native";
	nativename = bid ('.' bid)*;

union = typename "::=" ws typenames semi $"union";

	typenames = $"list" typename $"cons" ("," ws typename $"cons")* ("," ws)? | $"list";

global = id "=" ws brace optsemi $"global" 
		| id "=" ws exp semi $"global" 
		| id ":" ws type "=" ws brace optsemi $"global_typed"
		| id ":" ws type "=" ws exp semi $"global_typed";

functionOrStruct = 
	// Forward declaration
	  id fntype brace optsemi $"fndef_typed" 
	| id fntypeauto brace optsemi $"fndef_typed" 
	| id fntype semi $"typedef"
	| id '(' ws structargs ')' ws semi $"structdef" // This is a struct!

	// When we only have names for the arguments

	// Forward type declarations
	| id ':' ws type semi $"typedef"
	// Struct
	| id ':' ws '(' ws structargs ')' ws semi $"structdef"
	;

	// listof(structarg, ",")
	structargs = $"list" structarg $"cons" ("," ws structarg $"cons")* ("," ws)? | $"list";
	structarg = $"list" ("mutable" !letterOrDigit ws $$"mutable" $"cons")? id ':' ws type $"structarg";

expsemi = $"list" exp $"cons" (#";" ws exp $"cons")* (";" ws)? $"sequence"
	| $"list" $"sequence"; 

exp = 
	(id "=" ws exp #";" ws exp $"let"
		| id ":" ws type "=" ws exp #";" ws exp $"let_typed"
	)
	|> exp ":=" ws exp $":="
	|> exp < ("|>" ws exp $"|>")*
	|> exp "||" ws exp $"||"
	|> exp "&&" ws exp $"&&"
	|> exp "==" ws exp $"==" | exp "!=" ws exp $"!="
	|> exp ("<=" ws exp $"<=" | "<" ws exp $"<" | ">=" ws exp $">=" | ">" ws exp $">")
	|> exp < ("+" ws exp $"+" | "-" ws exp ws $"-")*
	|> exp ("*" ws exp $"*" | "/" ws exp $"/" | "%" ws exp $"%")*

	// To ensure that ?? does not consider the : as part of the type
	|> exp (":" ws type $":")+

	|> exp "??" ws <exp ":" ws exp $"maybe"

	|> (
		'!' ws exp $"not"
		| "-" ws exp $"negate"
		| lambda
		| exp (
			"(" ws exps ")" ws $"call"
			| with
			| "." ws id "::=" ws exp $"::="
			| "." ws id $"dot"
			| "[" ws exp "]" ws $"index"
		)*
	)

	|> '^' ws exp $"deref"

	|> (
		"if" !letterOrDigit ws "(" ws exp ")" ws exp "else" ws exp $"ifelse" 
		| "if" !letterOrDigit ws "(" ws exp ")" ws exp $"if"
		| "(" ws exp ")" ws 
		| "ref" !letterOrDigit ws exp $"ref"
		| switch
		| "cast" !letterOrDigit ws '(' ws exp "->" ws type ')' ws $"cast"
		| brace
		| "true" !letterOrDigit ws $"true"
		| "false" !letterOrDigit ws $"false"
		| id $"var"
		| '"#inc' "lude" s $path '"' ws $"stringinclude"
		| string ws $"unescape"
		| "0x" $(hexdigit+) ws $"hex"
		| $double $"s2d"
		| $int ws $"s2i"
		| "[" ws exps "]" ws $"array"
	);

with = '(' ws exp "with" s fields ')' ws $"with";
	fields = $"list" fieldassign $"cons" ("," ws fieldassign $"cons")*  ("," ws)? | $"list";
		fieldassign = id '=' ws exp $"fieldassign";

switch = "switch" !letterOrDigit ws 
		'(' ws exp ')' ws 
		'{' ws cases #'}' ws $"switch";

	cases = $"list" defaultOrNamedCase $"cons" (defaultOrNamedCase $"cons")*
			| $"list";

	defaultOrNamedCase = 
		"default" !letterOrDigit ws ':' ws exp (';' ws)? $"default" 
		| id '(' ws names ')' ws ':' ws exp (';' ws)?  $"case";

	names = $"list" id $"cons" ("," ws id $"cons")* | $"list";

brace = "{" ws expsemi "}" ws;

lambda = backslash ws lambdaargs "->" ws exp "" $"lambda"; // The "" makes right-recursion disappear
	lambdaargs = $"list" lambdaarg $"cons" ("," ws lambdaarg $"cons")* ("," ws)? 
		| $"list";

	lambdaarg = id ":" ws type $":" |
		id $"var" $"auto" $":";	// We add auto automatically

exps = $"list" exp $"cons" ("," ws exp $"cons")* ("," ws)? 
	| $"list";

//
// Types
//

type = 	
		"bool" !letterOrDigit ws $"bool"
		| "int" !letterOrDigit ws $"int"
		| "double" !letterOrDigit ws $"double"
		| "string" !letterOrDigit ws $"string"
		| "flow" !letterOrDigit ws $"flow"
		| "void" !letterOrDigit ws $"void"
		| "native" !letterOrDigit ws $"nativetype"
		| "ref" !letterOrDigit ws type $"reftype"

		| fntype
		| typename

		| "[" ws type "]" ws $"arraytype"

		| $("?"+) ws $"polytype"
	;

fntype = "(" ws argtypes ")" ws "->" ws type $"fntype";
fntypeauto = "(" ws argtypes ")" ws $"auto" $"fntype";

	// listof(type, ",")
	argtypes = $"list" argtype $"cons" ("," ws argtype $"cons")* ("," ws)? 
		| $"list";

	argtype = id ":" ws type $"argtype" | type;

typename = id typars $"typename";

	typars = "<" ws types ">" ws
		| $"list";

	// listof(type, ",")
	types = $"list" type $"cons" ("," ws type $"cons")* ("," ws)? 
		| $"list";

//
// Lexing
//

hexdigit = '0'-'9'
	| 'a'-'f'
	| 'A'-'F';

id = $bid ws;

bid = ('a'-'z' | 'A'-'Z' | '_') (letterOrDigit)*;

letterOrDigit = 'a'-'z'
	| 'A'-'Z'
	| '_'
	| '0'-'9';

string = $('"' onechar_* '"') ws;

onechar_ = backslash "u" hexdigit hexdigit hexdigit hexdigit
	| backslash "X" hexdigit hexdigit hexdigit hexdigit
	| backslash "x" hexdigit hexdigit
	| backslash escapedchar_
	| !'"' !backslash anychar;

escapedchar_ = backslash | '"' | "n" | "t" | "r";
backslash = '\';
anychar = '0x0000'-'0xffff';

double = int '.' int? | '.' int;

int = '0'-'9'+;


ws = s*;
s = cs+;

cs = " " | "\t" | "\n" | "//" (!"\n" anychar)* "\n" | "/*" (!"*/" anychar)* "*/";

flow
