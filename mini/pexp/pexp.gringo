flow = '\uFEFF'? ws $$pos toplevels $"module" $"setpos" lastLineComment?;

toplevels = $"list" toplevel $"cons" (toplevel $"cons")* optsemi | $"list";

toplevel = import | export | forbid | native | union | global | functionOrStruct;
	semi = #";" ws;
	optsemi = (";" ws)?;

import = "import" s pathpos ws semi $"import";
export = "export" ws $$pos "{" ws toplevels "}" ws $"export" $"setpos";
forbid = "forbid" s pathpos ws semi $"forbid";
	pathpos = $$pos $path $"setpos";
	path = bid ('/' bid)*;

native = "native" s idpos ':' ws $"list" ("io" ws $$"io" $"cons")? type '=' ws $nativename ws semi $"native";
	nativename = bid ('.' bid)*;

union = typename "::=" ws typenames semi $"union";
	typenames = $"list" typename $"cons" ("," ws typename $"cons")* ("," ws)? | $"list";

global = idpos "=" ws brace optsemi $"global"
		| idpos "=" ws exp semi $"global" 
		| idpos ":" ws type "=" ws brace optsemi $"global_typed"
		| idpos ":" ws type "=" ws exp semi $"global_typed";

functionOrStruct = 
	// Forward declaration
	  idpos fntype brace optsemi $"fndef_typed" 
	| idpos fntype exp semi $"fndef_typed"
	| idpos fntype semi $"typedef"
	| idpos fntypeauto brace optsemi $"fndef_typed" 
	| idpos fntypeauto exp semi $"fndef_typed" 
	| idpos '(' ws structargs ')' ws semi $"structdef" // This is a struct!

	// Forward type declarations
	| idpos ':' ws type semi $"typedef"
	// Struct
	| idpos ':' ws '(' ws structargs ')' ws semi $"structdef"
	;

	// listof(structarg, ",")
	structargs = $"list" structarg $"cons" ("," ws structarg $"cons")* ("," ws)? | $"list";
	structarg = $"list" ("mutable" !letterOrDigit ws $$"mutable" $"cons")? id ':' ws type $"structarg";

exp = 
	// These optsemi should really be semi, but we have too much legacy without
	(idpos "=" ws exp optsemi (exp | $"void") $"let"	// The else is error recovery for the common case of missing a body
		| idpos ":" ws type "=" ws exp optsemi exp $"let_typed"
	)
	|> exp ":=" ws exp $":="
	|> exp < ("|>" ws exp $"|>")*
	|> exp "||" ws exp $"||"
	|> exp "&&" ws exp $"&&"
	|> exp "==" ws exp $"==" | exp "!=" ws exp $"!="
	|> exp ("<=" ws exp $"<=" | "<" ws exp $"<" | ">=" ws exp $">=" | ">" ws exp $">")
	|> exp < ("+" ws exp $"+" | "-" ws exp $"-")*
	|> exp ("*" ws exp $"*" | "/" ws exp $"/" | "%" ws exp $"%")*

	// To ensure that ?? does not consider the : as part of the type
	|> exp (":" ws type $":")+

	|> exp "??" ws <exp ":" ws exp $"maybe"

	|> (
		'!' ws exp $"not"
		| "-" ws exp $"negate"
		| lambda
		| exp (
			"(" ws exps ")" ws $"call"
			| with
			| "." ws idpos "::=" ws exp $"::="
			| "." ws idpos $"dot"
			| "[" ws exp "]" ws $"index"
		)*
	)

	|> '^' ws exp $"deref"

	|> (
		"if" !letterOrDigit ws "(" ws exp ")" ws exp "else" ws exp $"ifelse" 
		| "if" !letterOrDigit ws "(" ws exp ")" ws exp $"if"
		| "(" ws exp ")" ws 
		| "ref" !letterOrDigit ws exp $"ref"
		| switch
		| "cast" !letterOrDigit ws '(' ws exp "->" ws type ')' ws $"cast"
		| brace
		| "true" !letterOrDigit ws $"true"
		| "false" !letterOrDigit ws $"false"
		| id $"var"
		| '"#inc' "lude" s pathpos '"' ws $"stringinclude"
		| string ws $"unescape"
		| "0x" $(hexdigit+) ws $"hex"
		| $double ws $"s2d"
		| $int ws $"s2i"
		| "[" ws exps "]" ws $"array"
	);

with = '(' ws exp "with" s fields ')' ws $"with";
	fields = $"list" fieldassign $"cons" ("," ws fieldassign $"cons")*  ("," ws)? | $"list";
		fieldassign = id '=' ws exp $"fieldassign";

switch = "switch" !letterOrDigit ws 
		'(' ws exp ')' ws 
		'{' ws cases #'}' ws $"switch";

	cases = $"list" defaultOrNamedCase $"cons" (defaultOrNamedCase $"cons")*
			| $"list";

	defaultOrNamedCase = 
		"default" !letterOrDigit ws ':' ws exp (';' ws)? $"default" 
		| id '(' ws names ')' ws ':' ws exp (';' ws)?  $"case";

	names = $"list" id $"cons" ("," ws id $"cons")* ("," ws)? | $"list";

brace = "{" ws expsemi "}" ws $"sequence";
	// The first optsemi here is to have backwards compatibility. Really, it should be semi
	expsemi = $"list" exp $"cons" (optsemi exp $"cons")* optsemi
		| $"list";

lambda = backslash ws lambdaargs "->" ws exp "" $"lambda"; // The "" makes right-recursion disappear
	lambdaargs = $"list" lambdaarg $"cons" ("," ws lambdaarg $"cons")* ("," ws)? 
		| $"list";

	lambdaarg = id ":" ws type $":" |
		id $"var" $"auto" $":";	// We add auto automatically

exps = $"list" exp $"cons" ("," ws exp $"cons")* ("," ws)? 
	| $"list";


idpos = $$pos id $"setpos";

//
// Types
//

type = 	
	"bool" !letterOrDigit ws $"bool"
	| "int" !letterOrDigit ws $"int"
	| "double" !letterOrDigit ws $"double"
	| "string" !letterOrDigit ws $"string"
	| "flow" !letterOrDigit ws $"flow"
	| "void" !letterOrDigit ws $"void"
	| "native" !letterOrDigit ws $"nativetype"
	| "ref" !letterOrDigit ws type $"reftype"
	| fntype
	| typename
	| "[" ws type "]" ws $"arraytype"
	| $("?"+) ws $"polytype"
	;

fntype = "(" ws argtypes ")" ws "->" ws type $"fntype";
fntypeauto = "(" ws argtypes ")" ws $"auto" $"fntype";
	argtypes = $"list" argtype $"cons" ("," ws argtype $"cons")* ("," ws)? | $"list";
	argtype = id ":" ws type $"argtype" | type;

typename = id typars $"typename";
	typars = "<" ws types ">" ws | $"list";

	types = $"list" type $"cons" ("," ws type $"cons")* ("," ws)? 
		| $"list";

//
// Lexing
//

hexdigit = '0'-'9'
	| 'a'-'f'
	| 'A'-'F';

id = $bid ws;

bid = ('a'-'z' | 'A'-'Z' | '_') (letterOrDigit)*;

letterOrDigit = 'a'-'z'
	| 'A'-'Z'
	| '_'
	| '0'-'9';

string = $('"' onechar_* '"') ws;

onechar_ = backslash "u" hexdigit hexdigit hexdigit hexdigit
	| backslash "X" hexdigit hexdigit hexdigit hexdigit
	| backslash "x" hexdigit hexdigit
	| backslash escapedchar_
	| !'"' !backslash anychar;

escapedchar_ = backslash | '"' | "n" | "t" | "r";
backslash = '\';
anychar = '0x0000'-'0xffff';

double = int '.' int? | '.' int;
int = '0'-'9'+;

ws = s*;
s = cs+;

cs = " " | "\t" | "\n" | "//" (!"\n" anychar)* "\n" | "/*" (!"*/" anychar)* "*/";

lastLineComment = "//" (!"\n" anychar)*;

flow
