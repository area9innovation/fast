import mini/pexp/pexp;
import mini/pexp/values;
import mini/pexp/pexp_parser;
import text/gringo/gringo_interpreter;
import text/deserialize_string;

export {
	parsePExp(program : string, onError : (string) -> void) -> PExp;
}

parsePExp(program : string, onError : (string) -> void) -> PExp {
	if (false) {
		gringoTypedParse(program, pexpTypeAction(onError), parse_flow, PSequence([]), onError);
	} else {
		gterm = prepareGringoParser("#include mini/pexp/pexp.gringo", onError);
		if (gterm != GEpsilon()) {
			// OK, parse the program
			ops = pexpTypeOps();
			gringoParseWithActionCheck(program, ops, pexpTypeAction(onError), gterm, PSequence([]), onError);
		} else {
			onError("Could not understand grammar");
			PSequence([]);
		}
	}
}

// This defines the semantic actions used in the grammar
pexpTypeAction(onError : (string) -> void) -> GringoAction<List<PExp>> {
	gringoTypedAction(
		// Make a string
		\s : string -> PString(s),
		// Extract a string from a value (typically a string)
		getPString,
		// Construct the basic value
		\b -> PBool(b), // We do not have bools, so use ints
		\i -> PInt(s2i(i)),
		\d -> PDouble(s2d(d)), // We do not have doubles, so just use ints
		// Construct an empty array
		\ -> PList(makeList()),
		// Append an element to an array
		\h, t -> {
			switch (t) {
				PList(es): PList(Cons(h, es));
				default: t;
			}
		},
		pexpTypeOps()
	);
}

pexpTypeOps() -> GringoTypedOperators<PExp> {
	un = \op -> Pair(op, \l -> PCallOp(op, [l]));
	bin = \op -> Pair(op, \l, r -> PCallOp(op, [l, r]));
	tri = \op -> Pair(op, \l, m, r -> PCallOp(op, [l, m, r]));
	mktype = \t -> PTypeName(t, []);
	GringoTypedOperators(
		// Nullary operators
		pairs2tree([
			Pair("void", \ -> mktype("void")),
			Pair("bool", \ -> mktype("bool")),
			Pair("int", \ -> mktype("int")),
			Pair("double", \ -> mktype("double")),
			Pair("string", \ -> mktype("string")),
			Pair("flow", \ -> mktype("flow")),
			Pair("auto", \ -> mktype("auto")),
			Pair("nativetype", \ -> mktype("native")),
		]),
		// Unary operators
		pairs2tree([
			un("negate"),
			un("not"),
			un("deref"),

			Pair("unescape", \e -> {
				switch (e) {
					PString(t): PString(deserializeString(t).first);
					default: e;
				}
			}),
			Pair("var", \e -> {
				PVar(getPString(e))
			}),
			Pair("sequence", \e -> {
				PSequence(getPListArray(e));
			}),
			Pair("hex", \e -> {
				PInt(parseHex(getPString(e)))
			}),
			Pair("stringinclude", \e -> {
				PStringInclude(getPString(e))
			}),
			Pair("import", \e -> {
				PImport(getPString(e))
			}),
			Pair("forbid", \e -> {
				PForbid(getPString(e))
			}),
			Pair("export", \e -> {
				PExport(e)
			}),
			Pair("ref", \e -> {
				PRef(e)
			}),
			Pair("default", \e -> {
				PCase("default", [], e)
			}),
			Pair("polytype", \e -> {
				PTypePar(getPString(e))
			}),
			Pair("arraytype", \e -> {
				PTypeName("array", [getPType(e)])
			}),
			Pair("reftype", \e -> {
				PTypeName("ref", [getPType(e)])
			}),
			Pair("array", \e -> {
				PArray(getPListArray(e));
			}),
		]),
		// Binary operators
		pairs2tree([
			bin("||"), bin("&&"),
			bin("=="), bin("!="),
			bin("<="), bin("<"), bin(">"), bin(">="),
			bin("+"), bin("-"), 
			bin("*"), bin("/"), bin("%"), 
			bin("index"), bin("dot"),
			bin("if"),
			Pair("lambda", \args, b -> {
				fargs = map(getPListArray(args), getPArgType);
				PLambda(fargs, b);
			}),
			Pair("call", \fn, args -> {
				PCall(fn, getPListArray(args))
			}),
			bin(":="), bin("|>"), bin(":"), 

			Pair("switch", \a, b -> {
				PSwitch(a, getPListArray(b))
			}),
			Pair("typename", \a, b -> {
				PTypeName(getPString(a), map(getPListArray(b), getPType))
			}),
			Pair("union", \a, b -> {
				PUnion(getPTypeName(a), map(getPListArray(b), getPTypeName))
			}),
			Pair("global", \a, b -> {
				PGlobal(getPString(a), b)
			}),
			Pair("structdef", \a, b -> {
				PStruct(getPString(a), map(getPListArray(b), getPStructArg));
			}),
			Pair("fntype", \a, b -> {
				PTypeFunction(map(getPListArray(a), getPType), getPType(b))
			}),
			Pair("argtype", \id, type -> {
				PArgType(getPString(id), getPType(type))
			}),
			Pair("cast", \val, type -> {
				PCast(val, getPType(type))
			}),
			Pair("fieldassign", \field, value -> {
				PFieldAssign(getPString(field), value)
			}),
			Pair("typedef", \var, type -> {
				PTypeDef(getPString(var), getPType(type))
			}),
		]),
		// Ternary operators
		pairs2tree([
			tri("ifelse"),
			tri("maybe"),
			Pair("let", \a, b, c -> {
				PLet(getPString(a), b, c)
			}),
			Pair("case", \a, b, c -> {
				PCase(getPString(a), map(getPListArray(b), getPString), c)
			}),
			Pair("structarg", \a, b, c -> {
				PStructArg(getPString(b), getPListArray(a) != [], getPType(c))
			}),
			Pair("global_typed", \id, type, value -> {
				PGlobal(getPString(id), PCallOp(":", [value, getPType(type)]))
			}),
			Pair("fndef_typed", \id, type, body -> {
				fntype = getPTypeFunction(type);
				argtypes : [PArgType] = map(fntype.args, getPArgType);

				PGlobal(getPString(id), 
					PLambda(argtypes,
						PCallOp(":", [body, fntype.returnType])
					)
				)
			}),
			Pair("::=", \a, field, val -> {
				PSetMutable(a, getPString(field), val);
			}),
			Pair("with", \struct, value, fields -> {
				PWith(getPVar(struct), value, map(getPListArray(fields), getPFieldAssign));
			}),
		]),
		// Quadrary operators
		pairs2tree([
			Pair("let_typed", \a, b, c, d -> {
				PLet(getPString(a), PCallOp(":", [c, getPType(b)]), d)
			}),
			Pair("native", \id, isIo, type, name -> {
				PNative(getPString(id), getPListArray(isIo) != [], getPType(type), getPString(name))
			})
		])
	);
}

getPArgType(a : PExp) -> PArgType {
	switch (a) {
		PArgType(__, __): a;
		default: PArgType("error", PTypeName("", []));
	}
}

getPStructArg(a : PExp) -> PStructArg {
	switch (a) {
		PStructArg(__, __, __): a;
		default: PStructArg("error", false, PTypeName("", []));
	}
}
