import mini/pexp/pexp;
import mini/pexp/values;
import mini/pexp/pexp_parser;
import text/gringo/gringo_interpreter;
import text/deserialize_string;

export {
	parsePExp(program : string, onError : (string) -> void) -> PExp;
}

parsePExp(program : string, onError : (string) -> void) -> PExp {
	if (true) {
		gringoTypedParse(program, pexpTypeAction(onError), parse_flow, PSequence([], -1), onError);
	} else {
		gterm = prepareGringoParser("#include mini/pexp/pexp.gringo", onError);
		if (gterm != GEpsilon()) {
			// OK, parse the program
			ops = pexpTypeOps();
			gringoParseWithActionCheck(program, ops, pexpTypeAction(onError), gterm, PSequence([], -1), onError);
		} else {
			onError("Could not understand grammar");
			PSequence([], -1);
		}
	}
}

// This defines the semantic actions used in the grammar
pexpTypeAction(onError : (string) -> void) -> GringoAction<List<PExp>> {
	gringoTypedAction(
		// Make a string
		\s : string -> PString(s, 0),
		// Extract a string from a value (typically a string)
		getPString,
		// Construct the basic value
		\b -> PBool(b, 0), // We do not have bools, so use ints
		\i -> PInt(s2i(i), 0),
		\d -> PDouble(s2d(d), 0), // We do not have doubles, so just use ints
		// Construct an empty array
		\ -> PList(makeList()),
		// Append an element to an array
		\h, t -> {
			switch (t) {
				PList(es): PList(Cons(h, es));
				default: t;
			}
		},
		pexpTypeOps()
	);
}

pexpTypeOps() -> GringoTypedOperators<PExp> {
	todo = \ -> -1;

	un = \op -> Pair(op, \l -> PCallOp(op, [l], todo()));
	bin = \op -> Pair(op, \l, r -> PCallOp(op, [l, r], todo()));
	tri = \op -> Pair(op, \l, m, r -> PCallOp(op, [l, m, r], todo()));
	mktype = \t, pos -> PTypeName(t, [], pos);

	GringoTypedOperators(
		// Nullary operators
		pairs2tree([
			Pair("void", \ -> mktype("void", todo())),
			Pair("bool", \ -> mktype("bool", todo())),
			Pair("int", \ -> mktype("int", todo())),
			Pair("double", \ -> mktype("double", todo())),
			Pair("string", \ -> mktype("string", todo())),
			Pair("flow", \ -> mktype("flow", todo())),
			Pair("auto", \ -> mktype("auto", todo())),
			Pair("nativetype", \ -> mktype("native", todo())),
		]),
		// Unary operators
		pairs2tree([
			un("negate"),
			un("not"),
			un("deref"),

			Pair("unescape", \e -> {
				switch (e) {
					PString(t, pos): PString(deserializeString(t).first, pos);
					default: e;
				}
			}),
			Pair("var", \e -> {
				PVar(getPString(e), todo())
			}),
			Pair("sequence", \e -> {
				PSequence(getPListArray(e), todo());
			}),
			Pair("hex", \e -> {
				PInt(parseHex(getPString(e)), todo())
			}),
			Pair("stringinclude", \e -> {
				PStringInclude(getPString(e), todo())
			}),
			Pair("import", \e -> {
				PImport(getPString(e), todo())
			}),
			Pair("forbid", \e -> {
				PForbid(getPString(e), todo())
			}),
			Pair("export", \e -> {
				PExport(e, todo())
			}),
			Pair("ref", \e -> {
				PRef(e, todo())
			}),
			Pair("default", \e -> {
				PCase("default", [], e, todo())
			}),
			Pair("polytype", \e -> {
				PTypePar(getPString(e), todo())
			}),
			Pair("arraytype", \e -> {
				PTypeName("array", [getPType(e)], todo())
			}),
			Pair("reftype", \e -> {
				PTypeName("ref", [getPType(e)], todo())
			}),
			Pair("array", \e -> {
				PArray(getPListArray(e), todo());
			}),
		]),
		// Binary operators
		pairs2tree([
			bin("||"), bin("&&"),
			bin("=="), bin("!="),
			bin("<="), bin("<"), bin(">"), bin(">="),
			bin("+"), bin("-"), 
			bin("*"), bin("/"), bin("%"), 
			bin("index"), bin("dot"),
			bin("if"),
			Pair("lambda", \args, b -> {
				fargs = map(getPListArray(args), getPArgType);
				PLambda(fargs, b, todo());
			}),
			Pair("call", \fn, args -> {
				PCall(fn, getPListArray(args), todo())
			}),
			bin(":="), bin("|>"), bin(":"), 

			Pair("switch", \a, b -> {
				PSwitch(a, getPListArray(b), todo())
			}),
			Pair("typename", \a, b -> {
				PTypeName(getPString(a), map(getPListArray(b), getPType), todo())
			}),
			Pair("union", \a, b -> {
				PUnion(getPTypeName(a), map(getPListArray(b), getPTypeName), todo())
			}),
			Pair("global", \a, b -> {
				PGlobal(getPString(a), b, todo())
			}),
			Pair("structdef", \a, b -> {
				PStruct(getPString(a), map(getPListArray(b), getPStructArg), todo());
			}),
			Pair("fntype", \a, b -> {
				PTypeFunction(map(getPListArray(a), getPType), getPType(b), todo())
			}),
			Pair("argtype", \id, type -> {
				PArgType(getPString(id), getPType(type), todo())
			}),
			Pair("cast", \val, type -> {
				PCast(val, getPType(type), todo())
			}),
			Pair("fieldassign", \field, value -> {
				PFieldAssign(getPString(field), value, todo())
			}),
			Pair("typedef", \var, type -> {
				PTypeDef(getPString(var), getPType(type), todo())
			}),
		]),
		// Ternary operators
		pairs2tree([
			tri("ifelse"),
			tri("maybe"),
			Pair("let", \a, b, c -> {
				PLet(getPString(a), b, c, todo())
			}),
			Pair("case", \a, b, c -> {
				PCase(getPString(a), map(getPListArray(b), getPString), c, todo())
			}),
			Pair("structarg", \a, b, c -> {
				PStructArg(getPString(b), getPListArray(a) != [], getPType(c), todo())
			}),
			Pair("global_typed", \id, type, value -> {
				PGlobal(getPString(id), PCallOp(":", [value, getPType(type)], todo()), todo())
			}),
			Pair("fndef_typed", \id, type, body -> {
				fntype = getPTypeFunction(type);
				argtypes : [PArgType] = map(fntype.args, getPArgType);

				PGlobal(getPString(id), 
					PLambda(argtypes,
						PCallOp(":", [body, fntype.returnType], todo()), todo()
					), todo()
				)
			}),
			Pair("::=", \a, field, val -> {
				PSetMutable(a, getPString(field), val, todo());
			}),
			Pair("with", \struct, value, fields -> {
				PWith(getPVar(struct), value, map(getPListArray(fields), getPFieldAssign), todo());
			}),
		]),
		// Quadrary operators
		pairs2tree([
			Pair("let_typed", \a, b, c, d -> {
				PLet(getPString(a), PCallOp(":", [c, getPType(b)], todo()), d, todo())
			}),
			Pair("native", \id, isIo, type, name -> {
				PNative(getPString(id), getPListArray(isIo) != [], getPType(type), getPString(name), todo())
			})
		])
	);
}

getPArgType(a : PExp) -> PArgType {
	switch (a) {
		PArgType(__, __, __): a;
		default: PArgType("error", PTypeName("", [], -1), -1);
	}
}

getPStructArg(a : PExp) -> PStructArg {
	switch (a) {
		PStructArg(__, __, __, __): a;
		default: PStructArg("error", false, PTypeName("", [], -1), -1);
	}
}
