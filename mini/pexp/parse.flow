import mini/pexp/pexp;
import mini/pexp/values;
import mini/pexp/pexp_parser;
import text/gringo/gringo_interpreter;
import text/deserialize_string;

export {
	parsePExp(program : string, onError : (string) -> void) -> PExp;
}

parsePExp(program : string, onError : (string) -> void) -> PExp {
	if (false) {
		gringoTypedParse(program, pexpTypeAction(onError), parse_flow, PSequence([]), onError);
	} else {
		gterm = prepareGringoParser("#include mini/pexp/pexp.gringo", onError);
		if (gterm != GEpsilon()) {
			// OK, parse the program
			checkGringoTypedOps(pexpTypeOps(), gterm);
			gringoInterpretedParse(program, pexpTypeAction(onError), gterm, PSequence([]), onError);
		} else {
			onError("Could not understand grammar");
			PSequence([]);
		}

	}
}


// This defines the semantic actions used in the grammar
pexpTypeAction(onError : (string) -> void) -> GringoAction<List<PExp>> {
	gringoTypedAction(
		// Make a string
		\s : string -> PString(s),
		// Extract a string from a value (typically a string)
		getPString,
		// Construct the basic value
		\b -> PBool(b), // We do not have bools, so use ints
		\i -> PInt(s2i(i)),
		\d -> PDouble(s2d(d)), // We do not have doubles, so just use ints
		// Construct an empty array
		\ -> PArray([]),
		// Append an element to an array
		\h, t -> {
			switch (t) {
				PArray(es): PArray(arrayPush(es, h));
				default: t;
			}
		},
		pexpTypeOps()
	);
}

pexpTypeOps() -> GringoTypedOperators<PExp> {
	un = \op -> Pair(op, \l -> PCallOp(op, [l]));
	bin = \op -> Pair(op, \l, r -> PCallOp(op, [l, r]));
	tri = \op -> Pair(op, \l, m, r -> PCallOp(op, [l, m, r]));
	GringoTypedOperators(
		// Nullary operators
		pairs2tree([
			Pair("int", \ -> PTypeInt()),
		]),
		// A Tree<string, (Exp) -> Exp> of unary operator constructors
		pairs2tree([
			un("negate"),
			un("not"),
			un("deref"),

			Pair("unescape", \e -> {
				switch (e) {
					PString(t): PString(deserializeString(t).first);
					default: e;
				}
			}),
			Pair("var", \e -> {
				PVar(getPString(e))
			}),
			Pair("sequence", \e -> {
				PSequence(getPArray(e));
			}),
			Pair("hex", \e -> {
				PInt(parseHex(getPString(e)))
			}),
			Pair("import", \e -> {
				PImport(getPString(e))
			}),
			Pair("forbid", \e -> {
				PForbid(getPString(e))
			}),
			Pair("export", \e -> {
				PExport(e)
			}),
			Pair("ref", \e -> {
				PRef(e)
			}),
			Pair("polytype", \e -> {
				PTypePar(getPString(e))
			}),
			Pair("default", \e -> {
				PCase("default", [], e)
			})
		]),
		// A Tree<string, (Exp, Exp) -> Exp> of binary operator constructors
		pairs2tree([
			bin("||"), bin("&&"),
			bin("=="), bin("!="),
			bin("<="), bin("<"), bin(">"), bin(">="),
			bin("+"), bin("-"), 
			bin("*"), bin("/"), bin("%"), 
			bin("index"), bin("dot"),
			bin("if"),
			Pair("lambda", \args, b -> {
				fargs = map(getPArray(args), getPArgType);
				PLambda(fargs, b);
			}),
			Pair("call", \fn, args -> {
				PCall(fn, getPArray(args))
			}),
			bin(":="), bin("|>"), bin(":"), 
			Pair("switch", \a, b -> {
				PSwitch(a, getPArray(b))
			}),
			Pair("typename", \a, b -> {
				// TODO: Verify we did not loose any types from the filter
				PTypeName(getPString(a), filtermap(getPArray(b), getPType))
			}),
			Pair("union", \a, b -> {
				mtn = getPTypeName(a);
				mtn ?? {
					PUnion(mtn, filtermap(getPArray(b), getPTypeName))
				} : {
					println("Expected typename in union def");
					PVoid()
				}
			}),
			Pair("global", \a, b -> {
				PGlobal(getPString(a), b)
			}),
			Pair("structdef", \a, b -> {
				PStruct(getPString(a), map(getPArray(b), getPStructArg));
			})
		]),
		// A Tree<string, (Exp, Exp, Exp) -> Exp> of ternary operator constructors
		pairs2tree([
			tri("ifelse"),
			tri("maybe"),
			Pair("let", \a, b, c -> {
				PLet(getPString(a), b, c)
			}),
			Pair("case", \a, b, c -> {
				PCase(getPString(a), map(getPArray(b), getPString), c)
			}),
			Pair("structarg", \a, b, c -> {
				mtype = getPType(c);
				type = mtype ?? mtype : PTypeInt();
				PStructArg(getPString(b), getPArray(a) != [], type)
			}),
		]),
		// A Tree<string, (Exp, Exp, Exp, Exp) -> Exp of quadrary operators
		pairs2tree([
			Pair("let_typed", \a, b, c, d -> {
				mtype = getPType(b);
				mtype ?? {
					PLet(getPString(a), PCallOp(":", [c, mtype]), d)
				} : {
					println("ERROR");
					PLet(getPString(a), c, d);
				}
			})
		])
	);
}

getPArgType(a : PExp) -> PArgType {
	switch (a) {
		PArgType(__, __): a;
		default: PArgType("error", PTypeInt());
	}
}

getPStructArg(a : PExp) -> PStructArg {
	switch (a) {
		PStructArg(__, __, __): a;
		default: PStructArg("error", false, PTypeInt());
	}
}
