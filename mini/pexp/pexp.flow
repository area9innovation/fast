export {
	PValue ::= PVoid, PBool, PInt, PDouble, PString, 
		// When evaluated
		PArrayValue, PLambda;

		PVoid();
		PBool(v : bool);
		PInt(v : int);
		PDouble(v : double);
		PString(v : string);
		PArrayValue(values : [PValue]);

	PExp ::= PValue, PTopLevel, PType, PArgType,
		PRef, PVar, PLet, PIf, PCall, PCallOp,
		PArray, PSequence, PSwitch, PCase;

	PTopLevel ::= PImport, PForbid, PExport, PGlobal, PUnion, PStruct, PStructArg;
		PImport(path : string);
		PForbid(path : string);
		PExport(exports : PExp);
		PGlobal(id : string, value : PExp);
		PUnion(typename : PTypeName, types : [PTypeName]);
		PStruct(id : string, structArgs : [PStructArg]);
			PStructArg(id : string, ismutable : bool, type : PType);

		PRef(value : PExp);
		PVar(var : string);
		PLet(var : string, value : PExp, body : PExp);
		PIf(cond : PExp, then : PExp, else_ : PExp);
		// Array construction
		PArray(exps : [PExp]);
		PSequence(exps : [PExp]);
		PCall(fn : PExp, args : [PExp]);
		// For built-in operators
		PCallOp(op : string, args : [PExp]);
		PLambda(args : [PArgType], body : PExp);

			PArgType(id : string, type : PType);

		PSwitch(value : PExp, cases : [PExp]);
		PCase(id : string, args : [string], body : PExp);

		// Definitions
		// Types
		// PSwitch
		// PWith
	PType ::= PTypeInt, PTypePar, PTypeName;
		PTypeInt();

	PTypeName(id : string, typars : [PType]);
	PTypePar(id : string);
}
