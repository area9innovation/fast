import ds/list;

export {
	PValue ::= PVoid, PBool, PInt, PDouble, PString, 
		// When evaluated
		PArrayValue, PLambda;

		PVoid();
		PBool(v : bool);
		PInt(v : int);
		PDouble(v : double);
		PString(v : string);
		PArrayValue(values : [PValue]);

	PExp ::= PValue, PTopLevel, PType, PArgType,
		PStringInclude,
		PVar, PLet, PIf, PCall, PCallOp,
		PRef, PSetMutable, PArray, PSequence, PSwitch, PCase, PCast,
		PWith, PFieldAssign,

		// While parsing, we have an efficient list for collecting arrays
		PList
		;

	PTopLevel ::= PImport, PForbid, PExport, PGlobal, PNative, PUnion, PStruct, PStructArg,
		PTypeDef;
		PImport(path : string);
		PForbid(path : string);
		PExport(exports : PExp);
		PGlobal(id : string, value : PExp);
		PTypeDef(id : string, type : PType);
		PNative(id : string, isIo : bool, type : PType, name : string);
		PUnion(typename : PTypeName, types : [PTypeName]);
		PStruct(id : string, structArgs : [PStructArg]);
			PStructArg(id : string, ismutable : bool, type : PType);
		
		PStringInclude(path : string);

		PRef(value : PExp);
		PSetMutable(lhs : PExp, field : string, value : PExp);
		PVar(var : string);
		PLet(var : string, value : PExp, body : PExp);
		PIf(cond : PExp, then : PExp, else_ : PExp);
		// Array construction
		PArray(exps : [PExp]);
		PSequence(exps : [PExp]);
		PCall(fn : PExp, args : [PExp]);
		// For built-in operators
		PCallOp(op : string, args : [PExp]);
		PLambda(args : [PArgType], body : PExp);

			PArgType(id : string, type : PType);

		PSwitch(value : PExp, cases : [PExp]);
		PCase(id : string, args : [string], body : PExp);
		PCast(value : PExp, target : PType);

		PWith(struct : string, value : PExp, fields : [PFieldAssign]);
			PFieldAssign(id : string, value : PExp);


	PList(l : List<PExp>);

		// Definitions
	PType ::= PTypePar, PTypeName, PTypeFunction, PArgType;

	PTypeName(id : string, typars : [PType]);
	PTypePar(id : string);
	PTypeFunction(args : [PType], returnType : PType);
}
