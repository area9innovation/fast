import fast/fast_path;

import mini/commands/db;

import mini/exp/dependencies;
import mini/exp/topological;

import mini/forth/stack;
import mini/forth/parse;

import mini/types/typeinference;
import mini/types/resolve;
import mini/types/pretty;

export {
	// TODO: Split this into two:
	// - One for mini-forth
	// - The other for the compiler backend stuff
	miniCompile(db : MiniDb) -> MiniDb;
}

miniCompile(db : MiniDb) -> MiniDb {
	mcom = popMiniCommand(db);
	ndb = mcom.first;
	switch (mcom.second) {
		None(): ndb;
		Some(command): {
			println("Running " + miniCommand2string(command));
			miniCompile(runMiniCommand(ndb, command));
		}
	}
}

runMiniCommand(db : MiniDb, command : MiniCommand) -> MiniDb {
	switch (command) {
		MiniEvalFile(name, evalcommand): {
			path = fastPath2path(db.includes, name);
			content = getFileContent(path);
			ndb = pushMiniValue(db, MiniString(content));
			miniEvalForth(name, ndb, evalcommand);
		}
		MiniDefine(file, id, body): {
			// Define or redefine this id to this body
			mexisting = lookupTree(db.program.declarations, id);

			def = \ -> {
				// OK, we have either a new or changed definition

				// Update the dependencies
				npr = updateMiniDeps(db.program, id, body);
				db2 = pushMiniCommand(db, MiniTypeInfer(makeSet1(id)));

				// OK, this is a new definition
				ndecl = MiniAst(npr with 
					declarations = setTree(npr.declarations, id, body),
					declarationFile = setTree(npr.declarationFile, id, file),
				);

				MiniDb(db2 with program = ndecl);
			}

			mexisting ?? {
				if (mexisting == body) {
					// It is the same. Nothing to do.
					db;
				} else {
					// OK, it is new. We should put it in and process it
					def();
				}
			} : def();
		}
		MiniTypeInfer(ids): {
			// Find a topological order of these ids
			order = topologicalMiniOrder(db.program, ids);

			tenv = makeMiniTypeEnv(db.program);
			tenv2 = fold(order, tenv, \acc, id -> {
				mfn = lookupTree(db.program.declarations, id);
				mfn ?? {
					type = typeInferenceMini(acc, mfn);
					// Set the type in the type environment when inferring
					setMiniType2(acc, id, type);
				} : {
					println("Unknown name " + id);
					acc;
				}
			});

			// Then we should set the (resolved) type in the overall type environment
			// and check if there is a change, and if so, request re-typecheck
			// of dependent ids
			foldTree(tenv2.types, db, \id, type, acc -> {
				updateMiniType(acc, ids, id, resolveMiniType(tenv2, type))
			})
		}
	}
}

updateMiniDeps(pr : MiniAst, id : string, body : MiniExp) -> MiniAst {
	npr = removeMiniDeps(pr, id);
	addMiniDeps(npr, id, body)
}

addMiniDeps(pr : MiniAst, id : string, body : MiniExp) -> MiniAst {
	deps = extractMiniDeps(body, makeSet(), makeSet());
	// println(id + " depends on " + strGlue(set2array(deps), ", "));
	MiniAst(pr with
		dependencies = setTree(pr.dependencies, id, deps),
		dependents = foldSet(deps, pr.dependents, \acc, dep -> {
			insertMultimap(acc, dep, id)
		})
	)
}

removeMiniDeps(pr : MiniAst, id : string) -> MiniAst {
	deps = lookupMultimap(pr.dependencies, id);
	MiniAst(
		pr with
		dependencies = removeFromTree(pr.dependencies, id),
		dependents = foldSet(deps, pr.dependents, \acc, dep -> {
			removeMultimap(acc, dep, id)
		})
	);
}

// OK, we have a new type for the "id".
// The "types" is the set of types we are updating in this round
// and we do not need to propagate any changes to those
updateMiniType(db : MiniDb, updating : Set<string>, id : string, type : MiniType2) -> MiniDb {
	program = db.program;
	mexist = lookupTree(program.types, id);
	def = \ -> {
		deps = lookupMultimap(db.program.dependents, id);
		newDeps = differenceSets(deps, updating);
		ndb = if (isEmptySet(newDeps)) db else pushMiniCommand(db, MiniTypeInfer(newDeps));
		MiniDb(ndb with program = MiniAst(program with types = setTree(program.types, id, type)));
	}
	mexist ?? {
		if (mexist == type) {
			db;
		} else def();
	} : def();
}

