import fast/fast_path;

import mini/commands/db;

import mini/exp/dependencies;
import mini/exp/topological;

import mini/forth/eval;
import mini/forth/stack;

import mini/types/type_check;
import mini/types/resolve;
import mini/types/pretty;

import behaviour;

export {
	// Run the commands requested.
	// Keep progress updated in the remaining behaviour.
	// When all is done, we call onDone with the resulting db
	miniCompile(db : MiniDb, remaining : DynamicBehaviour<string>, onDone : (MiniDb) -> void) -> void;
}

miniCompile(db : MiniDb, remaining : DynamicBehaviour<string>, onDone : (MiniDb) -> void) -> void {
	mcom = popMiniCommand(db);
	ndb = mcom.first;
	switch (mcom.second) {
		None(): {
			next(remaining, "Done");
			onDone(ndb);
		}
		Some(command): {
			if (true) {
				// println(miniCommand2string(command));
			} else {
				println("Running command " + miniCommand2string(command) + " with stack");
				iterList(db.forth.stack, println);
			};
			res = runMiniCommand(ndb, command);
			priority = getMiniCommandPriority(command);
			commandCounts = foldTree(db.queue, makeTree(), \prio, cmds, acc -> {
				setTree(acc, prio, lookupTreeDef(acc, prio, 0) + length(cmds))
			});
			totalCount = sum(getTreeValues(commandCounts));
			if (priority == 0 || (totalCount % 100) == 0) {
				status = foldTree(commandCounts, "", \prio, count, acc -> {
					if (count > 0) {
						acc + getMiniCommandFromPriority(prio) + ": " + i2s(count) + " "
					} else acc;
				});
				next(remaining, status);
				deferUntilRender(
					\ -> {
						miniCompile(res, remaining, onDone)
					}					
				)
			} else {
				miniCompile(res, remaining, onDone)
			}
		}
	}
}

runMiniCommand(db : MiniDb, command : MiniCommand) -> MiniDb {
	switch (command) {
		MiniProcessFile(usedByFile, name, evalcommand): {
			path = fastPath2path(db.includes, name);
			if (shouldReadFile(db.fileCache, path)) {
				content = getFileContent(path);
				// TODO: Update deps: We have to collect all of them from each file
				ndb = pushMiniValue(db, MiniString(content));
				miniEvalForth(name, ndb, evalcommand);
			} else {
				// OK, this is already read. We can skip it
				db;
			}
		}
		MiniDefine(file, id, body): {
			// Define or redefine this id to this body
			mexisting = lookupTree(db.program.declarations, id);

			def = \ -> {
				// OK, we have either a new or changed definition

				// Update the dependencies
				deps = extractMiniDeps(body, makeSet(), makeSet());
				npr = MiniAst(db.program with idDependents = updateMiniDependent(db.program.idDependents, id, deps));
				db2 = pushMiniCommand(db, MiniTypeInfer(makeSet1(id)));

				// OK, this is a new definition
				ndecl = MiniAst(npr with 
					declarations = setTree(npr.declarations, id, body),
					declarationFile = setTree(npr.declarationFile, id, file),
				);

				MiniDb(db2 with program = ndecl);
			}

			mexisting ?? {
				if (mexisting == body) {
					// It is the same. Nothing to do.
					db;
				} else {
					// OK, it is new. We should put it in and process it
					def();
				}
			} : def();
		}
		MiniTypeInfer(ids): {
			tenv = typecheckMiniTypes(db.program, ids);

			// Then we should set the (resolved) type in the overall type environment
			// and check if there is a change, and if so, request re-typecheck
			// of dependent ids
			foldTree(tenv.types, db, \id, type, acc -> {
				updateMiniType(acc, ids, id, resolveMiniType(tenv, type))
			})
		}
	}
}

// OK, we have a new type for the "id".
// The "types" is the set of types we are updating in this round
// and we do not need to propagate any changes to those
updateMiniType(db : MiniDb, updating : Set<string>, id : string, type : MiniType2) -> MiniDb {
	program = db.program;
	mexist = lookupTree(program.types, id);
	def = \ -> {
		deps = lookupMultimap(db.program.idDependents.dependents, id);
		newDeps = differenceSets(deps, updating);
		ndb = if (isEmptySet(newDeps)) db else pushMiniCommand(db, MiniTypeInfer(newDeps));
		MiniDb(ndb with program = MiniAst(program with types = setTree(program.types, id, type)));
	}
	mexist ?? {
		if (mexist == type) {
			db;
		} else def();
	} : def();
}
