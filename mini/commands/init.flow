import mini/commands/db;
import mini/forth/init;
import mini/forth/eval;
import mini/types/builtin;

export {
	makeMiniDb(includes : [string], onError : (string) -> void) -> MiniDb;
}

makeMiniDb(includes : [string], onError : (string) -> void) -> MiniDb {
	strict = isUrlParameterTrue("strict");
	stagestr = getUrlParameterDef("stages", "parse,ct,type,lower");
	stages = fold(strSplit(stagestr, ","), makeSet(), \acc, stage -> {
		if (stage == "parse") insertSet(acc, StageParse())
		else if (stage == "ct") insertSet(acc, StageCompileTime())
		else if (stage == "type") insertSet(acc, StageTypeInference())
		else if (stage == "lower") insertSet(acc, StageLower())
		else if (stage == "coalesce") insertSet(acc, StageTypeCoalesce())
		else {
			println("Unknown stage: " + stage);
			acc;
		}
	});
	options = MiniOptions(
		s2i(getUrlParameter("verbose")), 
		buildSet(strSplit(getUrlParameter("debug"), ",")),
		stages,
		// Implicit type pars
		!strict
	);

	db = MiniDb(
		includes, 
		makeTree(), 
		MiniDependent(makeTree(), makeTree()),
		makeMiniFileCache(),
		MiniAst(
			makeTree(), makeTree(), makeTree(), makeTree(), MiniDependent(makeTree(), makeTree()), 
			getBuiltinMiniTypes(), makeTree(), makeTree(), MiniSubtypeGraph(makeSimpleGraph()),
			makeTree(), getBuiltinPureNames(), options,
			\env, name, pos, error -> {
				file = lookupTreeDef(env.declarationFile, name, "");
				prefix = if (pos != -1) {
					lineCol : LineColumn = findLineOneTime(getFileContent(file), pos);
					i2s(lineCol.lineno) + ":" + i2s(lineCol.column) + ":"
				} else {
					// TODO: We could maybe find the position of name?
					"";
				};
				prefix1 = (if (file != "") file + ":" else "") + prefix + (if (name != "") name + ":" else "");
				onError((if (prefix1 != "") prefix1 + " " else "") + error);
			}
		),
		makeMiniForth(),
		makeTree(),
		makeTree(),
		makeList(),
		onError
	);

	lib = getFileContent("mini/forth/lib.forth");
	miniEvalForths("", db, strSplit(lib, "\n"))
}
