import mini/exp/exp;
import ds/set;
import algorithms;

export {
	// These are the commands that the underlying compiler understands
	MiniCommand ::= MiniProcessFile, MiniSetAnnotation, MiniDefine, MiniPopFile, MiniTypeInfer;

		// Read a file and if changed, run this Forth command on it. Notice this is async
		MiniProcessFile(usedByFile : string, name : string, asyncCommand : string);

		// Set an annotation for a given scope (id). If scope is "", then it is all ids.
		MiniSetAnnotation(scope : string, annotation : string, value : MiniExp);

		// Define this id to this expression from this file
		MiniDefine(file : string, name : string, value : MiniExp);

		// Finish processing the current file.
		MiniPopFile();

		// Infer the type of these ids, since they are new
		MiniTypeInfer(ids : Set<string>);

	// What order should commands be run in? 0 is first.
	getMiniCommandPriority(m : MiniCommand) -> int;

	getMiniCommandFromPriority(p : int) -> string;

	// If we need to run all these commands of the same type, can that be optimized?
	combineMiniCommands(m : [MiniCommand]) -> [MiniCommand];

	miniCommand2string(m : MiniCommand) -> string;
}

getMiniCommandPriority(c : MiniCommand) -> int {
	switch (c) {
		MiniProcessFile(__, name, command): 0;
		MiniSetAnnotation(annotation, scope, value): 1;
		MiniDefine(file, name, value): 2;
		MiniPopFile(): 3;
		MiniTypeInfer(ids): 4;
	}
}

getMiniCommandFromPriority(p : int) -> string {
	["Files", "Set annotation", "Defines", "Finish file", "Typechecks"][p]
}

miniCommand2string(c : MiniCommand) -> string {
	switch (c) {
		MiniProcessFile(__, name, command): "Process file '" + name + "' with '" + command + "'";
		MiniSetAnnotation(annotation, scope, value): "Set annotation " + annotation + " with scope " + scope;
		MiniDefine(file, name, value): "Define " + name;
		MiniPopFile(): "Pop file";
		MiniTypeInfer(ids): "Infer type " + strGlue(set2array(ids), ", ");
	}
}

combineMiniCommands(ms : [MiniCommand]) -> [MiniCommand] {
	if (ms == []) ms
	else {
		first = ms[0];
		switch (first) {
			MiniProcessFile(__, __, command): uniq(ms);
			MiniSetAnnotation(__, __, __): ms;
			MiniDefine(__, __, __): ms;
			MiniPopFile(): ms;
			MiniTypeInfer(__): {
				[MiniTypeInfer(fold(ms, makeSet(), \acc, tc -> {
					switch (tc) {
						MiniTypeInfer(ss): mergeSets(acc, ss);
						default: acc;
					}
				}))]
			}
		}
	}
}
