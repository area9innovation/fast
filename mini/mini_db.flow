import mini/mini_command;
import ds/set;
import ds/simplegraph;

export {
	MiniDb(
		// The include path we should use
		includes : [string],
		// The prioritized queue of stuff this compiler needs to work on.
		queue : Tree<int, [MiniCommand]>,

		// The program we are working on - is not consistent yet
		program : MiniAst,

		// This is the evaluation stack for the compiler itself
		stack : List<MiniExp>,

		// TODO: Add a set of outputs we are producing

		// TODO: Add a set of names which have errors. Change this interface accordingly:
		onError : (string) -> void,
	);

	// A consistent set of declarations
	MiniAst(
		// When was this set ready?
		// timestamp : double,
		// The names defined in this program
		declarations : Tree<string, MiniExp>,
		// Where is each name defined? From name to file
		declarationFile : Tree<string, string>,
		// What does this id depend on?
		dependencies : Tree<string, Set<string>>,
		// What depends on this id?
		dependents : Tree<string, Set<string>>,
		// What names are declared in this file?
		// fileDeclarations : Tree<string, [string]>,
		// The types of expressions
		// types : Tree<MiniExp, MiniType>,
		// The dependency graph between names
		// dependency : SimpleGraph<string, bool>,
	);

	pushMiniCommand(db : MiniDb, mini : MiniCommand) -> MiniDb;

	popMiniCommand(db : MiniDb) -> Pair<MiniDb, Maybe<MiniCommand>>;
}

pushMiniCommand(db : MiniDb, mini : MiniCommand) -> MiniDb {
	prio = getMiniCommandPriority(mini);
	MiniDb(db with queue = treePushToArrayUnique(db.queue, prio, mini));
}

popMiniCommand(db : MiniDb) -> Pair<MiniDb, Maybe<MiniCommand>> {
	mp = popmin(db.queue);
	switch (mp) {
		EmptyPopResult(): Pair(db, None());
		PopResult(prio, commands, rest): {
			db1 = MiniDb(db with queue = rest);
			if (commands == []) {
				popMiniCommand(db1)
			} else {
				// See if we can combine some of them
				comb = combineMiniCommands(commands);
				he = comb[0];
				ta = tail(comb);
				db2 = if (ta != []) MiniDb(db1 with queue = setTree(db1.queue, prio, ta)) else db1;
				Pair(db2, Some(he));
			}
		}
	}
}
