import mini/forth/forth;
import mini/commands/db;
import text/serialize;
import mini/forth/stack;
import mini/exp/value;

export {
	// Evaluate this - these commands can have side-effects on the compiler
	miniEvalForth(file : string, db : MiniDb, command : string) -> MiniDb;

	// Evaluate these ids
	miniEvalForths(file : string, db : MiniDb, commands : [string]) -> MiniDb;
}

miniEvalForth(file : string, db : MiniDb, command : string) -> MiniDb {
	fchar = getCharAt(command, 0);
	if (command == "") db
	else if (startsWith(command, "\"")) {
		// MiniString(value : string);
		str = deserializeString(command);
		pushMiniValue(db, MiniString(str.first));
	} else if (("0" <= fchar && fchar <= "9") || fchar == ".") {
		if (strContains(command, ".") || strContains(command, "e")) {
			// MiniDouble(value : double);
			d = s2d(command);
			pushMiniValue(db, MiniDouble(d));
		} else {
			// MiniInt(value : int);
			i = s2i(command);
			pushMiniValue(db, MiniInt(i));
		}
	} else if (command == "import") {
		// TODO: This can be defines
		filename = popMiniValue(db);
		pushMiniCommand(filename.second, MiniEvalFile(getMiniString(filename.first), "evallines"));
	} else if (command == "evalfile") {
		// 	MiniEvalFile(name : string, command);
		filename = popMiniValue(db);
		evalcommand = popMiniValue(filename.second);
		pushMiniCommand(evalcommand.second, MiniEvalFile(getMiniString(filename.first), getMiniString(evalcommand.first)));
	} else if (command == "define") {
		// MiniDefine(name : string, value : MiniExp);
		value = popMiniValue(db);
		name = popMiniValue(value.second);
		pushMiniCommand(name.second, MiniDefine(file, getMiniString(name.first), value.first));
	} else if (command == "evallines") {
		// Splits each line in the string, and evaluates it
		// TODO: Could maybe be strsplit, and then some kind of foreach
		content = popMiniValue(db);
		lines = strSplit(getMiniString(content.first), "\n");
		fold(lines, content.second, \acc, line -> {
			miniEvalForth(file, acc, line)
		});
	} else if (startsWith(command, "def ")) {
		// OK, defining a new Forth word (macro)
		parts = strSplit(command, " ");
		if (length(parts) < 2) {
			db.onError("def expects a name and the commands");
			db
		} else {
			name = parts[1];
			commands = tailFrom(parts, 2);
			// println("Defining macro " + name + " as " + strGlue(commands, " "));
			MiniDb(
				db with macros = setTree(db.macros, name, commands)
			)
		}
	} else if (startsWith(command, "// ")) {
		db;
	} else {
		macro = getTreeArrayValue(db.macros, command);
		if (macro != []) {
			miniEvalForths(file, db, macro)
		} else {
			mbuiltin = lookupTree(db.forth.definitions, command);
			mbuiltin ?? {
				MiniDb(
					db with forth = mbuiltin(db.forth)
				)
			} : {
				db.onError("Does not handle " + command);
				db;
			}
		}
	}
}

miniEvalForths(file : string, db : MiniDb, commands : [string]) -> MiniDb {
	fold(commands, db, \acc, command -> {
		miniEvalForth(file, acc, command);
	})
}
