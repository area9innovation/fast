import mini/mini_db;
import mini/mini_stack;
import mini/mini_dependencies;
import fast/fast_path;
import mini/mini_parse;

export {
	miniCompile(db : MiniDb) -> MiniDb;
}

miniCompile(db : MiniDb) -> MiniDb {
	if (db.queue == []) db
	else {
		val = db.queue[0];
		rest = tail(db.queue);
		ndb = MiniDb(db with queue = rest);

		miniCompile(switch (val) {
			MiniFilename(name): {
				withext = changeFileExt(name, ".mini");
				filename = fastPath2path(db.includes, withext);
				// Reads the lines of this file and runs them
				parseMiniFile(name, filename, ndb);
			}
			MiniDefine(file, id, body): {
				// Define or redefine this id to this body
				mexisting = lookupTree(ndb.program.declarations, id);

				def = \ -> {
					// OK, we have either a new or changed definition

					// Update the dependencies
					npr = updateMiniDeps(ndb.program, id, body);

					// All that are dependent on this id should be updated
					dependents = lookupMultimap(npr.dependents, id);
					db2 = if (isEmptySet(dependents)) ndb else pushMiniCommand(ndb, MiniReprocess(dependents));

					// OK, this is a new definition
					ndecl = MiniAst(npr with 
						declarations = setTree(npr.declarations, id, body),
						declarationFile = setTree(npr.declarationFile, id, file),
					);

					MiniDb(db2 with program = ndecl);
				}

				mexisting ?? {
					if (mexisting == body) {
						// It is the same. Nothing to do.
						ndb;
					} else {
						// OK, it is new. We should put it in and process it
						def();
					}
				} : def();
			}
			MiniReprocess(ids): {
				// TODO: Here, we should do them in topological order.
				println("TODO: Reprocess these " + strGlue(set2array(ids), ", "));
				ndb;
			}
		});
	};
}

updateMiniDeps(pr : MiniAst, id : string, body : MiniExp) -> MiniAst {
	npr = removeMiniDeps(pr, id);
	addMiniDeps(npr, id, body)
}

addMiniDeps(pr : MiniAst, id : string, body : MiniExp) -> MiniAst {
	deps = extractMiniDeps(body, makeSet(), makeSet());
	println(id + " depends on " + strGlue(set2array(deps), ", "));
	MiniAst(pr with
		dependencies = setTree(pr.dependencies, id, deps),
		dependents = foldSet(deps, pr.dependents, \acc, dep -> {
			insertMultimap(acc, dep, id)
		})
	)
}

removeMiniDeps(pr : MiniAst, id : string) -> MiniAst {
	deps = lookupMultimap(pr.dependencies, id);
	MiniAst(
		pr with
		dependencies = removeFromTree(pr.dependencies, id),
		dependents = foldSet(deps, pr.dependents, \acc, dep -> {
			removeMultimap(acc, dep, id)
		})
	);
}
