import gringo/utils;
import gringo/gringo_pretty;
import ds/simplegraph;

export {
	reduceCommon(g : GTerm) -> GTerm;
}

reduceCommon(g : GTerm) -> GTerm {
	// We should do this from small rules up to bigger rules
	// so we do not have to iterate and maximize overlap
	rules : Tree<string, GTerm> = findRules(makeTree(), g);

	// Build the dependency graph of rules
	graph0 = dependencyGraph(rules);
	source = mainRule(g);
	// OK, we get a loop-free graph
	graph = simpleLoopFree(graph0, source);

	if (false) {
		dot = simpleGraph2dot(graph, "", [], \node -> [DotLabel(node)], \edge -> []);
		setFileContent("deps.dot", dot);
		{}
	}

	// Find a topological order, and start from the leaves
	order = reverseA(topoSortSimpleGraph(graph));
	// println(order);

	// Replace them in this order
	fold(order, g, \acc, rule -> {
		// TODO: Replace with simpler search for just one rule
		nrules : Tree<string, GTerm> = findRules(makeTree(), acc);
		mterm = lookupTree(nrules, rule);

		mterm ?? {
			//	println(rule);
			replaceTerm(mterm, GVar(rule, 0), rule, acc)
		} : acc
	});
}

dependencyGraph(rules : Tree<string, GTerm>) -> SimpleGraph<string, bool> {
	foldTree(rules, makeSimpleGraph(), \rule, term, acc -> {
		deps = ruleDependencies(makeSet(), term);
		foldSet(deps, acc, \acc2, dep -> {
			if (rule != dep) {
				addSimpleEdge(acc2, rule, dep, true, 0);
			} else acc2;
		})
	});
}

ruleDependencies(acc : Set<string>, g : GTerm) -> Set<string> {
	switch (g) {
		GRule(id, term): {
			println("Unexpected");
			acc;
		}

		GChoice(left, right): ruleDependencies(ruleDependencies(acc, left), right);
		GSeq(left, right): ruleDependencies(ruleDependencies(acc, left), right);
		GStar(term): ruleDependencies(acc, term);
		GPlus(term): ruleDependencies(acc, term);
		GOpt(term): ruleDependencies(acc, term);
		GNegate(term): ruleDependencies(acc, term);
		GUnquote(term): ruleDependencies(acc, term);
		GString(text): acc;
		GRange(lower, upper): acc;
		GVar(id, power): insertSet(acc, id);
	}
}

// Does basic replacement in the term
replaceTerm(find : GTerm, replace : GTerm, exceptInRule : string, g : GTerm) -> GTerm {
	if (g == find) replace
	else switch (g) {
		GRule(id, term): {
			if (exceptInRule == id) g
			else GRule(id, replaceTerm(find, replace, exceptInRule, term));
		}
		GChoice(left, right): GChoice(replaceTerm(find, replace, exceptInRule, left), replaceTerm(find, replace, exceptInRule, right)); 
		GSeq(left, right): GSeq(replaceTerm(find, replace, exceptInRule, left), replaceTerm(find, replace, exceptInRule, right));
		GStar(term): GStar(replaceTerm(find, replace, exceptInRule, term));
		GPlus(term): GPlus(replaceTerm(find, replace, exceptInRule, term));
		GOpt(term): GOpt(replaceTerm(find, replace, exceptInRule, term));
		GNegate(term): GNegate(replaceTerm(find, replace, exceptInRule, term));
		GUnquote(term): GUnquote(replaceTerm(find, replace, exceptInRule, term));
		GString(text): g;
		GRange(lower, upper): g;
		GVar(id, power): g;
	}
}

// Replace occurences of a term with the id. This is for common subexpression elimination
commonReplacement(reversed : Tree<GTerm, [string]>, rule : string, g : GTerm) -> GTerm {
	switch (g) {
		GRule(id, term): {
			// Do we have a direct replacement?
			rep = findDirectReplacement(reversed, id, term);
			if (rep != term) GRule(id, rep)
			else GRule(id, commonReplacement(reversed, id, term));
		}
		GChoice(left, right): {
			rep = findDirectReplacement(reversed, rule, g);
			if (rep != g) rep
			else {
				lreplaced0 = findDirectReplacement(reversed, rule, left);
				rreplaced0 = findDirectReplacement(reversed, rule, right);

				lreplaced = commonReplacement(reversed, rule, lreplaced0);
				rreplaced = commonReplacement(reversed, rule, rreplaced0);
				GChoice(lreplaced, rreplaced);
			}
		}
		GSeq(left, right): {
			lreplaced = commonReplacement(reversed, rule, left);
			rreplaced = commonReplacement(reversed, rule, right);
			GSeq(lreplaced, rreplaced);
		}

		// Well, there is a theoretical change we can do something in these
		GStar(term): g;
		GPlus(term): g;
		GOpt(term): g;
		GNegate(term): g;
		GUnquote(term): g;
		GVar(id, power): g;

		GString(text): g;
		GRange(lower, upper): g;
	}
}

findDirectReplacement(reversed : Tree<GTerm, [string]>, rule : string, g : GTerm) -> GTerm {
	rules = getTreeArrayValue(reversed, g);
	if (rules == []) g
	else {
		if (rules[0] == rule) g
		else GVar(rules[0], 0);
	}
}
