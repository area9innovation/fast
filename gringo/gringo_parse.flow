import gringo/gringo_ast;
import gringo/gringo_pretty;
import ds/tree;
import string;
import ds/set;

export {
	gringoParse(env : GringoEnv, minPower : int, term : GTerm) -> GringoEnv;

	GringoEnv(
		input : string,
		names : Tree<string, GTerm>,
		failCache : Set<Pair<int, GTerm>>,
		i : int,
		output : string,
		fail : bool
	);
}

indent = ref "";

// The power tracking should probably be a stack with names instead
gringoParse(env : GringoEnv, minPower : int, gterm : GTerm) -> GringoEnv {
	if (containsSet(env.failCache, Pair(env.i, gterm)) || strlen(^indent) > 20) {
		GringoEnv(env with fail = true)
	} else {
		oindent = ^indent;
		println(oindent + "Parsing " + i2s(env.i) + " at power "  + i2s(minPower) + " with " + gterm2summary(gterm));
		indent := oindent + " ";
		res = switch (gterm) {
			GBind(id, term): {
				println(oindent + "Bound " + id);
				GringoEnv(
					env with names = setTree(env.names, id, term)
				);
			}
			GChoice(left, right): {
				lenv = gringoParse(env, minPower, left);
				if (lenv.fail) {
					gringoParse(env, minPower, right);
				} else lenv
			}
			GSeq(left, right): {
				lenv = gringoParse(env, minPower, left);
				if (lenv.fail) lenv
				else gringoParse(lenv, minPower, right);
			}
			GStar(term): {
				senv = gringoParse(env, minPower, term);
				if (senv.fail) {
					env;
				} else {
					gringoParse(senv, minPower, gterm);
				}
			}
			GPlus(term): {
				senv = gringoParse(env, minPower, term);
				if (senv.fail) {
					println(oindent + "Could not parse plus");
					senv;
				} else {
					gringoParse(senv, minPower, GStar(term));
				}
			}
			GOpt(term): {
				senv = gringoParse(env, minPower, term);
				if (senv.fail) {
					env;
				} else {
					senv;
				}
			}
			GNegate(term): {
				senv = gringoParse(env, minPower, term);
				if (senv.fail) {
					GringoEnv(senv with fail = false);
				} else {
					println(oindent + "Do not accept term");
					GringoEnv(env with fail = true);
				}
			}
			GUnquote(term): {
				un = unquoteGTerm(env, term);
				GringoEnv(
					env with output = env.output + un
				)
			}
			GString(text): {
				if (strContainsAt(env.input, env.i, text)) {
					GringoEnv(
						env with i = env.i + strlen(text)
					)
				} else {
					println(oindent + "Could not parse " + text);
					GringoEnv(env with fail = true)
				}
			}
			GRange(lower, upper): {
				code = getCharCodeAt(env.input, env.i);
				if (lower <= code && code <= upper) {
					GringoEnv(
						env with i = env.i + 1
					)
				} else {
					GringoEnv(env with fail = true)
				}
			}
			GVar(id, power): {
				mterm = lookupTree(env.names, id);
				mterm ?? {
					if (false && power < minPower) {
						println(oindent + "Should we recurse into " + id + " at power " + i2s(power) + " when we have " + i2s(minPower));
						env;
					} else {
						res = gringoParse(env, power, mterm);
						if (!res.fail) {
							println(oindent + "Parsed " + id);
						}
						res;
					}
				} : {
					println(oindent + "Unknown name");
					GringoEnv(env with fail = true);
				}
			}
		}
		// println(oindent + "Parsed " + i2s(res.i) + " " + if(res.fail) " failed" else "");

		indent := oindent;
		res;

	}
}

unquoteGTerm(env : GringoEnv, term : GTerm) -> string {
	switch (term) {
		GString(text): text;
		GVar(id, power): {
			mbind = lookupTree(env.names, id);
			mbind ?? {
				unquoteGTerm(env, mbind)
			} : {
				println("Could not unquote " + id);
				"";
			}
		}
		default: {
			println("Could not unquote");
			"";
		}
	}
}
