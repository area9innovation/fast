import gringo/gringo_ast;
import ds/treeutils;

export {
	// Construct a map of all rules
	findRules(acc : Tree<string, GTerm>, g : GTerm) -> Tree<string, GTerm>;

	// Find the definition of this rule
	findRule(rule : string, g : GTerm) -> Maybe<GTerm>;

	// What is the main rule we should run?
	mainRule(g : GTerm) -> string;

	// Does basic replacement in the term, except in a named rule
	replaceTerm(find : GTerm, replace : GTerm, exceptInRule : string, g : GTerm) -> GTerm;
}

// Extract rule definitioms. We only support a seq of rules. Not deeply nested rules.
findRules(acc : Tree<string, GTerm>, g : GTerm) -> Tree<string, GTerm> {
	switch (g) {
		GRule(id, term, body): {
			if (containsKeyTree(acc, id)) {
				println("Duplicate rule " + id);
			}
			nacc = setTree(acc, id, term);
			findRules(nacc, body);
		}

		GSeq(left, right): findRules(findRules(acc, left), right);

		// TODO: Check that these do not have recursive rules
		GChoice(left, right): acc;
		GStar(term): acc;
		GPlus(term): acc;
		GOpt(term): acc;
		GNegate(term): acc;

		GUnquote(term): acc;
		GString(text): acc;
		GRange(lower, upper): acc;
		GVar(id, power): acc;
		GEpsilon(): acc;
	}	
}

findRule(rule : string, g : GTerm) -> Maybe<GTerm> {
	switch (g) {
		GRule(id, term, body): if (id == rule) Some(term) else findRule(rule, body);
		GChoice(left, right): {
			mleft = findRule(rule, left);
			mleft ?? Some(mleft) : {
				findRule(rule, right);
			}
		}
		GSeq(left, right): {
			mleft = findRule(rule, left);
			mleft ?? Some(mleft) : {
				findRule(rule, right);
			}
		}
		GStar(term): findRule(rule, term);
		GPlus(term): findRule(rule, term);
		GOpt(term): findRule(rule, term);
		GNegate(term): findRule(rule, term);
		GUnquote(term): findRule(rule, term);
		GString(text): None();
		GRange(lower, upper): None();
		GVar(id, power): None();
		GEpsilon(): None();
	}
}

mainRule(g : GTerm) -> string {
	switch (g) {
		GRule(id, term, body): mainRule(body);
		GChoice(left, right): mainRule(right);
		GSeq(left, right): mainRule(right);
		GStar(term): mainRule(term);
		GPlus(term): mainRule(term);
		GOpt(term): mainRule(term);
		GNegate(term): mainRule(term);
		GUnquote(term): mainRule(term);
		GString(text): "";
		GRange(lower, upper): "";
		GVar(id, power): id;
		GEpsilon(): "";
	}
}

// Does basic replacement in the term
replaceTerm(find : GTerm, replace : GTerm, exceptInRule : string, g : GTerm) -> GTerm {
	if (g == find) replace
	else switch (g) {
		GRule(id, term, body): {
			nbody = replaceTerm(find, replace, exceptInRule, body);
			nterm = if (exceptInRule == id) term else replaceTerm(find, replace, exceptInRule, term);
			GRule(id, nterm, nbody);
		}
		GChoice(left, right): GChoice(replaceTerm(find, replace, exceptInRule, left), replaceTerm(find, replace, exceptInRule, right)); 
		GSeq(left, right): GSeq(replaceTerm(find, replace, exceptInRule, left), replaceTerm(find, replace, exceptInRule, right));
		GStar(term): GStar(replaceTerm(find, replace, exceptInRule, term));
		GPlus(term): GPlus(replaceTerm(find, replace, exceptInRule, term));
		GOpt(term): GOpt(replaceTerm(find, replace, exceptInRule, term));
		GNegate(term): GNegate(replaceTerm(find, replace, exceptInRule, term));
		GUnquote(term): GUnquote(replaceTerm(find, replace, exceptInRule, term));
		GString(text): g;
		GRange(lower, upper): g;
		GVar(id, power): g;
		GEpsilon(): g;
	}
}
