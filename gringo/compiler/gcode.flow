import gringo/gringo_ast;
import gringo/gringo_pretty;
import gringo/utils;
import text/blueprint;

export {
	makeGTermParser(g : GTerm) -> string;
}

/*
TODO:
- Compile error handler

The flow-parser takes a SyntaxParseAcc and returns the result.


*/

makeGTermParser(g : GTerm) -> string {
	main = mainRule(g);
	blueprint("
		// Produced by  flowcpp gringo/gringo.flow -- file=<file>.gringo compile=1
		import gringo/gringo_env;
		import string;
		
		export {
			parse_%main%(GringoEnv) -> GringoEnv;
		}

		%term%"
		, [
			"term", compileGTerm(g, ref 0, "env"),
			"main", main
		]
	);
}


compileGTerm(g : GTerm, var : ref int, envname : string) -> string {
	newid = \ -> {
		var := ^var + 1;
		"var" + i2s(^var)
	}
	switch (g) {
		GRule(id, term, body): {
			blueprint("
				parse_%id%(env : GringoEnv) -> GringoEnv {
					%term%
				}

				%body%", ["id", id,
					"term", compileGTerm(term, var, "env"),
					"body", {
						switch (body) {
							GVar(__): ""
							default: compileGTerm(body, var, "")
						}
					}
				]
			)
		}
		GPrecedence(left, right): "ERROR";
		GChoice(left, right): {
			blueprint("
				{
					// Choice
					%var% = %left%;
					if (%var%.fail) {
						%right%
					} else %var%
				}
				", [
					"var", newid(),
					"left", compileGTerm(left, var, envname),
					"right", compileGTerm(right, var, envname)
				]
			)
		}
		GSeq(left, right): {
			lvar = newid();
			blueprint("
				{
					// seq
					%var% = %left%;
					if (%var%.fail) {
						GringoEnv(%env% with fail = true)
					} else {
						%right%
					}
				}", [
					"var", lvar,
					"env", envname,
					"left", compileGTerm(left, var, envname),
					"right", compileGTerm(right, var, lvar)
				]
			);
		}
		GStar(term): {
			blueprint("
				{
					// *
					%var% = ref \\acc -> acc;
					%var% := \\acc -> {
						senv = %term%;
						if (senv.fail) {
							acc
						} else {
							(^%var%)(senv)
						}
					};
					(^%var%)(%env%);
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, "acc"),
				]
			);
		}
		GPlus(term): {
			compileGTerm(
				GSeq(term, GStar(term)), var, envname
			);
		}
		GOpt(term): {
			blueprint("
				{
					// Opt
					%var% = %term%;
					if (%var%.fail) {
						%env%
					} else {
						%var%
					}
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, envname),
				]
			);
		}
		GNegate(term): {
			blueprint("
				{
					// Negate
					%var% = %term%;
					if (%var%.fail) {
						GringoEnv(%var% with fail = false);
					} else {
						GringoEnv(%env% with fail = true);
					}
				}", [
					"env", envname,
					"var", newid(),
					"term", compileGTerm(term, var, envname),
				]
			);
		}
		GError(term): {
			switch (term) {
				GNegate(nterm): {
					blueprint("
						{
							// Negative error
							%var% = %nterm%;
							if (%var%.fail) {
								GringoEnv(%var% with fail = true);
							} else {
								GringoEnv(
									%var% with errors = setTree(%env%.errors, %env%.i, %error%)
								);
							}
						}", [
							"env", envname,
							"var", newid(),
							"nterm", compileGTerm(nterm, var, envname),
							"error", toString("Superfluous " + makeGExplanation(nterm))
						]
					);
				}
				default: {
					blueprint("
						{
							// Error handling
							%var% = %term%;
							if (%var%.fail) {
								GringoEnv(
									%var% with fail = false, 
									errors = setTree(%env%.errors, %env%.i, %error%)
								);
							} else {
								%var%
							}
						}", [
							"env", envname,
							"var", newid(),
							"term", compileGTerm(term, var, envname),
							"error", toString("Expected " + makeGExplanation(term))
						]
					);
				}
			}
		}
		GLower(term): compileGTerm(term, var, envname);
		GUnquote(term): {
			def = \ -> {
				blueprint("
					{
						// Unquote matched
						%var% = %term%;
						if (%var%.fail) {
							%var%;
						} else {
							starti = %env%.i;
							matched = substring(%env%.input, starti, %var%.i - starti);
							GringoEnv(%var% with output = %env%.action.addMatched(%var%.output, matched))
						}
					}", [
						"env", envname,
						"var", newid(),
						"term", compileGTerm(term, var, envname),
					]
				);
			};
			switch (term) {
				GString(text): {
					blueprint("GringoEnv(%env% with output = %env%.action.addVerbatim(%env%.output, %text%))", [
							"env", envname,
							"text", toString(text)
						]
					);
				}
				GUnquote(nt): {
					switch (nt) {
						GString(text): {
							blueprint("GringoEnv(%env% with output = %env%.action.addMatched(%env%.output, %text%))", [
									"env", envname,
									"text", toString(text)
								]
							);
						}
						GVar(id): {
							if (id == "pos") {
								blueprint("GringoEnv(%env% with output = %env%.action.addVerbatim(%env%.output, i2s(%env%.i))", [
										"env", envname,
									]
								);
							} else def();
						}
						default: {
							def();
						}
					}
				}
				default: def();
			}
		}
		GString(text): {
			blueprint("
				if (strContainsAt(%env%.input, %env%.i, %text%)) {
					ni = %env%.i + %length%;
					GringoEnv(
						%env% with i = ni,
						maxi = max(%env%.maxi, ni)
					)
				} else {
					GringoEnv(%env% with fail = true)
				}", [
					"env", envname,
					"text", toString(text),
					"length", i2s(strlen(text)),
				]
			);
		}
		GRange(lower, upper): {
			blueprint("
				{
					// Range
					%code% = getCharCodeAt(%env%.input, %env%.i);
					if (%lower% <= %code% && %code% <= %upper%) {
						ni = %env%.i + 1;
						GringoEnv(
							%env% with i = ni,
							maxi = max(%env%.maxi, ni)
						)
					} else {
						GringoEnv(%env% with fail = true)
					}
				}", [
					"env", envname,
					"code", newid(),
					"lower", i2s(lower),
					"upper", i2s(upper)
				]
			);
		}
		GVar(id): {
			"parse_" + id + "(" + envname + ")";
		}
		GEpsilon():	envname;
	}
}
