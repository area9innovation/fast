import gringo/compiler/dcode_lib;
import gringo/compiler/dopcode;
import gringo/compiler/dopcode_opt;
import gringo/compiler/dopcode_code;
import gringo/utils;
import text/blueprint;

export {
	/*
	TODO: This works well, but we should do some
	intermediate representation so we can optimize 
	restore/discard pairs
	*/
	makeDExpParser(g : GTerm, file : string) -> string;
}

makeDExpParser(g : GTerm, file : string) -> string {
	
	term = if (false) compileDExp(g) else opcode2code(optimizeDOpCode(compileDExp2(g)));

	main = mainRule(g);
	blueprint("
		// Produced by  flowcpp gringo/gringo.flow -- file=%file%.gringo compile=1
		import gringo/compiler/dcode_lib;
		import string;
		
		export {
			parse_%main%(DParseAcc) -> bool;
		}

		%term%"
		, [
			"file", file,
			"term", term,
			"main", main
		]
	);
}

compileDExp(t : GTerm) -> string {
	switch (t) {
		GRule(id, term, body): {
			blueprint("
				parse_%id%(acc : DParseAcc) -> bool {
					%term%
				}

				%body%", [
					"id", id,
					"term", compileDExp(term),
					"body", {
						switch (body) {
							GVar(__): ""
							default: compileDExp(body)
						}
					}
				]
			)
		}
		GPrecedence(left, right): "NOT EXPECTED!";
		GChoice(left, right): {
			blueprint("
				{
					// choice
					pushDCheckpoint(acc);
					if (%left%) {
						discardDCheckpoint(acc);
						true
					} else {
						restoreDCheckpoint(acc);
						%right%
					}
				}
			",
			[
				"left", compileDExp(left),
				"right", compileDExp(right),
			]);
		}
		GSeq(left, right): {
			blueprint("
				{
					// seq
					pushDCheckpoint(acc);
					if (%left%) {
						discardDCheckpoint(acc);
						%right%
					} else {
						restoreDCheckpoint(acc);
						false;
					}
				}
			",
			[
				"left", compileDExp(left),
				"right", compileDExp(right),
			]);
		}
		GStar(term): {
			blueprint("
				parseStar(acc, \\ -> {
					%term%
				})
			", [
				"term", compileDExp(term)
			]);
		}
		GPlus(term): {
			compileDExp(
				GSeq(term, GStar(term))
			);
		}
		GOpt(term): {
			blueprint("
			{
				// Opt
				pushDCheckpoint(acc);
				if (%term%) {
					discardDCheckpoint(acc);
				} else {
					restoreDCheckpoint(acc);
				};
				true;
			}
			", [
				"term", compileDExp(term)
			])
		}
		GNegate(term): {
			blueprint("
				{
					// Negate
					pushDCheckpoint(acc);
					if (%term%) {
						restoreDCheckpoint(acc);
						false;
					} else {
						restoreDCheckpoint(acc);
						true;
					}
				}", [
					"term", compileDExp(term),
				]
			);
		}
		GError(term): {
			switch (term) {
				GNegate(nterm): {
					blueprint("
						{
							// Negative error
							if (%nterm%) {
								addError(acc, %error%);
								true
							} else true
						}", [
							"nterm", compileDExp(nterm),
							"error", toString("Superfluous " + makeGExplanation(nterm))
						]
					);
				}
				default: {
					blueprint("
						{
							// Error handling
							if (%term%) {
								true
							} else {
								addError(acc, %error%);
								true;
							}
						}", [
							"term", compileDExp(term),
							"error", toString("Expected " + makeGExplanation(term))
						]
					);
				}
			}
		}
		GLower(term): compileDExp(term);
		GUnquote(term): {
			def = \ -> {
				blueprint("
					{
						// Unquote match
						starti = acc.i;
						if (%term%) {
							addMatched(acc, substring(acc.input, starti, acc.i - starti));
							true;
						} else false;
					}
				", [
					"term", compileDExp(term)
				])
			}
			switch (term) {
				GString(text): {
					"addVerbatim(acc, " + toString(text) + ")"
				}
				GUnquote(nt): {
					switch (nt) {
						GString(text): {
							"addMatched(acc, " + toString(text) + ")"
						}
						GVar(id): {
							if (id == "pos") {
								"addVerbatim(acc, i2s(acc.i))"
							} else def();
						}
						default: def();
					}
				}
				default: def();
			}
		}
		GString(text): {
			"matchString(acc, " + toString(text) + ")"
		}
		GRange(lower, upper): {
			"matchRange(acc, " + i2s(lower) + ", " + i2s(upper) + ")"
		}
		GVar(id): "parse_" + id + "(acc)";
		GEpsilon(): "";
	}
}

compileDExp2(t : GTerm) -> DOpCode {
	switch (t) {
		GRule(id, term, body): {
			DFunction(id, compileDExp2(term),
				switch (body) {
					GVar(__): DSequence([]);
					default: compileDExp2(body)
				}
			);
		}
		GPrecedence(left, right): DSequence([]);
		GChoice(left, right): {
			DSequence([
				DPushCheckpoint(),
				DIf(
					compileDExp2(left),
					DSequence([
						DDiscardCheckpoint(),
						DTrue()
					]),
					DSequence([
						DRestoreCheckpoint(),
						compileDExp2(right),
					]),
				)
			])
		}
		GSeq(left, right): {
			DSequence([
				DPushCheckpoint(),
				DIf(
					compileDExp2(left),
					DSequence([
						DDiscardCheckpoint(),
						compileDExp2(right),
					]),
					DSequence([
						DRestoreCheckpoint(),
						DFalse()
					]),
				)
			])
		}
		GStar(term): {
			DParseStar(compileDExp2(term));
		}
		GPlus(term): {
			compileDExp2(
				GSeq(term, GStar(term))
			);
		}
		GOpt(term): {
			DSequence([
				DPushCheckpoint(),
				DIf(
					compileDExp2(term),
					DDiscardCheckpoint(),
					DRestoreCheckpoint(),
				),
				DTrue()
			])
		}
		GNegate(term): {
			DSequence([
				DPushCheckpoint(),
				DIf(
					compileDExp2(term),
					DSequence([
						DRestoreCheckpoint(),
						DFalse(),
					]),
					DSequence([
						DRestoreCheckpoint(),
						DTrue()
					]),
				)
			])
		}
		GError(term): {
			switch (term) {
				GNegate(nterm): {
					DIf(
						compileDExp2(nterm),
						DSequence([
							DAddError("Superfluous " + makeGExplanation(nterm)),
							DTrue(),
						]),
						DTrue()
					);
				}
				default: {
					DIf(
						compileDExp2(term),
						DTrue(),
						DSequence([
							DAddError("Expected " + makeGExplanation(term)),
							DTrue(),
						]),
					);
				}
			}
		}
		GLower(term): compileDExp2(term);
		GUnquote(term): {
			def = \ -> {
				DSequence([
					DCaptureI(),
					DIf(
						compileDExp2(term),
						DSequence([
							DMatched(),
							DTrue(),
						]),
						DFalse()
					)
				])
			}
			switch (term) {
				GString(text): {
					DAddVerbatim(DString(text));
				}
				GUnquote(nt): {
					switch (nt) {
						GString(text): {
							DAddMatched(DString(text));
						}
						GVar(id): {
							if (id == "pos") {
								DAddVerbatim(DPosition());
							} else def();
						}
						default: def();
					}
				}
				default: def();
			}
		}
		GString(text): {
			DMatchString(text)
		}
		GRange(lower, upper): {
			DMatchRange(lower, upper);
		}
		GVar(id): DCall(id);
		GEpsilon(): DSequence([]);
	}
}
