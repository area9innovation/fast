import gringo/compiler/dcode_lib;
import gringo/utils;
import text/blueprint;

export {
	makeDExpParser(g : GTerm, file : string) -> string;
}


makeDExpParser(g : GTerm, file : string) -> string {
	dexp = compileDExp(g);
	println(dexp);

	main = mainRule(g);
	blueprint("
		// Produced by  flowcpp gringo/gringo.flow -- file=%file%.gringo compile=1
		import gringo/compiler/dcode_lib;
		import string;
		
		export {
			parse_%main%(DParseAcc) -> bool;
		}

		%term%"
		, [
			"file", file,
			"term", compileDExp(g),
			"main", main
		]
	);
}



compileDExp(t : GTerm) -> string {
	switch (t) {
		GRule(id, term, body): {
			blueprint("
				parse_%id%(acc : DParseAcc) -> bool {
					%term%
				}

				%body%", [
					"id", id,
					"term", compileDExp(term),
					"body", {
						switch (body) {
							GVar(__): ""
							default: compileDExp(body)
						}
					}
				]
			)
		}
		GPrecedence(left, right): "NOT EXPECTED!";
		GChoice(left, right): {
			blueprint("
				{
					// choice
					pushDCheckpoint(acc);
					if (%left%) {
						discardDCheckpoint(acc);
						true
					} else {
						restoreDCheckpoint(acc);
						%right%
					}
				}
			",
			[
				"left", compileDExp(left),
				"right", compileDExp(right),
			]);
		}
		GSeq(left, right): {
			blueprint("
				{
					// seq
					pushDCheckpoint(acc);
					if (%left%) {
						discardDCheckpoint(acc);
						%right%
					} else {
						restoreDCheckpoint(acc);
						false;
					}
				}
			",
			[
				"left", compileDExp(left),
				"right", compileDExp(right),
			]);
		}
		GStar(term): {
			blueprint("
				parseStar(acc, \\ -> {
					%term%
				})
			", [
				"term", compileDExp(term)
			]);
		}
		GPlus(term): {
			compileDExp(
				GSeq(term, GStar(term))
			);
		}
		GOpt(term): {
			blueprint("
			{
				// Opt
				pushDCheckpoint(acc);
				if (%term%) {
					discardDCheckpoint(acc);
				} else {
					restoreDCheckpoint(acc);
				};
				true;
			}
			", [
				"term", compileDExp(term)
			])
		}
		GNegate(term): {
			blueprint("
				{
					// Negate
					pushDCheckpoint(acc);
					if (%term%) {
						restoreDCheckpoint(acc);
						false;
					} else {
						restoreDCheckpoint(acc);
						true;
					}
				}", [
					"term", compileDExp(term),
				]
			);
		}
		GError(term): {
			switch (term) {
				GNegate(nterm): {
					blueprint("
						{
							// Negative error
							if (%nterm%) {
								addError(acc, %error%);
								true
							} else true
						}", [
							"nterm", compileDExp(nterm),
							"error", toString("Superfluous " + makeGExplanation(nterm))
						]
					);
				}
				default: {
					blueprint("
						{
							// Error handling
							if (%term%) {
								true
							} else {
								addError(acc, %error%);
								true;
							}
						}", [
							"term", compileDExp(term),
							"error", toString("Expected " + makeGExplanation(term))
						]
					);
				}
			}
		}
		GLower(term): compileDExp(term);
		GUnquote(term): {
			def = \ -> {
				blueprint("
					{
						// Unquote match
						starti = acc.i;
						if (%term%) {
							addMatched(acc, substring(acc.input, starti, acc.i - starti));
							true;
						} else false;
					}
				", [
					"term", compileDExp(term)
				])
			}
			switch (term) {
				GString(text): {
					"addVerbatim(acc, " + toString(text) + ")"
				}
				GUnquote(nt): {
					switch (nt) {
						GString(text): {
							"addMatched(acc, " + toString(text) + ")"
						}
						GVar(id): {
							if (id == "pos") {
								"addVerbatim(acc, i2s(acc.i))"
							} else def();
						}
						default: def();
					}
				}
				default: def();
			}
		}
		GString(text): {
			"matchString(acc, " + toString(text) + ")"
		}
		GRange(lower, upper): {
			"matchRange(acc, " + i2s(lower) + ", " + i2s(upper) + ")"
		}
		GVar(id): "parse_" + id + "(acc)";
		GEpsilon(): "";
	}
}

