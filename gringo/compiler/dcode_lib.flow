import gringo/gringo_ast;
import gringo/gringo_env;
import gringo/gringo_action;
import string;
import ds/tree;

export {
	// TODO: Introduce maxi

	DParseAcc(
		input : string,
		action : GringoAction<?>,

		mutable i : int,
		// What is the result of the semantic actions so far?
		mutable output : ?,
		// What errors did we get?
		mutable errors : Tree<int, string>,
		// A stack of checkpoints
		mutable stack : List<DCheckpoint<?>>
	);
	DCheckpoint(i : int, output : ?, errors : Tree<int, string>);

	DParseAcc2GringoEnv(d : DParseAcc) -> GringoEnv;
	GringoEnv2DParseAcc(g : GringoEnv) -> DParseAcc;


	pushDCheckpoint(acc : DParseAcc<?>) -> void;
	discardDCheckpoint(acc : DParseAcc) -> void;
	restoreDCheckpoint(acc : DParseAcc) -> void;
	parseStar(acc : DParseAcc<?>, matcher : () -> bool) -> bool;
	matchString(acc : DParseAcc<?>, s : string) -> bool;
	matchRange(acc : DParseAcc<?>, l : int, u : int) -> bool;
	addVerbatim(acc : DParseAcc<?>, text : string) -> bool;
	addMatched(acc : DParseAcc<?>, text : string) -> bool;
	addError(acc : DParseAcc<?>, text : string) -> bool;
}

DParseAcc2GringoEnv(d : DParseAcc) -> GringoEnv {
	GringoEnv(
		d.input,
		makeTree(),
		d.action,
		d.output,
		d.errors,
		d.i,
		d.i != strlen(d.input),
		0,
	);
}

GringoEnv2DParseAcc(g : GringoEnv) -> DParseAcc {
	DParseAcc(g.input, g.action, g.i, g.output, g.errors, makeList())
}


pushDCheckpoint(acc : DParseAcc<?>) -> void {
	acc.stack ::= Cons(DCheckpoint(acc.i, acc.output, acc.errors), acc.stack);
}

discardDCheckpoint(acc : DParseAcc) -> void {
	switch (acc.stack) {
		EmptyList(): {}
		Cons(head, tail_): {
			acc.stack ::= tail_;
		}
	}
}

restoreDCheckpoint(acc : DParseAcc) -> void {
	switch (acc.stack) {
		EmptyList(): {}
		Cons(head, tail_): {
			acc.i ::= head.i;
			acc.output ::= head.output;
			acc.errors ::= head.errors;
			acc.stack ::= tail_;
		}
	}
}

parseStar(acc : DParseAcc<?>, matcher : () -> bool) -> bool {
	pushDCheckpoint(acc);
	if (matcher()) {
		discardDCheckpoint(acc);
		parseStar(acc, matcher)
	} else {
		restoreDCheckpoint(acc);
		true;
	};
}

matchString(acc : DParseAcc<?>, s : string) -> bool {
	if (strContainsAt(acc.input, acc.i, s)) {
		acc.i ::= acc.i + strlen(s);
		true;
	} else false;
}

matchRange(acc : DParseAcc<?>, l : int, u : int) -> bool {
	code = getCharCodeAt(acc.input, acc.i);
	if (l <= code && code <= u) {
		acc.i ::= acc.i + 1;
		true;
	} else false;
}

addVerbatim(acc : DParseAcc<?>, text : string) -> bool {
	acc.output ::= acc.action.addVerbatim(acc.output, text);
	true;
}

addMatched(acc : DParseAcc<?>, text : string) -> bool {
	acc.output ::= acc.action.addMatched(acc.output, text);
	true;
}

addError(acc : DParseAcc<?>, text : string) -> bool {
	acc.errors ::= setTree(acc.errors, acc.i, text);
	true;
}
