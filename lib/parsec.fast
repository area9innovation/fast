import string_utils;
import partial_call;
import combinators;
import tuples;
import array;

export {
    // Parser combinator library.
    // Each parser combinator generates a parser function of following signature:
    // 
    //    (input : string,  position : i32) -> Tuple<i32, ?>;
    //
    // The return tuple components:
    // - the first one (i32) - is a new position after action of parser. In case of match failure it is -1.
    // - the second one - the result of semantic action processing on the inputs.
    //
    // Arguments to the parser combinators:
    // - other parsers: 
    //     par_1 : (string, i32) -> Tuple<i32, ?>, 
    //     par_2 : (string, i32) -> Tuple<i32, ??>, 
    //       ... 
    //     par_k : (string, i32) -> Tuple<i32, ???...?>
    //
    // - semantic_action: 
    //     (arg_1 : ?, arg_2 : ?? , ... , arg_k : ???..?) -> ???...??
    //
    // - failure value


    // Empty sequence parser combinator
    emptyParseC(
        sem_act : () -> ?
    ) -> (string, i32) -> Tuple<i32, ?>;

    // Triggers at the end of the input
    inputEndParseC(
        sem_act : () -> ?,
        fail : ?
    ) -> (string, i32) -> Tuple<i32, ?>;

    // Fixed string parser combinator
    tokenParseC(
        pattern : string, 
        sem_act : (string) -> ?,
        fail : ?,
    ) -> (string, i32) -> Tuple<i32, ?>;

    // Apply a semantic action to a parser output
    modifyParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        sem_act : (?) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Sequential parsers
    sequenceParseC(
        parser1 : (string, i32) -> Tuple<i32, ?>,
        parser2 : (string, i32) -> Tuple<i32, ??>,
        sem_act : (?, ??) -> ???,
        fail : ???
    ) -> (string, i32) -> Tuple<i32, ???>;

    // Ordered choice of two parsers. If some triggers, further are not operated.
    choiceParseC(
        parser1 : (string, i32) -> Tuple<i32, ?>,
        parser2 : (string, i32) -> Tuple<i32, ?>,
        sem_act : (?) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Ordered choice of an array of parsers. If some triggers, further are not operated.
    choiceManyParseC(
        parsers : Array<(string, i32) -> Tuple<i32, ?> >,
        sem_act : (?) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Kleene star
    starParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        sem_act : (Array<?>) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Kleene plus
    plusParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        sem_act : (Array<?>) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Optional: may parse or not
    optionalParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        sem_act : (?) -> ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // And predicate: must match the input, but do not consume input stream
    andPredicateParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        success : ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;

    // Not predicate: must mismatch the input, do not consume input stream
    notPredicateParseC(
        parser : (string, i32) -> Tuple<i32, ?>,
        success : ??,
        fail : ??
    ) -> (string, i32) -> Tuple<i32, ??>;
}

compiletime::emptyParseC(
    sem_act : () -> ?
) -> (string, i32) -> Tuple<i32, ?> {
    compiletime::partialCall(emptyParseCimpl, sem_act);
}

emptyParseCimpl(sem_act : () -> ?, input : string, i : i32) -> Tuple<i32, ?> {
    tuple(i, sem_act());
}


compiletime::inputEndParseC(
    sem_act : () -> ?,
    fail : ?
) -> (string, i32) -> Tuple<i32, ?> {
    compiletime::partialCall(inputEndParseCimpl, sem_act, fail)
}

inputEndParseCimpl(sem_act : () -> ?, fail : ?, input : string, i : i32) -> Tuple<i32, ?> {
    if (i == length(input)) {
        tuple(i, sem_act());
    } else {
        tuple(-(1), fail);
    }
} 

compiletime::tokenParseC(
    pattern : string, 
    sem_act : (string) -> ?, 
    fail : ?
) -> (string, i32) -> Tuple<i32, ?> {
    compiletime::partialCall(tokenParseCimpl, pattern, sem_act, fail);
}

tokenParseCimpl(
    pattern : string, 
    sem_act : (string) -> ?, 
    fail : ?, 
    input : string, 
    i : i32
) -> Tuple<i32, ?> {
    doTokenParseCimpl(pattern, sem_act, fail, input, i, 0);
} 

doTokenParseCimpl(pattern : string, sem_act : (string) -> ?, fail : ?, input : string, i : i32, j : i32) -> Tuple<i32, ?> {
    if (j == length(pattern)) {
        tuple(i + j, sem_act(pattern));
    } else {
        a = index(input, i + j);
        b = index(pattern, j);
        if (a != b) {
            tuple(-(1), fail);
        } else {
            doTokenParseCimpl(pattern, sem_act, fail, input, i, j + 1);
        }
    }
}

compiletime::modifyParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (?) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(modifyParseCimpl, parser, sem_act, fail);
}

modifyParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>, 
    sem_act : (?) -> ??, 
    fail : ??, 
    input : string, 
    i : i32
) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ??>;
    j = first(p) : i32;
    x = second(p);
    y = sem_act(x);
    if (j == -(1)) {
        tuple(-(1), fail);
    } else {
        tuple(j, y);
    }
}

compiletime::sequenceParseC(
    parser1 : (string, i32) -> Tuple<i32, ?>,
    parser2 : (string, i32) -> Tuple<i32, ??>,
    sem_act : (?, ??) -> ???,
    fail : ???
) -> (string, i32) -> Tuple<i32, ???> {
    compiletime::partialCall(sequenceParseCimpl, parser1, parser2, sem_act, fail);
}

sequenceParseCimpl(
    parser1 : (string, i32) -> Tuple<i32, ?>,
    parser2 : (string, i32) -> Tuple<i32, ??>,
    sem_act : (?, ??) -> ???,
    fail : ???,
    input : string, 
    i : i32
) -> Tuple<i32, ???> {
    t1 = parser1(input, i) : Tuple<i32, ?>;
    if (0 > first(t1)) {
        tuple(-(1), fail);
    } else {
        t2 = parser2(input, first(t1)) : Tuple<i32, ??>;
        if (0 > first(t2)) {
            tuple(-(1), fail);
        } else {
            tuple(first(t2), sem_act(second(t1), second(t2)));
        }
    }
}

compiletime::choiceParseC(
    parser1 : (string, i32) -> Tuple<i32, ?>,
    parser2 : (string, i32) -> Tuple<i32, ?>,
    sem_act : (?) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(choiceParseCimpl, parser1, parser2, sem_act, fail);
}

choiceParseCimpl(
    parser1 : (string, i32) -> Tuple<i32, ?>,
    parser2 : (string, i32) -> Tuple<i32, ?>,
    sem_act : (?) -> ??,
    fail : ??,
    input : string, 
    i : i32
) -> Tuple<i32, ??> {
    t1 = modifyParseCimpl(parser1, sem_act, fail, input, i);
    if (0 <= first(t1)) {
        t1;
    } else {
        modifyParseCimpl(parser2, sem_act, fail, input, i);
    }
}

compiletime::choiceManyParseC(
    parsers : Array<(string, i32) -> Tuple<i32, ?> >,
    sem_act : (?) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(choiceManyParseCimpl, parsers, sem_act, fail);
}

choiceManyParseCimpl(
    parsers : Array<(string, i32) -> Tuple<i32, ?> >,
    sem_act : (?) -> ??,
    fail : ??,
    input : string, 
    i : i32
) -> Tuple<i32, ??> {
    doChoiceManyParseCimpl(parsers, sem_act, fail, input, i, 0);
}

doChoiceManyParseCimpl(
    parsers : Array<(string, i32) -> Tuple<i32, ?> >,
    sem_act : (?) -> ??,
    fail : ??,
    input : string, 
    i : i32,
    k : i32
) -> Tuple<i32, ??> {
    if (k == length(parsers)) {
        tuple(-(1), fail);
    } else {
        parser = index(parsers, k);
        t1 = modifyParseCimpl(parser, sem_act, fail, input, i);
        if (0 <= first(t1)) {
            t1;
        } else {
            doChoiceManyParseCimpl(parsers, sem_act, fail, input, i, k + 1);
        }
    }
}

compiletime::starParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (Array<?>) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(starParseCimpl, parser, sem_act, fail);
}

starParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (Array<?>) -> ??,
    fail : ??,
    input : string,
    i : i32
) -> (string, i32) -> Tuple<i32, ??> {
    doStarParseCimpl(parser, sem_act, fail, input, i, array());
}

compiletime::plusParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (Array<?>) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(plusParseCimpl, parser, sem_act, fail);
}

plusParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (Array<?>) -> ??,
    fail : ??,
    input : string,
    i : i32
) -> (string, i32) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ?>;
    j = first(p);
    if (j == -(1)) {
        tuple(-(1), fail);
    } else {
        doStarParseCimpl(parser, sem_act, fail, input, j, array(second(p)));
    }
}

doStarParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (Array<?>) -> ??,
    fail : ??,
    input : string,
    i : i32,
    acc : Array<?>
) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ?>;
    j = first(p);
    if (j == -(1)) {
        tuple(i, sem_act(acc));
    } else {
        x = second(p);
        new_acc = acc + array(x);
        doStarParseCimpl(parser, sem_act, fail, input, j, new_acc);
    }
}


compiletime::optionalParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (?) -> ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(optionalParseCimpl, parser, sem_act, fail);
}

optionalParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    sem_act : (?) -> ??,
    fail : ??,
    input : string,
    i : i32
) -> (string, i32) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ?>;
    j = first(p);
    if (j == -(1)) {
        tuple(i, fail);
    } else {
        x = second(p);
        tuple(j, sem_act(x));
    }
}

compiletime::andPredicateParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    success : ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(andPredicateParseCimpl, parser, success, fail);
}

andPredicateParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    success : ??,
    fail : ??,
    input : string,
    i : i32
) -> (string, i32) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ?>;
    j = first(p);
    if (j == -(1)) {
        tuple(-(1), fail);
    } else {
        tuple(i, success);
    }
}

notPredicateParseC(
    parser : (string, i32) -> Tuple<i32, ?>,
    success : ??,
    fail : ??
) -> (string, i32) -> Tuple<i32, ??> {
    compiletime::partialCall(notPredicateParseCimpl, parser, success, fail);
}

notPredicateParseCimpl(
    parser : (string, i32) -> Tuple<i32, ?>,
    success : ??,
    fail : ??,
    input : string,
    i : i32
) -> (string, i32) -> Tuple<i32, ??> {
    p = parser(input, i) : Tuple<i32, ?>;
    j = first(p);
    if (j == -(1)) {
        tuple(i, success);
    } else {
        tuple(-(1), fail);
    }
}